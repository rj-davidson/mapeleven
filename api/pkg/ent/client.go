// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"capstone-cs.eng.utah.edu/mapeleven/mapeleven/pkg/ent/migrate"

	"capstone-cs.eng.utah.edu/mapeleven/mapeleven/pkg/ent/birth"
	"capstone-cs.eng.utah.edu/mapeleven/mapeleven/pkg/ent/club"
	"capstone-cs.eng.utah.edu/mapeleven/mapeleven/pkg/ent/coach"
	"capstone-cs.eng.utah.edu/mapeleven/mapeleven/pkg/ent/country"
	"capstone-cs.eng.utah.edu/mapeleven/mapeleven/pkg/ent/fixture"
	"capstone-cs.eng.utah.edu/mapeleven/mapeleven/pkg/ent/fixtureevents"
	"capstone-cs.eng.utah.edu/mapeleven/mapeleven/pkg/ent/fixturelineups"
	"capstone-cs.eng.utah.edu/mapeleven/mapeleven/pkg/ent/league"
	"capstone-cs.eng.utah.edu/mapeleven/mapeleven/pkg/ent/matchplayer"
	"capstone-cs.eng.utah.edu/mapeleven/mapeleven/pkg/ent/player"
	"capstone-cs.eng.utah.edu/mapeleven/mapeleven/pkg/ent/playerstats"
	"capstone-cs.eng.utah.edu/mapeleven/mapeleven/pkg/ent/psdefense"
	"capstone-cs.eng.utah.edu/mapeleven/mapeleven/pkg/ent/psfairplay"
	"capstone-cs.eng.utah.edu/mapeleven/mapeleven/pkg/ent/psgames"
	"capstone-cs.eng.utah.edu/mapeleven/mapeleven/pkg/ent/pspenalty"
	"capstone-cs.eng.utah.edu/mapeleven/mapeleven/pkg/ent/psshooting"
	"capstone-cs.eng.utah.edu/mapeleven/mapeleven/pkg/ent/pssubstitutes"
	"capstone-cs.eng.utah.edu/mapeleven/mapeleven/pkg/ent/pstechnical"
	"capstone-cs.eng.utah.edu/mapeleven/mapeleven/pkg/ent/season"
	"capstone-cs.eng.utah.edu/mapeleven/mapeleven/pkg/ent/squad"
	"capstone-cs.eng.utah.edu/mapeleven/mapeleven/pkg/ent/standings"
	"capstone-cs.eng.utah.edu/mapeleven/mapeleven/pkg/ent/team"
	"capstone-cs.eng.utah.edu/mapeleven/mapeleven/pkg/ent/tsbiggest"
	"capstone-cs.eng.utah.edu/mapeleven/mapeleven/pkg/ent/tscards"
	"capstone-cs.eng.utah.edu/mapeleven/mapeleven/pkg/ent/tscleansheet"
	"capstone-cs.eng.utah.edu/mapeleven/mapeleven/pkg/ent/tsfailedtoscore"
	"capstone-cs.eng.utah.edu/mapeleven/mapeleven/pkg/ent/tsfixtures"
	"capstone-cs.eng.utah.edu/mapeleven/mapeleven/pkg/ent/tsgoals"
	"capstone-cs.eng.utah.edu/mapeleven/mapeleven/pkg/ent/tslineups"
	"capstone-cs.eng.utah.edu/mapeleven/mapeleven/pkg/ent/tspenalty"
	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Birth is the client for interacting with the Birth builders.
	Birth *BirthClient
	// Club is the client for interacting with the Club builders.
	Club *ClubClient
	// Coach is the client for interacting with the Coach builders.
	Coach *CoachClient
	// Country is the client for interacting with the Country builders.
	Country *CountryClient
	// Fixture is the client for interacting with the Fixture builders.
	Fixture *FixtureClient
	// FixtureEvents is the client for interacting with the FixtureEvents builders.
	FixtureEvents *FixtureEventsClient
	// FixtureLineups is the client for interacting with the FixtureLineups builders.
	FixtureLineups *FixtureLineupsClient
	// League is the client for interacting with the League builders.
	League *LeagueClient
	// MatchPlayer is the client for interacting with the MatchPlayer builders.
	MatchPlayer *MatchPlayerClient
	// PSDefense is the client for interacting with the PSDefense builders.
	PSDefense *PSDefenseClient
	// PSFairplay is the client for interacting with the PSFairplay builders.
	PSFairplay *PSFairplayClient
	// PSGames is the client for interacting with the PSGames builders.
	PSGames *PSGamesClient
	// PSPenalty is the client for interacting with the PSPenalty builders.
	PSPenalty *PSPenaltyClient
	// PSShooting is the client for interacting with the PSShooting builders.
	PSShooting *PSShootingClient
	// PSSubstitutes is the client for interacting with the PSSubstitutes builders.
	PSSubstitutes *PSSubstitutesClient
	// PSTechnical is the client for interacting with the PSTechnical builders.
	PSTechnical *PSTechnicalClient
	// Player is the client for interacting with the Player builders.
	Player *PlayerClient
	// PlayerStats is the client for interacting with the PlayerStats builders.
	PlayerStats *PlayerStatsClient
	// Season is the client for interacting with the Season builders.
	Season *SeasonClient
	// Squad is the client for interacting with the Squad builders.
	Squad *SquadClient
	// Standings is the client for interacting with the Standings builders.
	Standings *StandingsClient
	// TSBiggest is the client for interacting with the TSBiggest builders.
	TSBiggest *TSBiggestClient
	// TSCards is the client for interacting with the TSCards builders.
	TSCards *TSCardsClient
	// TSCleanSheet is the client for interacting with the TSCleanSheet builders.
	TSCleanSheet *TSCleanSheetClient
	// TSFailedToScore is the client for interacting with the TSFailedToScore builders.
	TSFailedToScore *TSFailedToScoreClient
	// TSFixtures is the client for interacting with the TSFixtures builders.
	TSFixtures *TSFixturesClient
	// TSGoals is the client for interacting with the TSGoals builders.
	TSGoals *TSGoalsClient
	// TSLineups is the client for interacting with the TSLineups builders.
	TSLineups *TSLineupsClient
	// TSPenalty is the client for interacting with the TSPenalty builders.
	TSPenalty *TSPenaltyClient
	// Team is the client for interacting with the Team builders.
	Team *TeamClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Birth = NewBirthClient(c.config)
	c.Club = NewClubClient(c.config)
	c.Coach = NewCoachClient(c.config)
	c.Country = NewCountryClient(c.config)
	c.Fixture = NewFixtureClient(c.config)
	c.FixtureEvents = NewFixtureEventsClient(c.config)
	c.FixtureLineups = NewFixtureLineupsClient(c.config)
	c.League = NewLeagueClient(c.config)
	c.MatchPlayer = NewMatchPlayerClient(c.config)
	c.PSDefense = NewPSDefenseClient(c.config)
	c.PSFairplay = NewPSFairplayClient(c.config)
	c.PSGames = NewPSGamesClient(c.config)
	c.PSPenalty = NewPSPenaltyClient(c.config)
	c.PSShooting = NewPSShootingClient(c.config)
	c.PSSubstitutes = NewPSSubstitutesClient(c.config)
	c.PSTechnical = NewPSTechnicalClient(c.config)
	c.Player = NewPlayerClient(c.config)
	c.PlayerStats = NewPlayerStatsClient(c.config)
	c.Season = NewSeasonClient(c.config)
	c.Squad = NewSquadClient(c.config)
	c.Standings = NewStandingsClient(c.config)
	c.TSBiggest = NewTSBiggestClient(c.config)
	c.TSCards = NewTSCardsClient(c.config)
	c.TSCleanSheet = NewTSCleanSheetClient(c.config)
	c.TSFailedToScore = NewTSFailedToScoreClient(c.config)
	c.TSFixtures = NewTSFixturesClient(c.config)
	c.TSGoals = NewTSGoalsClient(c.config)
	c.TSLineups = NewTSLineupsClient(c.config)
	c.TSPenalty = NewTSPenaltyClient(c.config)
	c.Team = NewTeamClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		Birth:           NewBirthClient(cfg),
		Club:            NewClubClient(cfg),
		Coach:           NewCoachClient(cfg),
		Country:         NewCountryClient(cfg),
		Fixture:         NewFixtureClient(cfg),
		FixtureEvents:   NewFixtureEventsClient(cfg),
		FixtureLineups:  NewFixtureLineupsClient(cfg),
		League:          NewLeagueClient(cfg),
		MatchPlayer:     NewMatchPlayerClient(cfg),
		PSDefense:       NewPSDefenseClient(cfg),
		PSFairplay:      NewPSFairplayClient(cfg),
		PSGames:         NewPSGamesClient(cfg),
		PSPenalty:       NewPSPenaltyClient(cfg),
		PSShooting:      NewPSShootingClient(cfg),
		PSSubstitutes:   NewPSSubstitutesClient(cfg),
		PSTechnical:     NewPSTechnicalClient(cfg),
		Player:          NewPlayerClient(cfg),
		PlayerStats:     NewPlayerStatsClient(cfg),
		Season:          NewSeasonClient(cfg),
		Squad:           NewSquadClient(cfg),
		Standings:       NewStandingsClient(cfg),
		TSBiggest:       NewTSBiggestClient(cfg),
		TSCards:         NewTSCardsClient(cfg),
		TSCleanSheet:    NewTSCleanSheetClient(cfg),
		TSFailedToScore: NewTSFailedToScoreClient(cfg),
		TSFixtures:      NewTSFixturesClient(cfg),
		TSGoals:         NewTSGoalsClient(cfg),
		TSLineups:       NewTSLineupsClient(cfg),
		TSPenalty:       NewTSPenaltyClient(cfg),
		Team:            NewTeamClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		Birth:           NewBirthClient(cfg),
		Club:            NewClubClient(cfg),
		Coach:           NewCoachClient(cfg),
		Country:         NewCountryClient(cfg),
		Fixture:         NewFixtureClient(cfg),
		FixtureEvents:   NewFixtureEventsClient(cfg),
		FixtureLineups:  NewFixtureLineupsClient(cfg),
		League:          NewLeagueClient(cfg),
		MatchPlayer:     NewMatchPlayerClient(cfg),
		PSDefense:       NewPSDefenseClient(cfg),
		PSFairplay:      NewPSFairplayClient(cfg),
		PSGames:         NewPSGamesClient(cfg),
		PSPenalty:       NewPSPenaltyClient(cfg),
		PSShooting:      NewPSShootingClient(cfg),
		PSSubstitutes:   NewPSSubstitutesClient(cfg),
		PSTechnical:     NewPSTechnicalClient(cfg),
		Player:          NewPlayerClient(cfg),
		PlayerStats:     NewPlayerStatsClient(cfg),
		Season:          NewSeasonClient(cfg),
		Squad:           NewSquadClient(cfg),
		Standings:       NewStandingsClient(cfg),
		TSBiggest:       NewTSBiggestClient(cfg),
		TSCards:         NewTSCardsClient(cfg),
		TSCleanSheet:    NewTSCleanSheetClient(cfg),
		TSFailedToScore: NewTSFailedToScoreClient(cfg),
		TSFixtures:      NewTSFixturesClient(cfg),
		TSGoals:         NewTSGoalsClient(cfg),
		TSLineups:       NewTSLineupsClient(cfg),
		TSPenalty:       NewTSPenaltyClient(cfg),
		Team:            NewTeamClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Birth.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Birth, c.Club, c.Coach, c.Country, c.Fixture, c.FixtureEvents,
		c.FixtureLineups, c.League, c.MatchPlayer, c.PSDefense, c.PSFairplay,
		c.PSGames, c.PSPenalty, c.PSShooting, c.PSSubstitutes, c.PSTechnical, c.Player,
		c.PlayerStats, c.Season, c.Squad, c.Standings, c.TSBiggest, c.TSCards,
		c.TSCleanSheet, c.TSFailedToScore, c.TSFixtures, c.TSGoals, c.TSLineups,
		c.TSPenalty, c.Team,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Birth, c.Club, c.Coach, c.Country, c.Fixture, c.FixtureEvents,
		c.FixtureLineups, c.League, c.MatchPlayer, c.PSDefense, c.PSFairplay,
		c.PSGames, c.PSPenalty, c.PSShooting, c.PSSubstitutes, c.PSTechnical, c.Player,
		c.PlayerStats, c.Season, c.Squad, c.Standings, c.TSBiggest, c.TSCards,
		c.TSCleanSheet, c.TSFailedToScore, c.TSFixtures, c.TSGoals, c.TSLineups,
		c.TSPenalty, c.Team,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *BirthMutation:
		return c.Birth.mutate(ctx, m)
	case *ClubMutation:
		return c.Club.mutate(ctx, m)
	case *CoachMutation:
		return c.Coach.mutate(ctx, m)
	case *CountryMutation:
		return c.Country.mutate(ctx, m)
	case *FixtureMutation:
		return c.Fixture.mutate(ctx, m)
	case *FixtureEventsMutation:
		return c.FixtureEvents.mutate(ctx, m)
	case *FixtureLineupsMutation:
		return c.FixtureLineups.mutate(ctx, m)
	case *LeagueMutation:
		return c.League.mutate(ctx, m)
	case *MatchPlayerMutation:
		return c.MatchPlayer.mutate(ctx, m)
	case *PSDefenseMutation:
		return c.PSDefense.mutate(ctx, m)
	case *PSFairplayMutation:
		return c.PSFairplay.mutate(ctx, m)
	case *PSGamesMutation:
		return c.PSGames.mutate(ctx, m)
	case *PSPenaltyMutation:
		return c.PSPenalty.mutate(ctx, m)
	case *PSShootingMutation:
		return c.PSShooting.mutate(ctx, m)
	case *PSSubstitutesMutation:
		return c.PSSubstitutes.mutate(ctx, m)
	case *PSTechnicalMutation:
		return c.PSTechnical.mutate(ctx, m)
	case *PlayerMutation:
		return c.Player.mutate(ctx, m)
	case *PlayerStatsMutation:
		return c.PlayerStats.mutate(ctx, m)
	case *SeasonMutation:
		return c.Season.mutate(ctx, m)
	case *SquadMutation:
		return c.Squad.mutate(ctx, m)
	case *StandingsMutation:
		return c.Standings.mutate(ctx, m)
	case *TSBiggestMutation:
		return c.TSBiggest.mutate(ctx, m)
	case *TSCardsMutation:
		return c.TSCards.mutate(ctx, m)
	case *TSCleanSheetMutation:
		return c.TSCleanSheet.mutate(ctx, m)
	case *TSFailedToScoreMutation:
		return c.TSFailedToScore.mutate(ctx, m)
	case *TSFixturesMutation:
		return c.TSFixtures.mutate(ctx, m)
	case *TSGoalsMutation:
		return c.TSGoals.mutate(ctx, m)
	case *TSLineupsMutation:
		return c.TSLineups.mutate(ctx, m)
	case *TSPenaltyMutation:
		return c.TSPenalty.mutate(ctx, m)
	case *TeamMutation:
		return c.Team.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// BirthClient is a client for the Birth schema.
type BirthClient struct {
	config
}

// NewBirthClient returns a client for the Birth from the given config.
func NewBirthClient(c config) *BirthClient {
	return &BirthClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `birth.Hooks(f(g(h())))`.
func (c *BirthClient) Use(hooks ...Hook) {
	c.hooks.Birth = append(c.hooks.Birth, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `birth.Intercept(f(g(h())))`.
func (c *BirthClient) Intercept(interceptors ...Interceptor) {
	c.inters.Birth = append(c.inters.Birth, interceptors...)
}

// Create returns a builder for creating a Birth entity.
func (c *BirthClient) Create() *BirthCreate {
	mutation := newBirthMutation(c.config, OpCreate)
	return &BirthCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Birth entities.
func (c *BirthClient) CreateBulk(builders ...*BirthCreate) *BirthCreateBulk {
	return &BirthCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BirthClient) MapCreateBulk(slice any, setFunc func(*BirthCreate, int)) *BirthCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BirthCreateBulk{err: fmt.Errorf("calling to BirthClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BirthCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BirthCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Birth.
func (c *BirthClient) Update() *BirthUpdate {
	mutation := newBirthMutation(c.config, OpUpdate)
	return &BirthUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BirthClient) UpdateOne(b *Birth) *BirthUpdateOne {
	mutation := newBirthMutation(c.config, OpUpdateOne, withBirth(b))
	return &BirthUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BirthClient) UpdateOneID(id int) *BirthUpdateOne {
	mutation := newBirthMutation(c.config, OpUpdateOne, withBirthID(id))
	return &BirthUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Birth.
func (c *BirthClient) Delete() *BirthDelete {
	mutation := newBirthMutation(c.config, OpDelete)
	return &BirthDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BirthClient) DeleteOne(b *Birth) *BirthDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BirthClient) DeleteOneID(id int) *BirthDeleteOne {
	builder := c.Delete().Where(birth.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BirthDeleteOne{builder}
}

// Query returns a query builder for Birth.
func (c *BirthClient) Query() *BirthQuery {
	return &BirthQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBirth},
		inters: c.Interceptors(),
	}
}

// Get returns a Birth entity by its id.
func (c *BirthClient) Get(ctx context.Context, id int) (*Birth, error) {
	return c.Query().Where(birth.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BirthClient) GetX(ctx context.Context, id int) *Birth {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlayer queries the player edge of a Birth.
func (c *BirthClient) QueryPlayer(b *Birth) *PlayerQuery {
	query := (&PlayerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(birth.Table, birth.FieldID, id),
			sqlgraph.To(player.Table, player.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, birth.PlayerTable, birth.PlayerColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BirthClient) Hooks() []Hook {
	return c.hooks.Birth
}

// Interceptors returns the client interceptors.
func (c *BirthClient) Interceptors() []Interceptor {
	return c.inters.Birth
}

func (c *BirthClient) mutate(ctx context.Context, m *BirthMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BirthCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BirthUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BirthUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BirthDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Birth mutation op: %q", m.Op())
	}
}

// ClubClient is a client for the Club schema.
type ClubClient struct {
	config
}

// NewClubClient returns a client for the Club from the given config.
func NewClubClient(c config) *ClubClient {
	return &ClubClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `club.Hooks(f(g(h())))`.
func (c *ClubClient) Use(hooks ...Hook) {
	c.hooks.Club = append(c.hooks.Club, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `club.Intercept(f(g(h())))`.
func (c *ClubClient) Intercept(interceptors ...Interceptor) {
	c.inters.Club = append(c.inters.Club, interceptors...)
}

// Create returns a builder for creating a Club entity.
func (c *ClubClient) Create() *ClubCreate {
	mutation := newClubMutation(c.config, OpCreate)
	return &ClubCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Club entities.
func (c *ClubClient) CreateBulk(builders ...*ClubCreate) *ClubCreateBulk {
	return &ClubCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ClubClient) MapCreateBulk(slice any, setFunc func(*ClubCreate, int)) *ClubCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ClubCreateBulk{err: fmt.Errorf("calling to ClubClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ClubCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ClubCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Club.
func (c *ClubClient) Update() *ClubUpdate {
	mutation := newClubMutation(c.config, OpUpdate)
	return &ClubUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ClubClient) UpdateOne(cl *Club) *ClubUpdateOne {
	mutation := newClubMutation(c.config, OpUpdateOne, withClub(cl))
	return &ClubUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ClubClient) UpdateOneID(id int) *ClubUpdateOne {
	mutation := newClubMutation(c.config, OpUpdateOne, withClubID(id))
	return &ClubUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Club.
func (c *ClubClient) Delete() *ClubDelete {
	mutation := newClubMutation(c.config, OpDelete)
	return &ClubDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ClubClient) DeleteOne(cl *Club) *ClubDeleteOne {
	return c.DeleteOneID(cl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ClubClient) DeleteOneID(id int) *ClubDeleteOne {
	builder := c.Delete().Where(club.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ClubDeleteOne{builder}
}

// Query returns a query builder for Club.
func (c *ClubClient) Query() *ClubQuery {
	return &ClubQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeClub},
		inters: c.Interceptors(),
	}
}

// Get returns a Club entity by its id.
func (c *ClubClient) Get(ctx context.Context, id int) (*Club, error) {
	return c.Query().Where(club.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ClubClient) GetX(ctx context.Context, id int) *Club {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCountry queries the country edge of a Club.
func (c *ClubClient) QueryCountry(cl *Club) *CountryQuery {
	query := (&CountryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(club.Table, club.FieldID, id),
			sqlgraph.To(country.Table, country.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, club.CountryTable, club.CountryColumn),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeam queries the team edge of a Club.
func (c *ClubClient) QueryTeam(cl *Club) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(club.Table, club.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, club.TeamTable, club.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ClubClient) Hooks() []Hook {
	return c.hooks.Club
}

// Interceptors returns the client interceptors.
func (c *ClubClient) Interceptors() []Interceptor {
	return c.inters.Club
}

func (c *ClubClient) mutate(ctx context.Context, m *ClubMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ClubCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ClubUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ClubUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ClubDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Club mutation op: %q", m.Op())
	}
}

// CoachClient is a client for the Coach schema.
type CoachClient struct {
	config
}

// NewCoachClient returns a client for the Coach from the given config.
func NewCoachClient(c config) *CoachClient {
	return &CoachClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `coach.Hooks(f(g(h())))`.
func (c *CoachClient) Use(hooks ...Hook) {
	c.hooks.Coach = append(c.hooks.Coach, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `coach.Intercept(f(g(h())))`.
func (c *CoachClient) Intercept(interceptors ...Interceptor) {
	c.inters.Coach = append(c.inters.Coach, interceptors...)
}

// Create returns a builder for creating a Coach entity.
func (c *CoachClient) Create() *CoachCreate {
	mutation := newCoachMutation(c.config, OpCreate)
	return &CoachCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Coach entities.
func (c *CoachClient) CreateBulk(builders ...*CoachCreate) *CoachCreateBulk {
	return &CoachCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CoachClient) MapCreateBulk(slice any, setFunc func(*CoachCreate, int)) *CoachCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CoachCreateBulk{err: fmt.Errorf("calling to CoachClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CoachCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CoachCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Coach.
func (c *CoachClient) Update() *CoachUpdate {
	mutation := newCoachMutation(c.config, OpUpdate)
	return &CoachUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CoachClient) UpdateOne(co *Coach) *CoachUpdateOne {
	mutation := newCoachMutation(c.config, OpUpdateOne, withCoach(co))
	return &CoachUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CoachClient) UpdateOneID(id int) *CoachUpdateOne {
	mutation := newCoachMutation(c.config, OpUpdateOne, withCoachID(id))
	return &CoachUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Coach.
func (c *CoachClient) Delete() *CoachDelete {
	mutation := newCoachMutation(c.config, OpDelete)
	return &CoachDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CoachClient) DeleteOne(co *Coach) *CoachDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CoachClient) DeleteOneID(id int) *CoachDeleteOne {
	builder := c.Delete().Where(coach.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CoachDeleteOne{builder}
}

// Query returns a query builder for Coach.
func (c *CoachClient) Query() *CoachQuery {
	return &CoachQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCoach},
		inters: c.Interceptors(),
	}
}

// Get returns a Coach entity by its id.
func (c *CoachClient) Get(ctx context.Context, id int) (*Coach, error) {
	return c.Query().Where(coach.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CoachClient) GetX(ctx context.Context, id int) *Coach {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CoachClient) Hooks() []Hook {
	return c.hooks.Coach
}

// Interceptors returns the client interceptors.
func (c *CoachClient) Interceptors() []Interceptor {
	return c.inters.Coach
}

func (c *CoachClient) mutate(ctx context.Context, m *CoachMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CoachCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CoachUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CoachUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CoachDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Coach mutation op: %q", m.Op())
	}
}

// CountryClient is a client for the Country schema.
type CountryClient struct {
	config
}

// NewCountryClient returns a client for the Country from the given config.
func NewCountryClient(c config) *CountryClient {
	return &CountryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `country.Hooks(f(g(h())))`.
func (c *CountryClient) Use(hooks ...Hook) {
	c.hooks.Country = append(c.hooks.Country, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `country.Intercept(f(g(h())))`.
func (c *CountryClient) Intercept(interceptors ...Interceptor) {
	c.inters.Country = append(c.inters.Country, interceptors...)
}

// Create returns a builder for creating a Country entity.
func (c *CountryClient) Create() *CountryCreate {
	mutation := newCountryMutation(c.config, OpCreate)
	return &CountryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Country entities.
func (c *CountryClient) CreateBulk(builders ...*CountryCreate) *CountryCreateBulk {
	return &CountryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CountryClient) MapCreateBulk(slice any, setFunc func(*CountryCreate, int)) *CountryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CountryCreateBulk{err: fmt.Errorf("calling to CountryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CountryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CountryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Country.
func (c *CountryClient) Update() *CountryUpdate {
	mutation := newCountryMutation(c.config, OpUpdate)
	return &CountryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CountryClient) UpdateOne(co *Country) *CountryUpdateOne {
	mutation := newCountryMutation(c.config, OpUpdateOne, withCountry(co))
	return &CountryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CountryClient) UpdateOneID(id int) *CountryUpdateOne {
	mutation := newCountryMutation(c.config, OpUpdateOne, withCountryID(id))
	return &CountryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Country.
func (c *CountryClient) Delete() *CountryDelete {
	mutation := newCountryMutation(c.config, OpDelete)
	return &CountryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CountryClient) DeleteOne(co *Country) *CountryDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CountryClient) DeleteOneID(id int) *CountryDeleteOne {
	builder := c.Delete().Where(country.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CountryDeleteOne{builder}
}

// Query returns a query builder for Country.
func (c *CountryClient) Query() *CountryQuery {
	return &CountryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCountry},
		inters: c.Interceptors(),
	}
}

// Get returns a Country entity by its id.
func (c *CountryClient) Get(ctx context.Context, id int) (*Country, error) {
	return c.Query().Where(country.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CountryClient) GetX(ctx context.Context, id int) *Country {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlayers queries the players edge of a Country.
func (c *CountryClient) QueryPlayers(co *Country) *PlayerQuery {
	query := (&PlayerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(country.Table, country.FieldID, id),
			sqlgraph.To(player.Table, player.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, country.PlayersTable, country.PlayersColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLeagues queries the leagues edge of a Country.
func (c *CountryClient) QueryLeagues(co *Country) *LeagueQuery {
	query := (&LeagueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(country.Table, country.FieldID, id),
			sqlgraph.To(league.Table, league.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, country.LeaguesTable, country.LeaguesColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClubs queries the clubs edge of a Country.
func (c *CountryClient) QueryClubs(co *Country) *ClubQuery {
	query := (&ClubClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(country.Table, country.FieldID, id),
			sqlgraph.To(club.Table, club.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, country.ClubsTable, country.ClubsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CountryClient) Hooks() []Hook {
	return c.hooks.Country
}

// Interceptors returns the client interceptors.
func (c *CountryClient) Interceptors() []Interceptor {
	return c.inters.Country
}

func (c *CountryClient) mutate(ctx context.Context, m *CountryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CountryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CountryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CountryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CountryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Country mutation op: %q", m.Op())
	}
}

// FixtureClient is a client for the Fixture schema.
type FixtureClient struct {
	config
}

// NewFixtureClient returns a client for the Fixture from the given config.
func NewFixtureClient(c config) *FixtureClient {
	return &FixtureClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `fixture.Hooks(f(g(h())))`.
func (c *FixtureClient) Use(hooks ...Hook) {
	c.hooks.Fixture = append(c.hooks.Fixture, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `fixture.Intercept(f(g(h())))`.
func (c *FixtureClient) Intercept(interceptors ...Interceptor) {
	c.inters.Fixture = append(c.inters.Fixture, interceptors...)
}

// Create returns a builder for creating a Fixture entity.
func (c *FixtureClient) Create() *FixtureCreate {
	mutation := newFixtureMutation(c.config, OpCreate)
	return &FixtureCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Fixture entities.
func (c *FixtureClient) CreateBulk(builders ...*FixtureCreate) *FixtureCreateBulk {
	return &FixtureCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FixtureClient) MapCreateBulk(slice any, setFunc func(*FixtureCreate, int)) *FixtureCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FixtureCreateBulk{err: fmt.Errorf("calling to FixtureClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FixtureCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FixtureCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Fixture.
func (c *FixtureClient) Update() *FixtureUpdate {
	mutation := newFixtureMutation(c.config, OpUpdate)
	return &FixtureUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FixtureClient) UpdateOne(f *Fixture) *FixtureUpdateOne {
	mutation := newFixtureMutation(c.config, OpUpdateOne, withFixture(f))
	return &FixtureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FixtureClient) UpdateOneID(id int) *FixtureUpdateOne {
	mutation := newFixtureMutation(c.config, OpUpdateOne, withFixtureID(id))
	return &FixtureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Fixture.
func (c *FixtureClient) Delete() *FixtureDelete {
	mutation := newFixtureMutation(c.config, OpDelete)
	return &FixtureDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FixtureClient) DeleteOne(f *Fixture) *FixtureDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FixtureClient) DeleteOneID(id int) *FixtureDeleteOne {
	builder := c.Delete().Where(fixture.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FixtureDeleteOne{builder}
}

// Query returns a query builder for Fixture.
func (c *FixtureClient) Query() *FixtureQuery {
	return &FixtureQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFixture},
		inters: c.Interceptors(),
	}
}

// Get returns a Fixture entity by its id.
func (c *FixtureClient) Get(ctx context.Context, id int) (*Fixture, error) {
	return c.Query().Where(fixture.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FixtureClient) GetX(ctx context.Context, id int) *Fixture {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryHomeTeam queries the homeTeam edge of a Fixture.
func (c *FixtureClient) QueryHomeTeam(f *Fixture) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fixture.Table, fixture.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, fixture.HomeTeamTable, fixture.HomeTeamColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAwayTeam queries the awayTeam edge of a Fixture.
func (c *FixtureClient) QueryAwayTeam(f *Fixture) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fixture.Table, fixture.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, fixture.AwayTeamTable, fixture.AwayTeamColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySeason queries the season edge of a Fixture.
func (c *FixtureClient) QuerySeason(f *Fixture) *SeasonQuery {
	query := (&SeasonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fixture.Table, fixture.FieldID, id),
			sqlgraph.To(season.Table, season.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, fixture.SeasonTable, fixture.SeasonColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLineups queries the lineups edge of a Fixture.
func (c *FixtureClient) QueryLineups(f *Fixture) *FixtureLineupsQuery {
	query := (&FixtureLineupsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fixture.Table, fixture.FieldID, id),
			sqlgraph.To(fixturelineups.Table, fixturelineups.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, fixture.LineupsTable, fixture.LineupsColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFixtureEvents queries the fixtureEvents edge of a Fixture.
func (c *FixtureClient) QueryFixtureEvents(f *Fixture) *FixtureEventsQuery {
	query := (&FixtureEventsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fixture.Table, fixture.FieldID, id),
			sqlgraph.To(fixtureevents.Table, fixtureevents.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, fixture.FixtureEventsTable, fixture.FixtureEventsColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FixtureClient) Hooks() []Hook {
	return c.hooks.Fixture
}

// Interceptors returns the client interceptors.
func (c *FixtureClient) Interceptors() []Interceptor {
	return c.inters.Fixture
}

func (c *FixtureClient) mutate(ctx context.Context, m *FixtureMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FixtureCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FixtureUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FixtureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FixtureDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Fixture mutation op: %q", m.Op())
	}
}

// FixtureEventsClient is a client for the FixtureEvents schema.
type FixtureEventsClient struct {
	config
}

// NewFixtureEventsClient returns a client for the FixtureEvents from the given config.
func NewFixtureEventsClient(c config) *FixtureEventsClient {
	return &FixtureEventsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `fixtureevents.Hooks(f(g(h())))`.
func (c *FixtureEventsClient) Use(hooks ...Hook) {
	c.hooks.FixtureEvents = append(c.hooks.FixtureEvents, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `fixtureevents.Intercept(f(g(h())))`.
func (c *FixtureEventsClient) Intercept(interceptors ...Interceptor) {
	c.inters.FixtureEvents = append(c.inters.FixtureEvents, interceptors...)
}

// Create returns a builder for creating a FixtureEvents entity.
func (c *FixtureEventsClient) Create() *FixtureEventsCreate {
	mutation := newFixtureEventsMutation(c.config, OpCreate)
	return &FixtureEventsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FixtureEvents entities.
func (c *FixtureEventsClient) CreateBulk(builders ...*FixtureEventsCreate) *FixtureEventsCreateBulk {
	return &FixtureEventsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FixtureEventsClient) MapCreateBulk(slice any, setFunc func(*FixtureEventsCreate, int)) *FixtureEventsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FixtureEventsCreateBulk{err: fmt.Errorf("calling to FixtureEventsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FixtureEventsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FixtureEventsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FixtureEvents.
func (c *FixtureEventsClient) Update() *FixtureEventsUpdate {
	mutation := newFixtureEventsMutation(c.config, OpUpdate)
	return &FixtureEventsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FixtureEventsClient) UpdateOne(fe *FixtureEvents) *FixtureEventsUpdateOne {
	mutation := newFixtureEventsMutation(c.config, OpUpdateOne, withFixtureEvents(fe))
	return &FixtureEventsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FixtureEventsClient) UpdateOneID(id int) *FixtureEventsUpdateOne {
	mutation := newFixtureEventsMutation(c.config, OpUpdateOne, withFixtureEventsID(id))
	return &FixtureEventsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FixtureEvents.
func (c *FixtureEventsClient) Delete() *FixtureEventsDelete {
	mutation := newFixtureEventsMutation(c.config, OpDelete)
	return &FixtureEventsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FixtureEventsClient) DeleteOne(fe *FixtureEvents) *FixtureEventsDeleteOne {
	return c.DeleteOneID(fe.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FixtureEventsClient) DeleteOneID(id int) *FixtureEventsDeleteOne {
	builder := c.Delete().Where(fixtureevents.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FixtureEventsDeleteOne{builder}
}

// Query returns a query builder for FixtureEvents.
func (c *FixtureEventsClient) Query() *FixtureEventsQuery {
	return &FixtureEventsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFixtureEvents},
		inters: c.Interceptors(),
	}
}

// Get returns a FixtureEvents entity by its id.
func (c *FixtureEventsClient) Get(ctx context.Context, id int) (*FixtureEvents, error) {
	return c.Query().Where(fixtureevents.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FixtureEventsClient) GetX(ctx context.Context, id int) *FixtureEvents {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlayer queries the player edge of a FixtureEvents.
func (c *FixtureEventsClient) QueryPlayer(fe *FixtureEvents) *PlayerQuery {
	query := (&PlayerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fixtureevents.Table, fixtureevents.FieldID, id),
			sqlgraph.To(player.Table, player.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, fixtureevents.PlayerTable, fixtureevents.PlayerColumn),
		)
		fromV = sqlgraph.Neighbors(fe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssist queries the assist edge of a FixtureEvents.
func (c *FixtureEventsClient) QueryAssist(fe *FixtureEvents) *PlayerQuery {
	query := (&PlayerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fixtureevents.Table, fixtureevents.FieldID, id),
			sqlgraph.To(player.Table, player.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, fixtureevents.AssistTable, fixtureevents.AssistColumn),
		)
		fromV = sqlgraph.Neighbors(fe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeam queries the team edge of a FixtureEvents.
func (c *FixtureEventsClient) QueryTeam(fe *FixtureEvents) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fixtureevents.Table, fixtureevents.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, fixtureevents.TeamTable, fixtureevents.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(fe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFixture queries the fixture edge of a FixtureEvents.
func (c *FixtureEventsClient) QueryFixture(fe *FixtureEvents) *FixtureQuery {
	query := (&FixtureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fixtureevents.Table, fixtureevents.FieldID, id),
			sqlgraph.To(fixture.Table, fixture.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, fixtureevents.FixtureTable, fixtureevents.FixtureColumn),
		)
		fromV = sqlgraph.Neighbors(fe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlayerStats queries the playerStats edge of a FixtureEvents.
func (c *FixtureEventsClient) QueryPlayerStats(fe *FixtureEvents) *PlayerStatsQuery {
	query := (&PlayerStatsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fe.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fixtureevents.Table, fixtureevents.FieldID, id),
			sqlgraph.To(playerstats.Table, playerstats.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, fixtureevents.PlayerStatsTable, fixtureevents.PlayerStatsColumn),
		)
		fromV = sqlgraph.Neighbors(fe.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FixtureEventsClient) Hooks() []Hook {
	return c.hooks.FixtureEvents
}

// Interceptors returns the client interceptors.
func (c *FixtureEventsClient) Interceptors() []Interceptor {
	return c.inters.FixtureEvents
}

func (c *FixtureEventsClient) mutate(ctx context.Context, m *FixtureEventsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FixtureEventsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FixtureEventsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FixtureEventsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FixtureEventsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FixtureEvents mutation op: %q", m.Op())
	}
}

// FixtureLineupsClient is a client for the FixtureLineups schema.
type FixtureLineupsClient struct {
	config
}

// NewFixtureLineupsClient returns a client for the FixtureLineups from the given config.
func NewFixtureLineupsClient(c config) *FixtureLineupsClient {
	return &FixtureLineupsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `fixturelineups.Hooks(f(g(h())))`.
func (c *FixtureLineupsClient) Use(hooks ...Hook) {
	c.hooks.FixtureLineups = append(c.hooks.FixtureLineups, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `fixturelineups.Intercept(f(g(h())))`.
func (c *FixtureLineupsClient) Intercept(interceptors ...Interceptor) {
	c.inters.FixtureLineups = append(c.inters.FixtureLineups, interceptors...)
}

// Create returns a builder for creating a FixtureLineups entity.
func (c *FixtureLineupsClient) Create() *FixtureLineupsCreate {
	mutation := newFixtureLineupsMutation(c.config, OpCreate)
	return &FixtureLineupsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FixtureLineups entities.
func (c *FixtureLineupsClient) CreateBulk(builders ...*FixtureLineupsCreate) *FixtureLineupsCreateBulk {
	return &FixtureLineupsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *FixtureLineupsClient) MapCreateBulk(slice any, setFunc func(*FixtureLineupsCreate, int)) *FixtureLineupsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &FixtureLineupsCreateBulk{err: fmt.Errorf("calling to FixtureLineupsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*FixtureLineupsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &FixtureLineupsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FixtureLineups.
func (c *FixtureLineupsClient) Update() *FixtureLineupsUpdate {
	mutation := newFixtureLineupsMutation(c.config, OpUpdate)
	return &FixtureLineupsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FixtureLineupsClient) UpdateOne(fl *FixtureLineups) *FixtureLineupsUpdateOne {
	mutation := newFixtureLineupsMutation(c.config, OpUpdateOne, withFixtureLineups(fl))
	return &FixtureLineupsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FixtureLineupsClient) UpdateOneID(id int) *FixtureLineupsUpdateOne {
	mutation := newFixtureLineupsMutation(c.config, OpUpdateOne, withFixtureLineupsID(id))
	return &FixtureLineupsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FixtureLineups.
func (c *FixtureLineupsClient) Delete() *FixtureLineupsDelete {
	mutation := newFixtureLineupsMutation(c.config, OpDelete)
	return &FixtureLineupsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FixtureLineupsClient) DeleteOne(fl *FixtureLineups) *FixtureLineupsDeleteOne {
	return c.DeleteOneID(fl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FixtureLineupsClient) DeleteOneID(id int) *FixtureLineupsDeleteOne {
	builder := c.Delete().Where(fixturelineups.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FixtureLineupsDeleteOne{builder}
}

// Query returns a query builder for FixtureLineups.
func (c *FixtureLineupsClient) Query() *FixtureLineupsQuery {
	return &FixtureLineupsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFixtureLineups},
		inters: c.Interceptors(),
	}
}

// Get returns a FixtureLineups entity by its id.
func (c *FixtureLineupsClient) Get(ctx context.Context, id int) (*FixtureLineups, error) {
	return c.Query().Where(fixturelineups.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FixtureLineupsClient) GetX(ctx context.Context, id int) *FixtureLineups {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTeam queries the team edge of a FixtureLineups.
func (c *FixtureLineupsClient) QueryTeam(fl *FixtureLineups) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fixturelineups.Table, fixturelineups.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, fixturelineups.TeamTable, fixturelineups.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(fl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFixture queries the fixture edge of a FixtureLineups.
func (c *FixtureLineupsClient) QueryFixture(fl *FixtureLineups) *FixtureQuery {
	query := (&FixtureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fixturelineups.Table, fixturelineups.FieldID, id),
			sqlgraph.To(fixture.Table, fixture.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, fixturelineups.FixtureTable, fixturelineups.FixtureColumn),
		)
		fromV = sqlgraph.Neighbors(fl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLineupPlayer queries the lineupPlayer edge of a FixtureLineups.
func (c *FixtureLineupsClient) QueryLineupPlayer(fl *FixtureLineups) *MatchPlayerQuery {
	query := (&MatchPlayerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := fl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fixturelineups.Table, fixturelineups.FieldID, id),
			sqlgraph.To(matchplayer.Table, matchplayer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, fixturelineups.LineupPlayerTable, fixturelineups.LineupPlayerColumn),
		)
		fromV = sqlgraph.Neighbors(fl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FixtureLineupsClient) Hooks() []Hook {
	return c.hooks.FixtureLineups
}

// Interceptors returns the client interceptors.
func (c *FixtureLineupsClient) Interceptors() []Interceptor {
	return c.inters.FixtureLineups
}

func (c *FixtureLineupsClient) mutate(ctx context.Context, m *FixtureLineupsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FixtureLineupsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FixtureLineupsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FixtureLineupsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FixtureLineupsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown FixtureLineups mutation op: %q", m.Op())
	}
}

// LeagueClient is a client for the League schema.
type LeagueClient struct {
	config
}

// NewLeagueClient returns a client for the League from the given config.
func NewLeagueClient(c config) *LeagueClient {
	return &LeagueClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `league.Hooks(f(g(h())))`.
func (c *LeagueClient) Use(hooks ...Hook) {
	c.hooks.League = append(c.hooks.League, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `league.Intercept(f(g(h())))`.
func (c *LeagueClient) Intercept(interceptors ...Interceptor) {
	c.inters.League = append(c.inters.League, interceptors...)
}

// Create returns a builder for creating a League entity.
func (c *LeagueClient) Create() *LeagueCreate {
	mutation := newLeagueMutation(c.config, OpCreate)
	return &LeagueCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of League entities.
func (c *LeagueClient) CreateBulk(builders ...*LeagueCreate) *LeagueCreateBulk {
	return &LeagueCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LeagueClient) MapCreateBulk(slice any, setFunc func(*LeagueCreate, int)) *LeagueCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LeagueCreateBulk{err: fmt.Errorf("calling to LeagueClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LeagueCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LeagueCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for League.
func (c *LeagueClient) Update() *LeagueUpdate {
	mutation := newLeagueMutation(c.config, OpUpdate)
	return &LeagueUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LeagueClient) UpdateOne(l *League) *LeagueUpdateOne {
	mutation := newLeagueMutation(c.config, OpUpdateOne, withLeague(l))
	return &LeagueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LeagueClient) UpdateOneID(id int) *LeagueUpdateOne {
	mutation := newLeagueMutation(c.config, OpUpdateOne, withLeagueID(id))
	return &LeagueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for League.
func (c *LeagueClient) Delete() *LeagueDelete {
	mutation := newLeagueMutation(c.config, OpDelete)
	return &LeagueDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LeagueClient) DeleteOne(l *League) *LeagueDeleteOne {
	return c.DeleteOneID(l.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LeagueClient) DeleteOneID(id int) *LeagueDeleteOne {
	builder := c.Delete().Where(league.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LeagueDeleteOne{builder}
}

// Query returns a query builder for League.
func (c *LeagueClient) Query() *LeagueQuery {
	return &LeagueQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLeague},
		inters: c.Interceptors(),
	}
}

// Get returns a League entity by its id.
func (c *LeagueClient) Get(ctx context.Context, id int) (*League, error) {
	return c.Query().Where(league.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LeagueClient) GetX(ctx context.Context, id int) *League {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCountry queries the country edge of a League.
func (c *LeagueClient) QueryCountry(l *League) *CountryQuery {
	query := (&CountryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(league.Table, league.FieldID, id),
			sqlgraph.To(country.Table, country.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, league.CountryTable, league.CountryColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySeason queries the season edge of a League.
func (c *LeagueClient) QuerySeason(l *League) *SeasonQuery {
	query := (&SeasonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(league.Table, league.FieldID, id),
			sqlgraph.To(season.Table, season.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, league.SeasonTable, league.SeasonColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LeagueClient) Hooks() []Hook {
	return c.hooks.League
}

// Interceptors returns the client interceptors.
func (c *LeagueClient) Interceptors() []Interceptor {
	return c.inters.League
}

func (c *LeagueClient) mutate(ctx context.Context, m *LeagueMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LeagueCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LeagueUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LeagueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LeagueDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown League mutation op: %q", m.Op())
	}
}

// MatchPlayerClient is a client for the MatchPlayer schema.
type MatchPlayerClient struct {
	config
}

// NewMatchPlayerClient returns a client for the MatchPlayer from the given config.
func NewMatchPlayerClient(c config) *MatchPlayerClient {
	return &MatchPlayerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `matchplayer.Hooks(f(g(h())))`.
func (c *MatchPlayerClient) Use(hooks ...Hook) {
	c.hooks.MatchPlayer = append(c.hooks.MatchPlayer, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `matchplayer.Intercept(f(g(h())))`.
func (c *MatchPlayerClient) Intercept(interceptors ...Interceptor) {
	c.inters.MatchPlayer = append(c.inters.MatchPlayer, interceptors...)
}

// Create returns a builder for creating a MatchPlayer entity.
func (c *MatchPlayerClient) Create() *MatchPlayerCreate {
	mutation := newMatchPlayerMutation(c.config, OpCreate)
	return &MatchPlayerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MatchPlayer entities.
func (c *MatchPlayerClient) CreateBulk(builders ...*MatchPlayerCreate) *MatchPlayerCreateBulk {
	return &MatchPlayerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MatchPlayerClient) MapCreateBulk(slice any, setFunc func(*MatchPlayerCreate, int)) *MatchPlayerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MatchPlayerCreateBulk{err: fmt.Errorf("calling to MatchPlayerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MatchPlayerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MatchPlayerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MatchPlayer.
func (c *MatchPlayerClient) Update() *MatchPlayerUpdate {
	mutation := newMatchPlayerMutation(c.config, OpUpdate)
	return &MatchPlayerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MatchPlayerClient) UpdateOne(mp *MatchPlayer) *MatchPlayerUpdateOne {
	mutation := newMatchPlayerMutation(c.config, OpUpdateOne, withMatchPlayer(mp))
	return &MatchPlayerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MatchPlayerClient) UpdateOneID(id int) *MatchPlayerUpdateOne {
	mutation := newMatchPlayerMutation(c.config, OpUpdateOne, withMatchPlayerID(id))
	return &MatchPlayerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MatchPlayer.
func (c *MatchPlayerClient) Delete() *MatchPlayerDelete {
	mutation := newMatchPlayerMutation(c.config, OpDelete)
	return &MatchPlayerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MatchPlayerClient) DeleteOne(mp *MatchPlayer) *MatchPlayerDeleteOne {
	return c.DeleteOneID(mp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MatchPlayerClient) DeleteOneID(id int) *MatchPlayerDeleteOne {
	builder := c.Delete().Where(matchplayer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MatchPlayerDeleteOne{builder}
}

// Query returns a query builder for MatchPlayer.
func (c *MatchPlayerClient) Query() *MatchPlayerQuery {
	return &MatchPlayerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMatchPlayer},
		inters: c.Interceptors(),
	}
}

// Get returns a MatchPlayer entity by its id.
func (c *MatchPlayerClient) Get(ctx context.Context, id int) (*MatchPlayer, error) {
	return c.Query().Where(matchplayer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MatchPlayerClient) GetX(ctx context.Context, id int) *MatchPlayer {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlayer queries the player edge of a MatchPlayer.
func (c *MatchPlayerClient) QueryPlayer(mp *MatchPlayer) *PlayerQuery {
	query := (&PlayerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(matchplayer.Table, matchplayer.FieldID, id),
			sqlgraph.To(player.Table, player.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, matchplayer.PlayerTable, matchplayer.PlayerColumn),
		)
		fromV = sqlgraph.Neighbors(mp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLineup queries the lineup edge of a MatchPlayer.
func (c *MatchPlayerClient) QueryLineup(mp *MatchPlayer) *FixtureLineupsQuery {
	query := (&FixtureLineupsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(matchplayer.Table, matchplayer.FieldID, id),
			sqlgraph.To(fixturelineups.Table, fixturelineups.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, matchplayer.LineupTable, matchplayer.LineupColumn),
		)
		fromV = sqlgraph.Neighbors(mp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlayerStats queries the playerStats edge of a MatchPlayer.
func (c *MatchPlayerClient) QueryPlayerStats(mp *MatchPlayer) *PlayerStatsQuery {
	query := (&PlayerStatsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(matchplayer.Table, matchplayer.FieldID, id),
			sqlgraph.To(playerstats.Table, playerstats.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, matchplayer.PlayerStatsTable, matchplayer.PlayerStatsColumn),
		)
		fromV = sqlgraph.Neighbors(mp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MatchPlayerClient) Hooks() []Hook {
	return c.hooks.MatchPlayer
}

// Interceptors returns the client interceptors.
func (c *MatchPlayerClient) Interceptors() []Interceptor {
	return c.inters.MatchPlayer
}

func (c *MatchPlayerClient) mutate(ctx context.Context, m *MatchPlayerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MatchPlayerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MatchPlayerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MatchPlayerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MatchPlayerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MatchPlayer mutation op: %q", m.Op())
	}
}

// PSDefenseClient is a client for the PSDefense schema.
type PSDefenseClient struct {
	config
}

// NewPSDefenseClient returns a client for the PSDefense from the given config.
func NewPSDefenseClient(c config) *PSDefenseClient {
	return &PSDefenseClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `psdefense.Hooks(f(g(h())))`.
func (c *PSDefenseClient) Use(hooks ...Hook) {
	c.hooks.PSDefense = append(c.hooks.PSDefense, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `psdefense.Intercept(f(g(h())))`.
func (c *PSDefenseClient) Intercept(interceptors ...Interceptor) {
	c.inters.PSDefense = append(c.inters.PSDefense, interceptors...)
}

// Create returns a builder for creating a PSDefense entity.
func (c *PSDefenseClient) Create() *PSDefenseCreate {
	mutation := newPSDefenseMutation(c.config, OpCreate)
	return &PSDefenseCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PSDefense entities.
func (c *PSDefenseClient) CreateBulk(builders ...*PSDefenseCreate) *PSDefenseCreateBulk {
	return &PSDefenseCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PSDefenseClient) MapCreateBulk(slice any, setFunc func(*PSDefenseCreate, int)) *PSDefenseCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PSDefenseCreateBulk{err: fmt.Errorf("calling to PSDefenseClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PSDefenseCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PSDefenseCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PSDefense.
func (c *PSDefenseClient) Update() *PSDefenseUpdate {
	mutation := newPSDefenseMutation(c.config, OpUpdate)
	return &PSDefenseUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PSDefenseClient) UpdateOne(pd *PSDefense) *PSDefenseUpdateOne {
	mutation := newPSDefenseMutation(c.config, OpUpdateOne, withPSDefense(pd))
	return &PSDefenseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PSDefenseClient) UpdateOneID(id int) *PSDefenseUpdateOne {
	mutation := newPSDefenseMutation(c.config, OpUpdateOne, withPSDefenseID(id))
	return &PSDefenseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PSDefense.
func (c *PSDefenseClient) Delete() *PSDefenseDelete {
	mutation := newPSDefenseMutation(c.config, OpDelete)
	return &PSDefenseDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PSDefenseClient) DeleteOne(pd *PSDefense) *PSDefenseDeleteOne {
	return c.DeleteOneID(pd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PSDefenseClient) DeleteOneID(id int) *PSDefenseDeleteOne {
	builder := c.Delete().Where(psdefense.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PSDefenseDeleteOne{builder}
}

// Query returns a query builder for PSDefense.
func (c *PSDefenseClient) Query() *PSDefenseQuery {
	return &PSDefenseQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePSDefense},
		inters: c.Interceptors(),
	}
}

// Get returns a PSDefense entity by its id.
func (c *PSDefenseClient) Get(ctx context.Context, id int) (*PSDefense, error) {
	return c.Query().Where(psdefense.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PSDefenseClient) GetX(ctx context.Context, id int) *PSDefense {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlayerStats queries the playerStats edge of a PSDefense.
func (c *PSDefenseClient) QueryPlayerStats(pd *PSDefense) *PlayerStatsQuery {
	query := (&PlayerStatsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(psdefense.Table, psdefense.FieldID, id),
			sqlgraph.To(playerstats.Table, playerstats.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, psdefense.PlayerStatsTable, psdefense.PlayerStatsColumn),
		)
		fromV = sqlgraph.Neighbors(pd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PSDefenseClient) Hooks() []Hook {
	return c.hooks.PSDefense
}

// Interceptors returns the client interceptors.
func (c *PSDefenseClient) Interceptors() []Interceptor {
	return c.inters.PSDefense
}

func (c *PSDefenseClient) mutate(ctx context.Context, m *PSDefenseMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PSDefenseCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PSDefenseUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PSDefenseUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PSDefenseDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PSDefense mutation op: %q", m.Op())
	}
}

// PSFairplayClient is a client for the PSFairplay schema.
type PSFairplayClient struct {
	config
}

// NewPSFairplayClient returns a client for the PSFairplay from the given config.
func NewPSFairplayClient(c config) *PSFairplayClient {
	return &PSFairplayClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `psfairplay.Hooks(f(g(h())))`.
func (c *PSFairplayClient) Use(hooks ...Hook) {
	c.hooks.PSFairplay = append(c.hooks.PSFairplay, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `psfairplay.Intercept(f(g(h())))`.
func (c *PSFairplayClient) Intercept(interceptors ...Interceptor) {
	c.inters.PSFairplay = append(c.inters.PSFairplay, interceptors...)
}

// Create returns a builder for creating a PSFairplay entity.
func (c *PSFairplayClient) Create() *PSFairplayCreate {
	mutation := newPSFairplayMutation(c.config, OpCreate)
	return &PSFairplayCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PSFairplay entities.
func (c *PSFairplayClient) CreateBulk(builders ...*PSFairplayCreate) *PSFairplayCreateBulk {
	return &PSFairplayCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PSFairplayClient) MapCreateBulk(slice any, setFunc func(*PSFairplayCreate, int)) *PSFairplayCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PSFairplayCreateBulk{err: fmt.Errorf("calling to PSFairplayClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PSFairplayCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PSFairplayCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PSFairplay.
func (c *PSFairplayClient) Update() *PSFairplayUpdate {
	mutation := newPSFairplayMutation(c.config, OpUpdate)
	return &PSFairplayUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PSFairplayClient) UpdateOne(pf *PSFairplay) *PSFairplayUpdateOne {
	mutation := newPSFairplayMutation(c.config, OpUpdateOne, withPSFairplay(pf))
	return &PSFairplayUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PSFairplayClient) UpdateOneID(id int) *PSFairplayUpdateOne {
	mutation := newPSFairplayMutation(c.config, OpUpdateOne, withPSFairplayID(id))
	return &PSFairplayUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PSFairplay.
func (c *PSFairplayClient) Delete() *PSFairplayDelete {
	mutation := newPSFairplayMutation(c.config, OpDelete)
	return &PSFairplayDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PSFairplayClient) DeleteOne(pf *PSFairplay) *PSFairplayDeleteOne {
	return c.DeleteOneID(pf.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PSFairplayClient) DeleteOneID(id int) *PSFairplayDeleteOne {
	builder := c.Delete().Where(psfairplay.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PSFairplayDeleteOne{builder}
}

// Query returns a query builder for PSFairplay.
func (c *PSFairplayClient) Query() *PSFairplayQuery {
	return &PSFairplayQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePSFairplay},
		inters: c.Interceptors(),
	}
}

// Get returns a PSFairplay entity by its id.
func (c *PSFairplayClient) Get(ctx context.Context, id int) (*PSFairplay, error) {
	return c.Query().Where(psfairplay.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PSFairplayClient) GetX(ctx context.Context, id int) *PSFairplay {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlayerStats queries the playerStats edge of a PSFairplay.
func (c *PSFairplayClient) QueryPlayerStats(pf *PSFairplay) *PlayerStatsQuery {
	query := (&PlayerStatsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pf.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(psfairplay.Table, psfairplay.FieldID, id),
			sqlgraph.To(playerstats.Table, playerstats.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, psfairplay.PlayerStatsTable, psfairplay.PlayerStatsColumn),
		)
		fromV = sqlgraph.Neighbors(pf.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PSFairplayClient) Hooks() []Hook {
	return c.hooks.PSFairplay
}

// Interceptors returns the client interceptors.
func (c *PSFairplayClient) Interceptors() []Interceptor {
	return c.inters.PSFairplay
}

func (c *PSFairplayClient) mutate(ctx context.Context, m *PSFairplayMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PSFairplayCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PSFairplayUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PSFairplayUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PSFairplayDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PSFairplay mutation op: %q", m.Op())
	}
}

// PSGamesClient is a client for the PSGames schema.
type PSGamesClient struct {
	config
}

// NewPSGamesClient returns a client for the PSGames from the given config.
func NewPSGamesClient(c config) *PSGamesClient {
	return &PSGamesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `psgames.Hooks(f(g(h())))`.
func (c *PSGamesClient) Use(hooks ...Hook) {
	c.hooks.PSGames = append(c.hooks.PSGames, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `psgames.Intercept(f(g(h())))`.
func (c *PSGamesClient) Intercept(interceptors ...Interceptor) {
	c.inters.PSGames = append(c.inters.PSGames, interceptors...)
}

// Create returns a builder for creating a PSGames entity.
func (c *PSGamesClient) Create() *PSGamesCreate {
	mutation := newPSGamesMutation(c.config, OpCreate)
	return &PSGamesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PSGames entities.
func (c *PSGamesClient) CreateBulk(builders ...*PSGamesCreate) *PSGamesCreateBulk {
	return &PSGamesCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PSGamesClient) MapCreateBulk(slice any, setFunc func(*PSGamesCreate, int)) *PSGamesCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PSGamesCreateBulk{err: fmt.Errorf("calling to PSGamesClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PSGamesCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PSGamesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PSGames.
func (c *PSGamesClient) Update() *PSGamesUpdate {
	mutation := newPSGamesMutation(c.config, OpUpdate)
	return &PSGamesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PSGamesClient) UpdateOne(pg *PSGames) *PSGamesUpdateOne {
	mutation := newPSGamesMutation(c.config, OpUpdateOne, withPSGames(pg))
	return &PSGamesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PSGamesClient) UpdateOneID(id int) *PSGamesUpdateOne {
	mutation := newPSGamesMutation(c.config, OpUpdateOne, withPSGamesID(id))
	return &PSGamesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PSGames.
func (c *PSGamesClient) Delete() *PSGamesDelete {
	mutation := newPSGamesMutation(c.config, OpDelete)
	return &PSGamesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PSGamesClient) DeleteOne(pg *PSGames) *PSGamesDeleteOne {
	return c.DeleteOneID(pg.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PSGamesClient) DeleteOneID(id int) *PSGamesDeleteOne {
	builder := c.Delete().Where(psgames.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PSGamesDeleteOne{builder}
}

// Query returns a query builder for PSGames.
func (c *PSGamesClient) Query() *PSGamesQuery {
	return &PSGamesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePSGames},
		inters: c.Interceptors(),
	}
}

// Get returns a PSGames entity by its id.
func (c *PSGamesClient) Get(ctx context.Context, id int) (*PSGames, error) {
	return c.Query().Where(psgames.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PSGamesClient) GetX(ctx context.Context, id int) *PSGames {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlayerStats queries the playerStats edge of a PSGames.
func (c *PSGamesClient) QueryPlayerStats(pg *PSGames) *PlayerStatsQuery {
	query := (&PlayerStatsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pg.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(psgames.Table, psgames.FieldID, id),
			sqlgraph.To(playerstats.Table, playerstats.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, psgames.PlayerStatsTable, psgames.PlayerStatsColumn),
		)
		fromV = sqlgraph.Neighbors(pg.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PSGamesClient) Hooks() []Hook {
	return c.hooks.PSGames
}

// Interceptors returns the client interceptors.
func (c *PSGamesClient) Interceptors() []Interceptor {
	return c.inters.PSGames
}

func (c *PSGamesClient) mutate(ctx context.Context, m *PSGamesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PSGamesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PSGamesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PSGamesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PSGamesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PSGames mutation op: %q", m.Op())
	}
}

// PSPenaltyClient is a client for the PSPenalty schema.
type PSPenaltyClient struct {
	config
}

// NewPSPenaltyClient returns a client for the PSPenalty from the given config.
func NewPSPenaltyClient(c config) *PSPenaltyClient {
	return &PSPenaltyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `pspenalty.Hooks(f(g(h())))`.
func (c *PSPenaltyClient) Use(hooks ...Hook) {
	c.hooks.PSPenalty = append(c.hooks.PSPenalty, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `pspenalty.Intercept(f(g(h())))`.
func (c *PSPenaltyClient) Intercept(interceptors ...Interceptor) {
	c.inters.PSPenalty = append(c.inters.PSPenalty, interceptors...)
}

// Create returns a builder for creating a PSPenalty entity.
func (c *PSPenaltyClient) Create() *PSPenaltyCreate {
	mutation := newPSPenaltyMutation(c.config, OpCreate)
	return &PSPenaltyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PSPenalty entities.
func (c *PSPenaltyClient) CreateBulk(builders ...*PSPenaltyCreate) *PSPenaltyCreateBulk {
	return &PSPenaltyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PSPenaltyClient) MapCreateBulk(slice any, setFunc func(*PSPenaltyCreate, int)) *PSPenaltyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PSPenaltyCreateBulk{err: fmt.Errorf("calling to PSPenaltyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PSPenaltyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PSPenaltyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PSPenalty.
func (c *PSPenaltyClient) Update() *PSPenaltyUpdate {
	mutation := newPSPenaltyMutation(c.config, OpUpdate)
	return &PSPenaltyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PSPenaltyClient) UpdateOne(pp *PSPenalty) *PSPenaltyUpdateOne {
	mutation := newPSPenaltyMutation(c.config, OpUpdateOne, withPSPenalty(pp))
	return &PSPenaltyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PSPenaltyClient) UpdateOneID(id int) *PSPenaltyUpdateOne {
	mutation := newPSPenaltyMutation(c.config, OpUpdateOne, withPSPenaltyID(id))
	return &PSPenaltyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PSPenalty.
func (c *PSPenaltyClient) Delete() *PSPenaltyDelete {
	mutation := newPSPenaltyMutation(c.config, OpDelete)
	return &PSPenaltyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PSPenaltyClient) DeleteOne(pp *PSPenalty) *PSPenaltyDeleteOne {
	return c.DeleteOneID(pp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PSPenaltyClient) DeleteOneID(id int) *PSPenaltyDeleteOne {
	builder := c.Delete().Where(pspenalty.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PSPenaltyDeleteOne{builder}
}

// Query returns a query builder for PSPenalty.
func (c *PSPenaltyClient) Query() *PSPenaltyQuery {
	return &PSPenaltyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePSPenalty},
		inters: c.Interceptors(),
	}
}

// Get returns a PSPenalty entity by its id.
func (c *PSPenaltyClient) Get(ctx context.Context, id int) (*PSPenalty, error) {
	return c.Query().Where(pspenalty.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PSPenaltyClient) GetX(ctx context.Context, id int) *PSPenalty {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlayerStats queries the playerStats edge of a PSPenalty.
func (c *PSPenaltyClient) QueryPlayerStats(pp *PSPenalty) *PlayerStatsQuery {
	query := (&PlayerStatsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(pspenalty.Table, pspenalty.FieldID, id),
			sqlgraph.To(playerstats.Table, playerstats.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, pspenalty.PlayerStatsTable, pspenalty.PlayerStatsColumn),
		)
		fromV = sqlgraph.Neighbors(pp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PSPenaltyClient) Hooks() []Hook {
	return c.hooks.PSPenalty
}

// Interceptors returns the client interceptors.
func (c *PSPenaltyClient) Interceptors() []Interceptor {
	return c.inters.PSPenalty
}

func (c *PSPenaltyClient) mutate(ctx context.Context, m *PSPenaltyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PSPenaltyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PSPenaltyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PSPenaltyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PSPenaltyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PSPenalty mutation op: %q", m.Op())
	}
}

// PSShootingClient is a client for the PSShooting schema.
type PSShootingClient struct {
	config
}

// NewPSShootingClient returns a client for the PSShooting from the given config.
func NewPSShootingClient(c config) *PSShootingClient {
	return &PSShootingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `psshooting.Hooks(f(g(h())))`.
func (c *PSShootingClient) Use(hooks ...Hook) {
	c.hooks.PSShooting = append(c.hooks.PSShooting, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `psshooting.Intercept(f(g(h())))`.
func (c *PSShootingClient) Intercept(interceptors ...Interceptor) {
	c.inters.PSShooting = append(c.inters.PSShooting, interceptors...)
}

// Create returns a builder for creating a PSShooting entity.
func (c *PSShootingClient) Create() *PSShootingCreate {
	mutation := newPSShootingMutation(c.config, OpCreate)
	return &PSShootingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PSShooting entities.
func (c *PSShootingClient) CreateBulk(builders ...*PSShootingCreate) *PSShootingCreateBulk {
	return &PSShootingCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PSShootingClient) MapCreateBulk(slice any, setFunc func(*PSShootingCreate, int)) *PSShootingCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PSShootingCreateBulk{err: fmt.Errorf("calling to PSShootingClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PSShootingCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PSShootingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PSShooting.
func (c *PSShootingClient) Update() *PSShootingUpdate {
	mutation := newPSShootingMutation(c.config, OpUpdate)
	return &PSShootingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PSShootingClient) UpdateOne(ps *PSShooting) *PSShootingUpdateOne {
	mutation := newPSShootingMutation(c.config, OpUpdateOne, withPSShooting(ps))
	return &PSShootingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PSShootingClient) UpdateOneID(id int) *PSShootingUpdateOne {
	mutation := newPSShootingMutation(c.config, OpUpdateOne, withPSShootingID(id))
	return &PSShootingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PSShooting.
func (c *PSShootingClient) Delete() *PSShootingDelete {
	mutation := newPSShootingMutation(c.config, OpDelete)
	return &PSShootingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PSShootingClient) DeleteOne(ps *PSShooting) *PSShootingDeleteOne {
	return c.DeleteOneID(ps.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PSShootingClient) DeleteOneID(id int) *PSShootingDeleteOne {
	builder := c.Delete().Where(psshooting.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PSShootingDeleteOne{builder}
}

// Query returns a query builder for PSShooting.
func (c *PSShootingClient) Query() *PSShootingQuery {
	return &PSShootingQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePSShooting},
		inters: c.Interceptors(),
	}
}

// Get returns a PSShooting entity by its id.
func (c *PSShootingClient) Get(ctx context.Context, id int) (*PSShooting, error) {
	return c.Query().Where(psshooting.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PSShootingClient) GetX(ctx context.Context, id int) *PSShooting {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlayerStats queries the playerStats edge of a PSShooting.
func (c *PSShootingClient) QueryPlayerStats(ps *PSShooting) *PlayerStatsQuery {
	query := (&PlayerStatsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(psshooting.Table, psshooting.FieldID, id),
			sqlgraph.To(playerstats.Table, playerstats.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, psshooting.PlayerStatsTable, psshooting.PlayerStatsColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PSShootingClient) Hooks() []Hook {
	return c.hooks.PSShooting
}

// Interceptors returns the client interceptors.
func (c *PSShootingClient) Interceptors() []Interceptor {
	return c.inters.PSShooting
}

func (c *PSShootingClient) mutate(ctx context.Context, m *PSShootingMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PSShootingCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PSShootingUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PSShootingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PSShootingDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PSShooting mutation op: %q", m.Op())
	}
}

// PSSubstitutesClient is a client for the PSSubstitutes schema.
type PSSubstitutesClient struct {
	config
}

// NewPSSubstitutesClient returns a client for the PSSubstitutes from the given config.
func NewPSSubstitutesClient(c config) *PSSubstitutesClient {
	return &PSSubstitutesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `pssubstitutes.Hooks(f(g(h())))`.
func (c *PSSubstitutesClient) Use(hooks ...Hook) {
	c.hooks.PSSubstitutes = append(c.hooks.PSSubstitutes, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `pssubstitutes.Intercept(f(g(h())))`.
func (c *PSSubstitutesClient) Intercept(interceptors ...Interceptor) {
	c.inters.PSSubstitutes = append(c.inters.PSSubstitutes, interceptors...)
}

// Create returns a builder for creating a PSSubstitutes entity.
func (c *PSSubstitutesClient) Create() *PSSubstitutesCreate {
	mutation := newPSSubstitutesMutation(c.config, OpCreate)
	return &PSSubstitutesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PSSubstitutes entities.
func (c *PSSubstitutesClient) CreateBulk(builders ...*PSSubstitutesCreate) *PSSubstitutesCreateBulk {
	return &PSSubstitutesCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PSSubstitutesClient) MapCreateBulk(slice any, setFunc func(*PSSubstitutesCreate, int)) *PSSubstitutesCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PSSubstitutesCreateBulk{err: fmt.Errorf("calling to PSSubstitutesClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PSSubstitutesCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PSSubstitutesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PSSubstitutes.
func (c *PSSubstitutesClient) Update() *PSSubstitutesUpdate {
	mutation := newPSSubstitutesMutation(c.config, OpUpdate)
	return &PSSubstitutesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PSSubstitutesClient) UpdateOne(ps *PSSubstitutes) *PSSubstitutesUpdateOne {
	mutation := newPSSubstitutesMutation(c.config, OpUpdateOne, withPSSubstitutes(ps))
	return &PSSubstitutesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PSSubstitutesClient) UpdateOneID(id int) *PSSubstitutesUpdateOne {
	mutation := newPSSubstitutesMutation(c.config, OpUpdateOne, withPSSubstitutesID(id))
	return &PSSubstitutesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PSSubstitutes.
func (c *PSSubstitutesClient) Delete() *PSSubstitutesDelete {
	mutation := newPSSubstitutesMutation(c.config, OpDelete)
	return &PSSubstitutesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PSSubstitutesClient) DeleteOne(ps *PSSubstitutes) *PSSubstitutesDeleteOne {
	return c.DeleteOneID(ps.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PSSubstitutesClient) DeleteOneID(id int) *PSSubstitutesDeleteOne {
	builder := c.Delete().Where(pssubstitutes.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PSSubstitutesDeleteOne{builder}
}

// Query returns a query builder for PSSubstitutes.
func (c *PSSubstitutesClient) Query() *PSSubstitutesQuery {
	return &PSSubstitutesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePSSubstitutes},
		inters: c.Interceptors(),
	}
}

// Get returns a PSSubstitutes entity by its id.
func (c *PSSubstitutesClient) Get(ctx context.Context, id int) (*PSSubstitutes, error) {
	return c.Query().Where(pssubstitutes.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PSSubstitutesClient) GetX(ctx context.Context, id int) *PSSubstitutes {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlayerStats queries the playerStats edge of a PSSubstitutes.
func (c *PSSubstitutesClient) QueryPlayerStats(ps *PSSubstitutes) *PlayerStatsQuery {
	query := (&PlayerStatsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(pssubstitutes.Table, pssubstitutes.FieldID, id),
			sqlgraph.To(playerstats.Table, playerstats.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, pssubstitutes.PlayerStatsTable, pssubstitutes.PlayerStatsColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PSSubstitutesClient) Hooks() []Hook {
	return c.hooks.PSSubstitutes
}

// Interceptors returns the client interceptors.
func (c *PSSubstitutesClient) Interceptors() []Interceptor {
	return c.inters.PSSubstitutes
}

func (c *PSSubstitutesClient) mutate(ctx context.Context, m *PSSubstitutesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PSSubstitutesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PSSubstitutesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PSSubstitutesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PSSubstitutesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PSSubstitutes mutation op: %q", m.Op())
	}
}

// PSTechnicalClient is a client for the PSTechnical schema.
type PSTechnicalClient struct {
	config
}

// NewPSTechnicalClient returns a client for the PSTechnical from the given config.
func NewPSTechnicalClient(c config) *PSTechnicalClient {
	return &PSTechnicalClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `pstechnical.Hooks(f(g(h())))`.
func (c *PSTechnicalClient) Use(hooks ...Hook) {
	c.hooks.PSTechnical = append(c.hooks.PSTechnical, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `pstechnical.Intercept(f(g(h())))`.
func (c *PSTechnicalClient) Intercept(interceptors ...Interceptor) {
	c.inters.PSTechnical = append(c.inters.PSTechnical, interceptors...)
}

// Create returns a builder for creating a PSTechnical entity.
func (c *PSTechnicalClient) Create() *PSTechnicalCreate {
	mutation := newPSTechnicalMutation(c.config, OpCreate)
	return &PSTechnicalCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PSTechnical entities.
func (c *PSTechnicalClient) CreateBulk(builders ...*PSTechnicalCreate) *PSTechnicalCreateBulk {
	return &PSTechnicalCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PSTechnicalClient) MapCreateBulk(slice any, setFunc func(*PSTechnicalCreate, int)) *PSTechnicalCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PSTechnicalCreateBulk{err: fmt.Errorf("calling to PSTechnicalClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PSTechnicalCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PSTechnicalCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PSTechnical.
func (c *PSTechnicalClient) Update() *PSTechnicalUpdate {
	mutation := newPSTechnicalMutation(c.config, OpUpdate)
	return &PSTechnicalUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PSTechnicalClient) UpdateOne(pt *PSTechnical) *PSTechnicalUpdateOne {
	mutation := newPSTechnicalMutation(c.config, OpUpdateOne, withPSTechnical(pt))
	return &PSTechnicalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PSTechnicalClient) UpdateOneID(id int) *PSTechnicalUpdateOne {
	mutation := newPSTechnicalMutation(c.config, OpUpdateOne, withPSTechnicalID(id))
	return &PSTechnicalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PSTechnical.
func (c *PSTechnicalClient) Delete() *PSTechnicalDelete {
	mutation := newPSTechnicalMutation(c.config, OpDelete)
	return &PSTechnicalDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PSTechnicalClient) DeleteOne(pt *PSTechnical) *PSTechnicalDeleteOne {
	return c.DeleteOneID(pt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PSTechnicalClient) DeleteOneID(id int) *PSTechnicalDeleteOne {
	builder := c.Delete().Where(pstechnical.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PSTechnicalDeleteOne{builder}
}

// Query returns a query builder for PSTechnical.
func (c *PSTechnicalClient) Query() *PSTechnicalQuery {
	return &PSTechnicalQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePSTechnical},
		inters: c.Interceptors(),
	}
}

// Get returns a PSTechnical entity by its id.
func (c *PSTechnicalClient) Get(ctx context.Context, id int) (*PSTechnical, error) {
	return c.Query().Where(pstechnical.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PSTechnicalClient) GetX(ctx context.Context, id int) *PSTechnical {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlayerStats queries the playerStats edge of a PSTechnical.
func (c *PSTechnicalClient) QueryPlayerStats(pt *PSTechnical) *PlayerStatsQuery {
	query := (&PlayerStatsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(pstechnical.Table, pstechnical.FieldID, id),
			sqlgraph.To(playerstats.Table, playerstats.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, pstechnical.PlayerStatsTable, pstechnical.PlayerStatsColumn),
		)
		fromV = sqlgraph.Neighbors(pt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PSTechnicalClient) Hooks() []Hook {
	return c.hooks.PSTechnical
}

// Interceptors returns the client interceptors.
func (c *PSTechnicalClient) Interceptors() []Interceptor {
	return c.inters.PSTechnical
}

func (c *PSTechnicalClient) mutate(ctx context.Context, m *PSTechnicalMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PSTechnicalCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PSTechnicalUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PSTechnicalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PSTechnicalDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PSTechnical mutation op: %q", m.Op())
	}
}

// PlayerClient is a client for the Player schema.
type PlayerClient struct {
	config
}

// NewPlayerClient returns a client for the Player from the given config.
func NewPlayerClient(c config) *PlayerClient {
	return &PlayerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `player.Hooks(f(g(h())))`.
func (c *PlayerClient) Use(hooks ...Hook) {
	c.hooks.Player = append(c.hooks.Player, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `player.Intercept(f(g(h())))`.
func (c *PlayerClient) Intercept(interceptors ...Interceptor) {
	c.inters.Player = append(c.inters.Player, interceptors...)
}

// Create returns a builder for creating a Player entity.
func (c *PlayerClient) Create() *PlayerCreate {
	mutation := newPlayerMutation(c.config, OpCreate)
	return &PlayerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Player entities.
func (c *PlayerClient) CreateBulk(builders ...*PlayerCreate) *PlayerCreateBulk {
	return &PlayerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PlayerClient) MapCreateBulk(slice any, setFunc func(*PlayerCreate, int)) *PlayerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PlayerCreateBulk{err: fmt.Errorf("calling to PlayerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PlayerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PlayerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Player.
func (c *PlayerClient) Update() *PlayerUpdate {
	mutation := newPlayerMutation(c.config, OpUpdate)
	return &PlayerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PlayerClient) UpdateOne(pl *Player) *PlayerUpdateOne {
	mutation := newPlayerMutation(c.config, OpUpdateOne, withPlayer(pl))
	return &PlayerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PlayerClient) UpdateOneID(id int) *PlayerUpdateOne {
	mutation := newPlayerMutation(c.config, OpUpdateOne, withPlayerID(id))
	return &PlayerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Player.
func (c *PlayerClient) Delete() *PlayerDelete {
	mutation := newPlayerMutation(c.config, OpDelete)
	return &PlayerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PlayerClient) DeleteOne(pl *Player) *PlayerDeleteOne {
	return c.DeleteOneID(pl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PlayerClient) DeleteOneID(id int) *PlayerDeleteOne {
	builder := c.Delete().Where(player.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PlayerDeleteOne{builder}
}

// Query returns a query builder for Player.
func (c *PlayerClient) Query() *PlayerQuery {
	return &PlayerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePlayer},
		inters: c.Interceptors(),
	}
}

// Get returns a Player entity by its id.
func (c *PlayerClient) Get(ctx context.Context, id int) (*Player, error) {
	return c.Query().Where(player.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PlayerClient) GetX(ctx context.Context, id int) *Player {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBirth queries the birth edge of a Player.
func (c *PlayerClient) QueryBirth(pl *Player) *BirthQuery {
	query := (&BirthClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(player.Table, player.FieldID, id),
			sqlgraph.To(birth.Table, birth.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, player.BirthTable, player.BirthColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNationality queries the nationality edge of a Player.
func (c *PlayerClient) QueryNationality(pl *Player) *CountryQuery {
	query := (&CountryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(player.Table, player.FieldID, id),
			sqlgraph.To(country.Table, country.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, player.NationalityTable, player.NationalityColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySquad queries the squad edge of a Player.
func (c *PlayerClient) QuerySquad(pl *Player) *SquadQuery {
	query := (&SquadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(player.Table, player.FieldID, id),
			sqlgraph.To(squad.Table, squad.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, player.SquadTable, player.SquadColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlayerEvents queries the playerEvents edge of a Player.
func (c *PlayerClient) QueryPlayerEvents(pl *Player) *FixtureEventsQuery {
	query := (&FixtureEventsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(player.Table, player.FieldID, id),
			sqlgraph.To(fixtureevents.Table, fixtureevents.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, player.PlayerEventsTable, player.PlayerEventsColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMatchPlayer queries the matchPlayer edge of a Player.
func (c *PlayerClient) QueryMatchPlayer(pl *Player) *MatchPlayerQuery {
	query := (&MatchPlayerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(player.Table, player.FieldID, id),
			sqlgraph.To(matchplayer.Table, matchplayer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, player.MatchPlayerTable, player.MatchPlayerColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssistEvents queries the assistEvents edge of a Player.
func (c *PlayerClient) QueryAssistEvents(pl *Player) *FixtureEventsQuery {
	query := (&FixtureEventsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(player.Table, player.FieldID, id),
			sqlgraph.To(fixtureevents.Table, fixtureevents.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, player.AssistEventsTable, player.AssistEventsColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlayerStats queries the playerStats edge of a Player.
func (c *PlayerClient) QueryPlayerStats(pl *Player) *PlayerStatsQuery {
	query := (&PlayerStatsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(player.Table, player.FieldID, id),
			sqlgraph.To(playerstats.Table, playerstats.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, player.PlayerStatsTable, player.PlayerStatsColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PlayerClient) Hooks() []Hook {
	return c.hooks.Player
}

// Interceptors returns the client interceptors.
func (c *PlayerClient) Interceptors() []Interceptor {
	return c.inters.Player
}

func (c *PlayerClient) mutate(ctx context.Context, m *PlayerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PlayerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PlayerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PlayerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PlayerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Player mutation op: %q", m.Op())
	}
}

// PlayerStatsClient is a client for the PlayerStats schema.
type PlayerStatsClient struct {
	config
}

// NewPlayerStatsClient returns a client for the PlayerStats from the given config.
func NewPlayerStatsClient(c config) *PlayerStatsClient {
	return &PlayerStatsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `playerstats.Hooks(f(g(h())))`.
func (c *PlayerStatsClient) Use(hooks ...Hook) {
	c.hooks.PlayerStats = append(c.hooks.PlayerStats, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `playerstats.Intercept(f(g(h())))`.
func (c *PlayerStatsClient) Intercept(interceptors ...Interceptor) {
	c.inters.PlayerStats = append(c.inters.PlayerStats, interceptors...)
}

// Create returns a builder for creating a PlayerStats entity.
func (c *PlayerStatsClient) Create() *PlayerStatsCreate {
	mutation := newPlayerStatsMutation(c.config, OpCreate)
	return &PlayerStatsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PlayerStats entities.
func (c *PlayerStatsClient) CreateBulk(builders ...*PlayerStatsCreate) *PlayerStatsCreateBulk {
	return &PlayerStatsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PlayerStatsClient) MapCreateBulk(slice any, setFunc func(*PlayerStatsCreate, int)) *PlayerStatsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PlayerStatsCreateBulk{err: fmt.Errorf("calling to PlayerStatsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PlayerStatsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PlayerStatsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PlayerStats.
func (c *PlayerStatsClient) Update() *PlayerStatsUpdate {
	mutation := newPlayerStatsMutation(c.config, OpUpdate)
	return &PlayerStatsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PlayerStatsClient) UpdateOne(ps *PlayerStats) *PlayerStatsUpdateOne {
	mutation := newPlayerStatsMutation(c.config, OpUpdateOne, withPlayerStats(ps))
	return &PlayerStatsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PlayerStatsClient) UpdateOneID(id int) *PlayerStatsUpdateOne {
	mutation := newPlayerStatsMutation(c.config, OpUpdateOne, withPlayerStatsID(id))
	return &PlayerStatsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PlayerStats.
func (c *PlayerStatsClient) Delete() *PlayerStatsDelete {
	mutation := newPlayerStatsMutation(c.config, OpDelete)
	return &PlayerStatsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PlayerStatsClient) DeleteOne(ps *PlayerStats) *PlayerStatsDeleteOne {
	return c.DeleteOneID(ps.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PlayerStatsClient) DeleteOneID(id int) *PlayerStatsDeleteOne {
	builder := c.Delete().Where(playerstats.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PlayerStatsDeleteOne{builder}
}

// Query returns a query builder for PlayerStats.
func (c *PlayerStatsClient) Query() *PlayerStatsQuery {
	return &PlayerStatsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePlayerStats},
		inters: c.Interceptors(),
	}
}

// Get returns a PlayerStats entity by its id.
func (c *PlayerStatsClient) Get(ctx context.Context, id int) (*PlayerStats, error) {
	return c.Query().Where(playerstats.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PlayerStatsClient) GetX(ctx context.Context, id int) *PlayerStats {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlayer queries the player edge of a PlayerStats.
func (c *PlayerStatsClient) QueryPlayer(ps *PlayerStats) *PlayerQuery {
	query := (&PlayerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(playerstats.Table, playerstats.FieldID, id),
			sqlgraph.To(player.Table, player.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, playerstats.PlayerTable, playerstats.PlayerColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeam queries the team edge of a PlayerStats.
func (c *PlayerStatsClient) QueryTeam(ps *PlayerStats) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(playerstats.Table, playerstats.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, playerstats.TeamTable, playerstats.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlayerEvents queries the playerEvents edge of a PlayerStats.
func (c *PlayerStatsClient) QueryPlayerEvents(ps *PlayerStats) *FixtureEventsQuery {
	query := (&FixtureEventsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(playerstats.Table, playerstats.FieldID, id),
			sqlgraph.To(fixtureevents.Table, fixtureevents.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, playerstats.PlayerEventsTable, playerstats.PlayerEventsColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMatchPlayer queries the matchPlayer edge of a PlayerStats.
func (c *PlayerStatsClient) QueryMatchPlayer(ps *PlayerStats) *MatchPlayerQuery {
	query := (&MatchPlayerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(playerstats.Table, playerstats.FieldID, id),
			sqlgraph.To(matchplayer.Table, matchplayer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, playerstats.MatchPlayerTable, playerstats.MatchPlayerColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssistEvents queries the assistEvents edge of a PlayerStats.
func (c *PlayerStatsClient) QueryAssistEvents(ps *PlayerStats) *FixtureEventsQuery {
	query := (&FixtureEventsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(playerstats.Table, playerstats.FieldID, id),
			sqlgraph.To(fixtureevents.Table, fixtureevents.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, playerstats.AssistEventsTable, playerstats.AssistEventsColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPsGames queries the psGames edge of a PlayerStats.
func (c *PlayerStatsClient) QueryPsGames(ps *PlayerStats) *PSGamesQuery {
	query := (&PSGamesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(playerstats.Table, playerstats.FieldID, id),
			sqlgraph.To(psgames.Table, psgames.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, playerstats.PsGamesTable, playerstats.PsGamesColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPsShooting queries the psShooting edge of a PlayerStats.
func (c *PlayerStatsClient) QueryPsShooting(ps *PlayerStats) *PSShootingQuery {
	query := (&PSShootingClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(playerstats.Table, playerstats.FieldID, id),
			sqlgraph.To(psshooting.Table, psshooting.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, playerstats.PsShootingTable, playerstats.PsShootingColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPsDefense queries the psDefense edge of a PlayerStats.
func (c *PlayerStatsClient) QueryPsDefense(ps *PlayerStats) *PSDefenseQuery {
	query := (&PSDefenseClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(playerstats.Table, playerstats.FieldID, id),
			sqlgraph.To(psdefense.Table, psdefense.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, playerstats.PsDefenseTable, playerstats.PsDefenseColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPsTechnical queries the psTechnical edge of a PlayerStats.
func (c *PlayerStatsClient) QueryPsTechnical(ps *PlayerStats) *PSTechnicalQuery {
	query := (&PSTechnicalClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(playerstats.Table, playerstats.FieldID, id),
			sqlgraph.To(pstechnical.Table, pstechnical.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, playerstats.PsTechnicalTable, playerstats.PsTechnicalColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPsPenalty queries the psPenalty edge of a PlayerStats.
func (c *PlayerStatsClient) QueryPsPenalty(ps *PlayerStats) *PSPenaltyQuery {
	query := (&PSPenaltyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(playerstats.Table, playerstats.FieldID, id),
			sqlgraph.To(pspenalty.Table, pspenalty.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, playerstats.PsPenaltyTable, playerstats.PsPenaltyColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPsSubstitutes queries the psSubstitutes edge of a PlayerStats.
func (c *PlayerStatsClient) QueryPsSubstitutes(ps *PlayerStats) *PSSubstitutesQuery {
	query := (&PSSubstitutesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(playerstats.Table, playerstats.FieldID, id),
			sqlgraph.To(pssubstitutes.Table, pssubstitutes.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, playerstats.PsSubstitutesTable, playerstats.PsSubstitutesColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySeason queries the season edge of a PlayerStats.
func (c *PlayerStatsClient) QuerySeason(ps *PlayerStats) *SeasonQuery {
	query := (&SeasonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(playerstats.Table, playerstats.FieldID, id),
			sqlgraph.To(season.Table, season.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, playerstats.SeasonTable, playerstats.SeasonPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPsFairplay queries the psFairplay edge of a PlayerStats.
func (c *PlayerStatsClient) QueryPsFairplay(ps *PlayerStats) *PSFairplayQuery {
	query := (&PSFairplayClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(playerstats.Table, playerstats.FieldID, id),
			sqlgraph.To(psfairplay.Table, psfairplay.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, playerstats.PsFairplayTable, playerstats.PsFairplayColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PlayerStatsClient) Hooks() []Hook {
	return c.hooks.PlayerStats
}

// Interceptors returns the client interceptors.
func (c *PlayerStatsClient) Interceptors() []Interceptor {
	return c.inters.PlayerStats
}

func (c *PlayerStatsClient) mutate(ctx context.Context, m *PlayerStatsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PlayerStatsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PlayerStatsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PlayerStatsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PlayerStatsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PlayerStats mutation op: %q", m.Op())
	}
}

// SeasonClient is a client for the Season schema.
type SeasonClient struct {
	config
}

// NewSeasonClient returns a client for the Season from the given config.
func NewSeasonClient(c config) *SeasonClient {
	return &SeasonClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `season.Hooks(f(g(h())))`.
func (c *SeasonClient) Use(hooks ...Hook) {
	c.hooks.Season = append(c.hooks.Season, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `season.Intercept(f(g(h())))`.
func (c *SeasonClient) Intercept(interceptors ...Interceptor) {
	c.inters.Season = append(c.inters.Season, interceptors...)
}

// Create returns a builder for creating a Season entity.
func (c *SeasonClient) Create() *SeasonCreate {
	mutation := newSeasonMutation(c.config, OpCreate)
	return &SeasonCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Season entities.
func (c *SeasonClient) CreateBulk(builders ...*SeasonCreate) *SeasonCreateBulk {
	return &SeasonCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SeasonClient) MapCreateBulk(slice any, setFunc func(*SeasonCreate, int)) *SeasonCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SeasonCreateBulk{err: fmt.Errorf("calling to SeasonClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SeasonCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SeasonCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Season.
func (c *SeasonClient) Update() *SeasonUpdate {
	mutation := newSeasonMutation(c.config, OpUpdate)
	return &SeasonUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SeasonClient) UpdateOne(s *Season) *SeasonUpdateOne {
	mutation := newSeasonMutation(c.config, OpUpdateOne, withSeason(s))
	return &SeasonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SeasonClient) UpdateOneID(id int) *SeasonUpdateOne {
	mutation := newSeasonMutation(c.config, OpUpdateOne, withSeasonID(id))
	return &SeasonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Season.
func (c *SeasonClient) Delete() *SeasonDelete {
	mutation := newSeasonMutation(c.config, OpDelete)
	return &SeasonDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SeasonClient) DeleteOne(s *Season) *SeasonDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SeasonClient) DeleteOneID(id int) *SeasonDeleteOne {
	builder := c.Delete().Where(season.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SeasonDeleteOne{builder}
}

// Query returns a query builder for Season.
func (c *SeasonClient) Query() *SeasonQuery {
	return &SeasonQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSeason},
		inters: c.Interceptors(),
	}
}

// Get returns a Season entity by its id.
func (c *SeasonClient) Get(ctx context.Context, id int) (*Season, error) {
	return c.Query().Where(season.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SeasonClient) GetX(ctx context.Context, id int) *Season {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryLeague queries the league edge of a Season.
func (c *SeasonClient) QueryLeague(s *Season) *LeagueQuery {
	query := (&LeagueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(season.Table, season.FieldID, id),
			sqlgraph.To(league.Table, league.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, season.LeagueTable, season.LeagueColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFixtures queries the fixtures edge of a Season.
func (c *SeasonClient) QueryFixtures(s *Season) *FixtureQuery {
	query := (&FixtureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(season.Table, season.FieldID, id),
			sqlgraph.To(fixture.Table, fixture.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, season.FixturesTable, season.FixturesColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStandings queries the standings edge of a Season.
func (c *SeasonClient) QueryStandings(s *Season) *StandingsQuery {
	query := (&StandingsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(season.Table, season.FieldID, id),
			sqlgraph.To(standings.Table, standings.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, season.StandingsTable, season.StandingsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeams queries the teams edge of a Season.
func (c *SeasonClient) QueryTeams(s *Season) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(season.Table, season.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, season.TeamsTable, season.TeamsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySquad queries the squad edge of a Season.
func (c *SeasonClient) QuerySquad(s *Season) *SquadQuery {
	query := (&SquadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(season.Table, season.FieldID, id),
			sqlgraph.To(squad.Table, squad.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, season.SquadTable, season.SquadColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlayerStats queries the playerStats edge of a Season.
func (c *SeasonClient) QueryPlayerStats(s *Season) *PlayerStatsQuery {
	query := (&PlayerStatsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(season.Table, season.FieldID, id),
			sqlgraph.To(playerstats.Table, playerstats.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, season.PlayerStatsTable, season.PlayerStatsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SeasonClient) Hooks() []Hook {
	return c.hooks.Season
}

// Interceptors returns the client interceptors.
func (c *SeasonClient) Interceptors() []Interceptor {
	return c.inters.Season
}

func (c *SeasonClient) mutate(ctx context.Context, m *SeasonMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SeasonCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SeasonUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SeasonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SeasonDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Season mutation op: %q", m.Op())
	}
}

// SquadClient is a client for the Squad schema.
type SquadClient struct {
	config
}

// NewSquadClient returns a client for the Squad from the given config.
func NewSquadClient(c config) *SquadClient {
	return &SquadClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `squad.Hooks(f(g(h())))`.
func (c *SquadClient) Use(hooks ...Hook) {
	c.hooks.Squad = append(c.hooks.Squad, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `squad.Intercept(f(g(h())))`.
func (c *SquadClient) Intercept(interceptors ...Interceptor) {
	c.inters.Squad = append(c.inters.Squad, interceptors...)
}

// Create returns a builder for creating a Squad entity.
func (c *SquadClient) Create() *SquadCreate {
	mutation := newSquadMutation(c.config, OpCreate)
	return &SquadCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Squad entities.
func (c *SquadClient) CreateBulk(builders ...*SquadCreate) *SquadCreateBulk {
	return &SquadCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SquadClient) MapCreateBulk(slice any, setFunc func(*SquadCreate, int)) *SquadCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SquadCreateBulk{err: fmt.Errorf("calling to SquadClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SquadCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SquadCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Squad.
func (c *SquadClient) Update() *SquadUpdate {
	mutation := newSquadMutation(c.config, OpUpdate)
	return &SquadUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SquadClient) UpdateOne(s *Squad) *SquadUpdateOne {
	mutation := newSquadMutation(c.config, OpUpdateOne, withSquad(s))
	return &SquadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SquadClient) UpdateOneID(id int) *SquadUpdateOne {
	mutation := newSquadMutation(c.config, OpUpdateOne, withSquadID(id))
	return &SquadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Squad.
func (c *SquadClient) Delete() *SquadDelete {
	mutation := newSquadMutation(c.config, OpDelete)
	return &SquadDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SquadClient) DeleteOne(s *Squad) *SquadDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SquadClient) DeleteOneID(id int) *SquadDeleteOne {
	builder := c.Delete().Where(squad.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SquadDeleteOne{builder}
}

// Query returns a query builder for Squad.
func (c *SquadClient) Query() *SquadQuery {
	return &SquadQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSquad},
		inters: c.Interceptors(),
	}
}

// Get returns a Squad entity by its id.
func (c *SquadClient) Get(ctx context.Context, id int) (*Squad, error) {
	return c.Query().Where(squad.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SquadClient) GetX(ctx context.Context, id int) *Squad {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlayer queries the player edge of a Squad.
func (c *SquadClient) QueryPlayer(s *Squad) *PlayerQuery {
	query := (&PlayerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(squad.Table, squad.FieldID, id),
			sqlgraph.To(player.Table, player.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, squad.PlayerTable, squad.PlayerColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeam queries the team edge of a Squad.
func (c *SquadClient) QueryTeam(s *Squad) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(squad.Table, squad.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, squad.TeamTable, squad.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySeason queries the season edge of a Squad.
func (c *SquadClient) QuerySeason(s *Squad) *SeasonQuery {
	query := (&SeasonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(squad.Table, squad.FieldID, id),
			sqlgraph.To(season.Table, season.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, squad.SeasonTable, squad.SeasonColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SquadClient) Hooks() []Hook {
	return c.hooks.Squad
}

// Interceptors returns the client interceptors.
func (c *SquadClient) Interceptors() []Interceptor {
	return c.inters.Squad
}

func (c *SquadClient) mutate(ctx context.Context, m *SquadMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SquadCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SquadUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SquadUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SquadDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Squad mutation op: %q", m.Op())
	}
}

// StandingsClient is a client for the Standings schema.
type StandingsClient struct {
	config
}

// NewStandingsClient returns a client for the Standings from the given config.
func NewStandingsClient(c config) *StandingsClient {
	return &StandingsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `standings.Hooks(f(g(h())))`.
func (c *StandingsClient) Use(hooks ...Hook) {
	c.hooks.Standings = append(c.hooks.Standings, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `standings.Intercept(f(g(h())))`.
func (c *StandingsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Standings = append(c.inters.Standings, interceptors...)
}

// Create returns a builder for creating a Standings entity.
func (c *StandingsClient) Create() *StandingsCreate {
	mutation := newStandingsMutation(c.config, OpCreate)
	return &StandingsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Standings entities.
func (c *StandingsClient) CreateBulk(builders ...*StandingsCreate) *StandingsCreateBulk {
	return &StandingsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StandingsClient) MapCreateBulk(slice any, setFunc func(*StandingsCreate, int)) *StandingsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StandingsCreateBulk{err: fmt.Errorf("calling to StandingsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StandingsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StandingsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Standings.
func (c *StandingsClient) Update() *StandingsUpdate {
	mutation := newStandingsMutation(c.config, OpUpdate)
	return &StandingsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StandingsClient) UpdateOne(s *Standings) *StandingsUpdateOne {
	mutation := newStandingsMutation(c.config, OpUpdateOne, withStandings(s))
	return &StandingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StandingsClient) UpdateOneID(id int) *StandingsUpdateOne {
	mutation := newStandingsMutation(c.config, OpUpdateOne, withStandingsID(id))
	return &StandingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Standings.
func (c *StandingsClient) Delete() *StandingsDelete {
	mutation := newStandingsMutation(c.config, OpDelete)
	return &StandingsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StandingsClient) DeleteOne(s *Standings) *StandingsDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StandingsClient) DeleteOneID(id int) *StandingsDeleteOne {
	builder := c.Delete().Where(standings.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StandingsDeleteOne{builder}
}

// Query returns a query builder for Standings.
func (c *StandingsClient) Query() *StandingsQuery {
	return &StandingsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStandings},
		inters: c.Interceptors(),
	}
}

// Get returns a Standings entity by its id.
func (c *StandingsClient) Get(ctx context.Context, id int) (*Standings, error) {
	return c.Query().Where(standings.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StandingsClient) GetX(ctx context.Context, id int) *Standings {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTeam queries the team edge of a Standings.
func (c *StandingsClient) QueryTeam(s *Standings) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(standings.Table, standings.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, standings.TeamTable, standings.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySeason queries the season edge of a Standings.
func (c *StandingsClient) QuerySeason(s *Standings) *SeasonQuery {
	query := (&SeasonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(standings.Table, standings.FieldID, id),
			sqlgraph.To(season.Table, season.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, standings.SeasonTable, standings.SeasonColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StandingsClient) Hooks() []Hook {
	return c.hooks.Standings
}

// Interceptors returns the client interceptors.
func (c *StandingsClient) Interceptors() []Interceptor {
	return c.inters.Standings
}

func (c *StandingsClient) mutate(ctx context.Context, m *StandingsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StandingsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StandingsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StandingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StandingsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Standings mutation op: %q", m.Op())
	}
}

// TSBiggestClient is a client for the TSBiggest schema.
type TSBiggestClient struct {
	config
}

// NewTSBiggestClient returns a client for the TSBiggest from the given config.
func NewTSBiggestClient(c config) *TSBiggestClient {
	return &TSBiggestClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tsbiggest.Hooks(f(g(h())))`.
func (c *TSBiggestClient) Use(hooks ...Hook) {
	c.hooks.TSBiggest = append(c.hooks.TSBiggest, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tsbiggest.Intercept(f(g(h())))`.
func (c *TSBiggestClient) Intercept(interceptors ...Interceptor) {
	c.inters.TSBiggest = append(c.inters.TSBiggest, interceptors...)
}

// Create returns a builder for creating a TSBiggest entity.
func (c *TSBiggestClient) Create() *TSBiggestCreate {
	mutation := newTSBiggestMutation(c.config, OpCreate)
	return &TSBiggestCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TSBiggest entities.
func (c *TSBiggestClient) CreateBulk(builders ...*TSBiggestCreate) *TSBiggestCreateBulk {
	return &TSBiggestCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TSBiggestClient) MapCreateBulk(slice any, setFunc func(*TSBiggestCreate, int)) *TSBiggestCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TSBiggestCreateBulk{err: fmt.Errorf("calling to TSBiggestClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TSBiggestCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TSBiggestCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TSBiggest.
func (c *TSBiggestClient) Update() *TSBiggestUpdate {
	mutation := newTSBiggestMutation(c.config, OpUpdate)
	return &TSBiggestUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TSBiggestClient) UpdateOne(tb *TSBiggest) *TSBiggestUpdateOne {
	mutation := newTSBiggestMutation(c.config, OpUpdateOne, withTSBiggest(tb))
	return &TSBiggestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TSBiggestClient) UpdateOneID(id int) *TSBiggestUpdateOne {
	mutation := newTSBiggestMutation(c.config, OpUpdateOne, withTSBiggestID(id))
	return &TSBiggestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TSBiggest.
func (c *TSBiggestClient) Delete() *TSBiggestDelete {
	mutation := newTSBiggestMutation(c.config, OpDelete)
	return &TSBiggestDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TSBiggestClient) DeleteOne(tb *TSBiggest) *TSBiggestDeleteOne {
	return c.DeleteOneID(tb.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TSBiggestClient) DeleteOneID(id int) *TSBiggestDeleteOne {
	builder := c.Delete().Where(tsbiggest.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TSBiggestDeleteOne{builder}
}

// Query returns a query builder for TSBiggest.
func (c *TSBiggestClient) Query() *TSBiggestQuery {
	return &TSBiggestQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTSBiggest},
		inters: c.Interceptors(),
	}
}

// Get returns a TSBiggest entity by its id.
func (c *TSBiggestClient) Get(ctx context.Context, id int) (*TSBiggest, error) {
	return c.Query().Where(tsbiggest.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TSBiggestClient) GetX(ctx context.Context, id int) *TSBiggest {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTeam queries the team edge of a TSBiggest.
func (c *TSBiggestClient) QueryTeam(tb *TSBiggest) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tsbiggest.Table, tsbiggest.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, tsbiggest.TeamTable, tsbiggest.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(tb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TSBiggestClient) Hooks() []Hook {
	return c.hooks.TSBiggest
}

// Interceptors returns the client interceptors.
func (c *TSBiggestClient) Interceptors() []Interceptor {
	return c.inters.TSBiggest
}

func (c *TSBiggestClient) mutate(ctx context.Context, m *TSBiggestMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TSBiggestCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TSBiggestUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TSBiggestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TSBiggestDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TSBiggest mutation op: %q", m.Op())
	}
}

// TSCardsClient is a client for the TSCards schema.
type TSCardsClient struct {
	config
}

// NewTSCardsClient returns a client for the TSCards from the given config.
func NewTSCardsClient(c config) *TSCardsClient {
	return &TSCardsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tscards.Hooks(f(g(h())))`.
func (c *TSCardsClient) Use(hooks ...Hook) {
	c.hooks.TSCards = append(c.hooks.TSCards, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tscards.Intercept(f(g(h())))`.
func (c *TSCardsClient) Intercept(interceptors ...Interceptor) {
	c.inters.TSCards = append(c.inters.TSCards, interceptors...)
}

// Create returns a builder for creating a TSCards entity.
func (c *TSCardsClient) Create() *TSCardsCreate {
	mutation := newTSCardsMutation(c.config, OpCreate)
	return &TSCardsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TSCards entities.
func (c *TSCardsClient) CreateBulk(builders ...*TSCardsCreate) *TSCardsCreateBulk {
	return &TSCardsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TSCardsClient) MapCreateBulk(slice any, setFunc func(*TSCardsCreate, int)) *TSCardsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TSCardsCreateBulk{err: fmt.Errorf("calling to TSCardsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TSCardsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TSCardsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TSCards.
func (c *TSCardsClient) Update() *TSCardsUpdate {
	mutation := newTSCardsMutation(c.config, OpUpdate)
	return &TSCardsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TSCardsClient) UpdateOne(tc *TSCards) *TSCardsUpdateOne {
	mutation := newTSCardsMutation(c.config, OpUpdateOne, withTSCards(tc))
	return &TSCardsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TSCardsClient) UpdateOneID(id int) *TSCardsUpdateOne {
	mutation := newTSCardsMutation(c.config, OpUpdateOne, withTSCardsID(id))
	return &TSCardsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TSCards.
func (c *TSCardsClient) Delete() *TSCardsDelete {
	mutation := newTSCardsMutation(c.config, OpDelete)
	return &TSCardsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TSCardsClient) DeleteOne(tc *TSCards) *TSCardsDeleteOne {
	return c.DeleteOneID(tc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TSCardsClient) DeleteOneID(id int) *TSCardsDeleteOne {
	builder := c.Delete().Where(tscards.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TSCardsDeleteOne{builder}
}

// Query returns a query builder for TSCards.
func (c *TSCardsClient) Query() *TSCardsQuery {
	return &TSCardsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTSCards},
		inters: c.Interceptors(),
	}
}

// Get returns a TSCards entity by its id.
func (c *TSCardsClient) Get(ctx context.Context, id int) (*TSCards, error) {
	return c.Query().Where(tscards.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TSCardsClient) GetX(ctx context.Context, id int) *TSCards {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTeam queries the team edge of a TSCards.
func (c *TSCardsClient) QueryTeam(tc *TSCards) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tscards.Table, tscards.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, tscards.TeamTable, tscards.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(tc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TSCardsClient) Hooks() []Hook {
	return c.hooks.TSCards
}

// Interceptors returns the client interceptors.
func (c *TSCardsClient) Interceptors() []Interceptor {
	return c.inters.TSCards
}

func (c *TSCardsClient) mutate(ctx context.Context, m *TSCardsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TSCardsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TSCardsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TSCardsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TSCardsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TSCards mutation op: %q", m.Op())
	}
}

// TSCleanSheetClient is a client for the TSCleanSheet schema.
type TSCleanSheetClient struct {
	config
}

// NewTSCleanSheetClient returns a client for the TSCleanSheet from the given config.
func NewTSCleanSheetClient(c config) *TSCleanSheetClient {
	return &TSCleanSheetClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tscleansheet.Hooks(f(g(h())))`.
func (c *TSCleanSheetClient) Use(hooks ...Hook) {
	c.hooks.TSCleanSheet = append(c.hooks.TSCleanSheet, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tscleansheet.Intercept(f(g(h())))`.
func (c *TSCleanSheetClient) Intercept(interceptors ...Interceptor) {
	c.inters.TSCleanSheet = append(c.inters.TSCleanSheet, interceptors...)
}

// Create returns a builder for creating a TSCleanSheet entity.
func (c *TSCleanSheetClient) Create() *TSCleanSheetCreate {
	mutation := newTSCleanSheetMutation(c.config, OpCreate)
	return &TSCleanSheetCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TSCleanSheet entities.
func (c *TSCleanSheetClient) CreateBulk(builders ...*TSCleanSheetCreate) *TSCleanSheetCreateBulk {
	return &TSCleanSheetCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TSCleanSheetClient) MapCreateBulk(slice any, setFunc func(*TSCleanSheetCreate, int)) *TSCleanSheetCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TSCleanSheetCreateBulk{err: fmt.Errorf("calling to TSCleanSheetClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TSCleanSheetCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TSCleanSheetCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TSCleanSheet.
func (c *TSCleanSheetClient) Update() *TSCleanSheetUpdate {
	mutation := newTSCleanSheetMutation(c.config, OpUpdate)
	return &TSCleanSheetUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TSCleanSheetClient) UpdateOne(tcs *TSCleanSheet) *TSCleanSheetUpdateOne {
	mutation := newTSCleanSheetMutation(c.config, OpUpdateOne, withTSCleanSheet(tcs))
	return &TSCleanSheetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TSCleanSheetClient) UpdateOneID(id int) *TSCleanSheetUpdateOne {
	mutation := newTSCleanSheetMutation(c.config, OpUpdateOne, withTSCleanSheetID(id))
	return &TSCleanSheetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TSCleanSheet.
func (c *TSCleanSheetClient) Delete() *TSCleanSheetDelete {
	mutation := newTSCleanSheetMutation(c.config, OpDelete)
	return &TSCleanSheetDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TSCleanSheetClient) DeleteOne(tcs *TSCleanSheet) *TSCleanSheetDeleteOne {
	return c.DeleteOneID(tcs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TSCleanSheetClient) DeleteOneID(id int) *TSCleanSheetDeleteOne {
	builder := c.Delete().Where(tscleansheet.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TSCleanSheetDeleteOne{builder}
}

// Query returns a query builder for TSCleanSheet.
func (c *TSCleanSheetClient) Query() *TSCleanSheetQuery {
	return &TSCleanSheetQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTSCleanSheet},
		inters: c.Interceptors(),
	}
}

// Get returns a TSCleanSheet entity by its id.
func (c *TSCleanSheetClient) Get(ctx context.Context, id int) (*TSCleanSheet, error) {
	return c.Query().Where(tscleansheet.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TSCleanSheetClient) GetX(ctx context.Context, id int) *TSCleanSheet {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTeam queries the team edge of a TSCleanSheet.
func (c *TSCleanSheetClient) QueryTeam(tcs *TSCleanSheet) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tcs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tscleansheet.Table, tscleansheet.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, tscleansheet.TeamTable, tscleansheet.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(tcs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TSCleanSheetClient) Hooks() []Hook {
	return c.hooks.TSCleanSheet
}

// Interceptors returns the client interceptors.
func (c *TSCleanSheetClient) Interceptors() []Interceptor {
	return c.inters.TSCleanSheet
}

func (c *TSCleanSheetClient) mutate(ctx context.Context, m *TSCleanSheetMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TSCleanSheetCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TSCleanSheetUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TSCleanSheetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TSCleanSheetDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TSCleanSheet mutation op: %q", m.Op())
	}
}

// TSFailedToScoreClient is a client for the TSFailedToScore schema.
type TSFailedToScoreClient struct {
	config
}

// NewTSFailedToScoreClient returns a client for the TSFailedToScore from the given config.
func NewTSFailedToScoreClient(c config) *TSFailedToScoreClient {
	return &TSFailedToScoreClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tsfailedtoscore.Hooks(f(g(h())))`.
func (c *TSFailedToScoreClient) Use(hooks ...Hook) {
	c.hooks.TSFailedToScore = append(c.hooks.TSFailedToScore, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tsfailedtoscore.Intercept(f(g(h())))`.
func (c *TSFailedToScoreClient) Intercept(interceptors ...Interceptor) {
	c.inters.TSFailedToScore = append(c.inters.TSFailedToScore, interceptors...)
}

// Create returns a builder for creating a TSFailedToScore entity.
func (c *TSFailedToScoreClient) Create() *TSFailedToScoreCreate {
	mutation := newTSFailedToScoreMutation(c.config, OpCreate)
	return &TSFailedToScoreCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TSFailedToScore entities.
func (c *TSFailedToScoreClient) CreateBulk(builders ...*TSFailedToScoreCreate) *TSFailedToScoreCreateBulk {
	return &TSFailedToScoreCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TSFailedToScoreClient) MapCreateBulk(slice any, setFunc func(*TSFailedToScoreCreate, int)) *TSFailedToScoreCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TSFailedToScoreCreateBulk{err: fmt.Errorf("calling to TSFailedToScoreClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TSFailedToScoreCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TSFailedToScoreCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TSFailedToScore.
func (c *TSFailedToScoreClient) Update() *TSFailedToScoreUpdate {
	mutation := newTSFailedToScoreMutation(c.config, OpUpdate)
	return &TSFailedToScoreUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TSFailedToScoreClient) UpdateOne(tfts *TSFailedToScore) *TSFailedToScoreUpdateOne {
	mutation := newTSFailedToScoreMutation(c.config, OpUpdateOne, withTSFailedToScore(tfts))
	return &TSFailedToScoreUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TSFailedToScoreClient) UpdateOneID(id int) *TSFailedToScoreUpdateOne {
	mutation := newTSFailedToScoreMutation(c.config, OpUpdateOne, withTSFailedToScoreID(id))
	return &TSFailedToScoreUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TSFailedToScore.
func (c *TSFailedToScoreClient) Delete() *TSFailedToScoreDelete {
	mutation := newTSFailedToScoreMutation(c.config, OpDelete)
	return &TSFailedToScoreDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TSFailedToScoreClient) DeleteOne(tfts *TSFailedToScore) *TSFailedToScoreDeleteOne {
	return c.DeleteOneID(tfts.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TSFailedToScoreClient) DeleteOneID(id int) *TSFailedToScoreDeleteOne {
	builder := c.Delete().Where(tsfailedtoscore.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TSFailedToScoreDeleteOne{builder}
}

// Query returns a query builder for TSFailedToScore.
func (c *TSFailedToScoreClient) Query() *TSFailedToScoreQuery {
	return &TSFailedToScoreQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTSFailedToScore},
		inters: c.Interceptors(),
	}
}

// Get returns a TSFailedToScore entity by its id.
func (c *TSFailedToScoreClient) Get(ctx context.Context, id int) (*TSFailedToScore, error) {
	return c.Query().Where(tsfailedtoscore.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TSFailedToScoreClient) GetX(ctx context.Context, id int) *TSFailedToScore {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTeam queries the team edge of a TSFailedToScore.
func (c *TSFailedToScoreClient) QueryTeam(tfts *TSFailedToScore) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tfts.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tsfailedtoscore.Table, tsfailedtoscore.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, tsfailedtoscore.TeamTable, tsfailedtoscore.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(tfts.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TSFailedToScoreClient) Hooks() []Hook {
	return c.hooks.TSFailedToScore
}

// Interceptors returns the client interceptors.
func (c *TSFailedToScoreClient) Interceptors() []Interceptor {
	return c.inters.TSFailedToScore
}

func (c *TSFailedToScoreClient) mutate(ctx context.Context, m *TSFailedToScoreMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TSFailedToScoreCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TSFailedToScoreUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TSFailedToScoreUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TSFailedToScoreDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TSFailedToScore mutation op: %q", m.Op())
	}
}

// TSFixturesClient is a client for the TSFixtures schema.
type TSFixturesClient struct {
	config
}

// NewTSFixturesClient returns a client for the TSFixtures from the given config.
func NewTSFixturesClient(c config) *TSFixturesClient {
	return &TSFixturesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tsfixtures.Hooks(f(g(h())))`.
func (c *TSFixturesClient) Use(hooks ...Hook) {
	c.hooks.TSFixtures = append(c.hooks.TSFixtures, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tsfixtures.Intercept(f(g(h())))`.
func (c *TSFixturesClient) Intercept(interceptors ...Interceptor) {
	c.inters.TSFixtures = append(c.inters.TSFixtures, interceptors...)
}

// Create returns a builder for creating a TSFixtures entity.
func (c *TSFixturesClient) Create() *TSFixturesCreate {
	mutation := newTSFixturesMutation(c.config, OpCreate)
	return &TSFixturesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TSFixtures entities.
func (c *TSFixturesClient) CreateBulk(builders ...*TSFixturesCreate) *TSFixturesCreateBulk {
	return &TSFixturesCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TSFixturesClient) MapCreateBulk(slice any, setFunc func(*TSFixturesCreate, int)) *TSFixturesCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TSFixturesCreateBulk{err: fmt.Errorf("calling to TSFixturesClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TSFixturesCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TSFixturesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TSFixtures.
func (c *TSFixturesClient) Update() *TSFixturesUpdate {
	mutation := newTSFixturesMutation(c.config, OpUpdate)
	return &TSFixturesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TSFixturesClient) UpdateOne(tf *TSFixtures) *TSFixturesUpdateOne {
	mutation := newTSFixturesMutation(c.config, OpUpdateOne, withTSFixtures(tf))
	return &TSFixturesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TSFixturesClient) UpdateOneID(id int) *TSFixturesUpdateOne {
	mutation := newTSFixturesMutation(c.config, OpUpdateOne, withTSFixturesID(id))
	return &TSFixturesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TSFixtures.
func (c *TSFixturesClient) Delete() *TSFixturesDelete {
	mutation := newTSFixturesMutation(c.config, OpDelete)
	return &TSFixturesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TSFixturesClient) DeleteOne(tf *TSFixtures) *TSFixturesDeleteOne {
	return c.DeleteOneID(tf.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TSFixturesClient) DeleteOneID(id int) *TSFixturesDeleteOne {
	builder := c.Delete().Where(tsfixtures.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TSFixturesDeleteOne{builder}
}

// Query returns a query builder for TSFixtures.
func (c *TSFixturesClient) Query() *TSFixturesQuery {
	return &TSFixturesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTSFixtures},
		inters: c.Interceptors(),
	}
}

// Get returns a TSFixtures entity by its id.
func (c *TSFixturesClient) Get(ctx context.Context, id int) (*TSFixtures, error) {
	return c.Query().Where(tsfixtures.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TSFixturesClient) GetX(ctx context.Context, id int) *TSFixtures {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTeam queries the team edge of a TSFixtures.
func (c *TSFixturesClient) QueryTeam(tf *TSFixtures) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tf.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tsfixtures.Table, tsfixtures.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, tsfixtures.TeamTable, tsfixtures.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(tf.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TSFixturesClient) Hooks() []Hook {
	return c.hooks.TSFixtures
}

// Interceptors returns the client interceptors.
func (c *TSFixturesClient) Interceptors() []Interceptor {
	return c.inters.TSFixtures
}

func (c *TSFixturesClient) mutate(ctx context.Context, m *TSFixturesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TSFixturesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TSFixturesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TSFixturesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TSFixturesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TSFixtures mutation op: %q", m.Op())
	}
}

// TSGoalsClient is a client for the TSGoals schema.
type TSGoalsClient struct {
	config
}

// NewTSGoalsClient returns a client for the TSGoals from the given config.
func NewTSGoalsClient(c config) *TSGoalsClient {
	return &TSGoalsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tsgoals.Hooks(f(g(h())))`.
func (c *TSGoalsClient) Use(hooks ...Hook) {
	c.hooks.TSGoals = append(c.hooks.TSGoals, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tsgoals.Intercept(f(g(h())))`.
func (c *TSGoalsClient) Intercept(interceptors ...Interceptor) {
	c.inters.TSGoals = append(c.inters.TSGoals, interceptors...)
}

// Create returns a builder for creating a TSGoals entity.
func (c *TSGoalsClient) Create() *TSGoalsCreate {
	mutation := newTSGoalsMutation(c.config, OpCreate)
	return &TSGoalsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TSGoals entities.
func (c *TSGoalsClient) CreateBulk(builders ...*TSGoalsCreate) *TSGoalsCreateBulk {
	return &TSGoalsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TSGoalsClient) MapCreateBulk(slice any, setFunc func(*TSGoalsCreate, int)) *TSGoalsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TSGoalsCreateBulk{err: fmt.Errorf("calling to TSGoalsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TSGoalsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TSGoalsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TSGoals.
func (c *TSGoalsClient) Update() *TSGoalsUpdate {
	mutation := newTSGoalsMutation(c.config, OpUpdate)
	return &TSGoalsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TSGoalsClient) UpdateOne(tg *TSGoals) *TSGoalsUpdateOne {
	mutation := newTSGoalsMutation(c.config, OpUpdateOne, withTSGoals(tg))
	return &TSGoalsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TSGoalsClient) UpdateOneID(id int) *TSGoalsUpdateOne {
	mutation := newTSGoalsMutation(c.config, OpUpdateOne, withTSGoalsID(id))
	return &TSGoalsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TSGoals.
func (c *TSGoalsClient) Delete() *TSGoalsDelete {
	mutation := newTSGoalsMutation(c.config, OpDelete)
	return &TSGoalsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TSGoalsClient) DeleteOne(tg *TSGoals) *TSGoalsDeleteOne {
	return c.DeleteOneID(tg.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TSGoalsClient) DeleteOneID(id int) *TSGoalsDeleteOne {
	builder := c.Delete().Where(tsgoals.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TSGoalsDeleteOne{builder}
}

// Query returns a query builder for TSGoals.
func (c *TSGoalsClient) Query() *TSGoalsQuery {
	return &TSGoalsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTSGoals},
		inters: c.Interceptors(),
	}
}

// Get returns a TSGoals entity by its id.
func (c *TSGoalsClient) Get(ctx context.Context, id int) (*TSGoals, error) {
	return c.Query().Where(tsgoals.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TSGoalsClient) GetX(ctx context.Context, id int) *TSGoals {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTeam queries the team edge of a TSGoals.
func (c *TSGoalsClient) QueryTeam(tg *TSGoals) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tg.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tsgoals.Table, tsgoals.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, tsgoals.TeamTable, tsgoals.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(tg.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TSGoalsClient) Hooks() []Hook {
	return c.hooks.TSGoals
}

// Interceptors returns the client interceptors.
func (c *TSGoalsClient) Interceptors() []Interceptor {
	return c.inters.TSGoals
}

func (c *TSGoalsClient) mutate(ctx context.Context, m *TSGoalsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TSGoalsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TSGoalsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TSGoalsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TSGoalsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TSGoals mutation op: %q", m.Op())
	}
}

// TSLineupsClient is a client for the TSLineups schema.
type TSLineupsClient struct {
	config
}

// NewTSLineupsClient returns a client for the TSLineups from the given config.
func NewTSLineupsClient(c config) *TSLineupsClient {
	return &TSLineupsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tslineups.Hooks(f(g(h())))`.
func (c *TSLineupsClient) Use(hooks ...Hook) {
	c.hooks.TSLineups = append(c.hooks.TSLineups, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tslineups.Intercept(f(g(h())))`.
func (c *TSLineupsClient) Intercept(interceptors ...Interceptor) {
	c.inters.TSLineups = append(c.inters.TSLineups, interceptors...)
}

// Create returns a builder for creating a TSLineups entity.
func (c *TSLineupsClient) Create() *TSLineupsCreate {
	mutation := newTSLineupsMutation(c.config, OpCreate)
	return &TSLineupsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TSLineups entities.
func (c *TSLineupsClient) CreateBulk(builders ...*TSLineupsCreate) *TSLineupsCreateBulk {
	return &TSLineupsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TSLineupsClient) MapCreateBulk(slice any, setFunc func(*TSLineupsCreate, int)) *TSLineupsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TSLineupsCreateBulk{err: fmt.Errorf("calling to TSLineupsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TSLineupsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TSLineupsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TSLineups.
func (c *TSLineupsClient) Update() *TSLineupsUpdate {
	mutation := newTSLineupsMutation(c.config, OpUpdate)
	return &TSLineupsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TSLineupsClient) UpdateOne(tl *TSLineups) *TSLineupsUpdateOne {
	mutation := newTSLineupsMutation(c.config, OpUpdateOne, withTSLineups(tl))
	return &TSLineupsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TSLineupsClient) UpdateOneID(id int) *TSLineupsUpdateOne {
	mutation := newTSLineupsMutation(c.config, OpUpdateOne, withTSLineupsID(id))
	return &TSLineupsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TSLineups.
func (c *TSLineupsClient) Delete() *TSLineupsDelete {
	mutation := newTSLineupsMutation(c.config, OpDelete)
	return &TSLineupsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TSLineupsClient) DeleteOne(tl *TSLineups) *TSLineupsDeleteOne {
	return c.DeleteOneID(tl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TSLineupsClient) DeleteOneID(id int) *TSLineupsDeleteOne {
	builder := c.Delete().Where(tslineups.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TSLineupsDeleteOne{builder}
}

// Query returns a query builder for TSLineups.
func (c *TSLineupsClient) Query() *TSLineupsQuery {
	return &TSLineupsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTSLineups},
		inters: c.Interceptors(),
	}
}

// Get returns a TSLineups entity by its id.
func (c *TSLineupsClient) Get(ctx context.Context, id int) (*TSLineups, error) {
	return c.Query().Where(tslineups.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TSLineupsClient) GetX(ctx context.Context, id int) *TSLineups {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTeam queries the team edge of a TSLineups.
func (c *TSLineupsClient) QueryTeam(tl *TSLineups) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tslineups.Table, tslineups.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tslineups.TeamTable, tslineups.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(tl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TSLineupsClient) Hooks() []Hook {
	return c.hooks.TSLineups
}

// Interceptors returns the client interceptors.
func (c *TSLineupsClient) Interceptors() []Interceptor {
	return c.inters.TSLineups
}

func (c *TSLineupsClient) mutate(ctx context.Context, m *TSLineupsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TSLineupsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TSLineupsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TSLineupsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TSLineupsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TSLineups mutation op: %q", m.Op())
	}
}

// TSPenaltyClient is a client for the TSPenalty schema.
type TSPenaltyClient struct {
	config
}

// NewTSPenaltyClient returns a client for the TSPenalty from the given config.
func NewTSPenaltyClient(c config) *TSPenaltyClient {
	return &TSPenaltyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tspenalty.Hooks(f(g(h())))`.
func (c *TSPenaltyClient) Use(hooks ...Hook) {
	c.hooks.TSPenalty = append(c.hooks.TSPenalty, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tspenalty.Intercept(f(g(h())))`.
func (c *TSPenaltyClient) Intercept(interceptors ...Interceptor) {
	c.inters.TSPenalty = append(c.inters.TSPenalty, interceptors...)
}

// Create returns a builder for creating a TSPenalty entity.
func (c *TSPenaltyClient) Create() *TSPenaltyCreate {
	mutation := newTSPenaltyMutation(c.config, OpCreate)
	return &TSPenaltyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TSPenalty entities.
func (c *TSPenaltyClient) CreateBulk(builders ...*TSPenaltyCreate) *TSPenaltyCreateBulk {
	return &TSPenaltyCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TSPenaltyClient) MapCreateBulk(slice any, setFunc func(*TSPenaltyCreate, int)) *TSPenaltyCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TSPenaltyCreateBulk{err: fmt.Errorf("calling to TSPenaltyClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TSPenaltyCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TSPenaltyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TSPenalty.
func (c *TSPenaltyClient) Update() *TSPenaltyUpdate {
	mutation := newTSPenaltyMutation(c.config, OpUpdate)
	return &TSPenaltyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TSPenaltyClient) UpdateOne(tp *TSPenalty) *TSPenaltyUpdateOne {
	mutation := newTSPenaltyMutation(c.config, OpUpdateOne, withTSPenalty(tp))
	return &TSPenaltyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TSPenaltyClient) UpdateOneID(id int) *TSPenaltyUpdateOne {
	mutation := newTSPenaltyMutation(c.config, OpUpdateOne, withTSPenaltyID(id))
	return &TSPenaltyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TSPenalty.
func (c *TSPenaltyClient) Delete() *TSPenaltyDelete {
	mutation := newTSPenaltyMutation(c.config, OpDelete)
	return &TSPenaltyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TSPenaltyClient) DeleteOne(tp *TSPenalty) *TSPenaltyDeleteOne {
	return c.DeleteOneID(tp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TSPenaltyClient) DeleteOneID(id int) *TSPenaltyDeleteOne {
	builder := c.Delete().Where(tspenalty.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TSPenaltyDeleteOne{builder}
}

// Query returns a query builder for TSPenalty.
func (c *TSPenaltyClient) Query() *TSPenaltyQuery {
	return &TSPenaltyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTSPenalty},
		inters: c.Interceptors(),
	}
}

// Get returns a TSPenalty entity by its id.
func (c *TSPenaltyClient) Get(ctx context.Context, id int) (*TSPenalty, error) {
	return c.Query().Where(tspenalty.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TSPenaltyClient) GetX(ctx context.Context, id int) *TSPenalty {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTeam queries the team edge of a TSPenalty.
func (c *TSPenaltyClient) QueryTeam(tp *TSPenalty) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tspenalty.Table, tspenalty.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, tspenalty.TeamTable, tspenalty.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(tp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TSPenaltyClient) Hooks() []Hook {
	return c.hooks.TSPenalty
}

// Interceptors returns the client interceptors.
func (c *TSPenaltyClient) Interceptors() []Interceptor {
	return c.inters.TSPenalty
}

func (c *TSPenaltyClient) mutate(ctx context.Context, m *TSPenaltyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TSPenaltyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TSPenaltyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TSPenaltyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TSPenaltyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TSPenalty mutation op: %q", m.Op())
	}
}

// TeamClient is a client for the Team schema.
type TeamClient struct {
	config
}

// NewTeamClient returns a client for the Team from the given config.
func NewTeamClient(c config) *TeamClient {
	return &TeamClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `team.Hooks(f(g(h())))`.
func (c *TeamClient) Use(hooks ...Hook) {
	c.hooks.Team = append(c.hooks.Team, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `team.Intercept(f(g(h())))`.
func (c *TeamClient) Intercept(interceptors ...Interceptor) {
	c.inters.Team = append(c.inters.Team, interceptors...)
}

// Create returns a builder for creating a Team entity.
func (c *TeamClient) Create() *TeamCreate {
	mutation := newTeamMutation(c.config, OpCreate)
	return &TeamCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Team entities.
func (c *TeamClient) CreateBulk(builders ...*TeamCreate) *TeamCreateBulk {
	return &TeamCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TeamClient) MapCreateBulk(slice any, setFunc func(*TeamCreate, int)) *TeamCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TeamCreateBulk{err: fmt.Errorf("calling to TeamClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TeamCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TeamCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Team.
func (c *TeamClient) Update() *TeamUpdate {
	mutation := newTeamMutation(c.config, OpUpdate)
	return &TeamUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TeamClient) UpdateOne(t *Team) *TeamUpdateOne {
	mutation := newTeamMutation(c.config, OpUpdateOne, withTeam(t))
	return &TeamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TeamClient) UpdateOneID(id int) *TeamUpdateOne {
	mutation := newTeamMutation(c.config, OpUpdateOne, withTeamID(id))
	return &TeamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Team.
func (c *TeamClient) Delete() *TeamDelete {
	mutation := newTeamMutation(c.config, OpDelete)
	return &TeamDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TeamClient) DeleteOne(t *Team) *TeamDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TeamClient) DeleteOneID(id int) *TeamDeleteOne {
	builder := c.Delete().Where(team.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TeamDeleteOne{builder}
}

// Query returns a query builder for Team.
func (c *TeamClient) Query() *TeamQuery {
	return &TeamQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTeam},
		inters: c.Interceptors(),
	}
}

// Get returns a Team entity by its id.
func (c *TeamClient) Get(ctx context.Context, id int) (*Team, error) {
	return c.Query().Where(team.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TeamClient) GetX(ctx context.Context, id int) *Team {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySeason queries the season edge of a Team.
func (c *TeamClient) QuerySeason(t *Team) *SeasonQuery {
	query := (&SeasonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(season.Table, season.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, team.SeasonTable, team.SeasonColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClub queries the club edge of a Team.
func (c *TeamClient) QueryClub(t *Team) *ClubQuery {
	query := (&ClubClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(club.Table, club.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, team.ClubTable, team.ClubColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlayerStats queries the playerStats edge of a Team.
func (c *TeamClient) QueryPlayerStats(t *Team) *PlayerStatsQuery {
	query := (&PlayerStatsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(playerstats.Table, playerstats.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, team.PlayerStatsTable, team.PlayerStatsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStandings queries the standings edge of a Team.
func (c *TeamClient) QueryStandings(t *Team) *StandingsQuery {
	query := (&StandingsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(standings.Table, standings.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, team.StandingsTable, team.StandingsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHomeFixtures queries the homeFixtures edge of a Team.
func (c *TeamClient) QueryHomeFixtures(t *Team) *FixtureQuery {
	query := (&FixtureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(fixture.Table, fixture.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, team.HomeFixturesTable, team.HomeFixturesColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAwayFixtures queries the awayFixtures edge of a Team.
func (c *TeamClient) QueryAwayFixtures(t *Team) *FixtureQuery {
	query := (&FixtureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(fixture.Table, fixture.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, team.AwayFixturesTable, team.AwayFixturesColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeamFixtureEvents queries the teamFixtureEvents edge of a Team.
func (c *TeamClient) QueryTeamFixtureEvents(t *Team) *FixtureEventsQuery {
	query := (&FixtureEventsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(fixtureevents.Table, fixtureevents.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, team.TeamFixtureEventsTable, team.TeamFixtureEventsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFixtureLineups queries the fixtureLineups edge of a Team.
func (c *TeamClient) QueryFixtureLineups(t *Team) *FixtureLineupsQuery {
	query := (&FixtureLineupsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(fixturelineups.Table, fixturelineups.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, team.FixtureLineupsTable, team.FixtureLineupsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySquad queries the squad edge of a Team.
func (c *TeamClient) QuerySquad(t *Team) *SquadQuery {
	query := (&SquadClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(squad.Table, squad.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, team.SquadTable, team.SquadColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBiggestStats queries the biggest_stats edge of a Team.
func (c *TeamClient) QueryBiggestStats(t *Team) *TSBiggestQuery {
	query := (&TSBiggestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(tsbiggest.Table, tsbiggest.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, team.BiggestStatsTable, team.BiggestStatsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCardsStats queries the cards_stats edge of a Team.
func (c *TeamClient) QueryCardsStats(t *Team) *TSCardsQuery {
	query := (&TSCardsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(tscards.Table, tscards.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, team.CardsStatsTable, team.CardsStatsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCleanSheetStats queries the clean_sheet_stats edge of a Team.
func (c *TeamClient) QueryCleanSheetStats(t *Team) *TSCleanSheetQuery {
	query := (&TSCleanSheetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(tscleansheet.Table, tscleansheet.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, team.CleanSheetStatsTable, team.CleanSheetStatsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFailedToScoreStats queries the failed_to_score_stats edge of a Team.
func (c *TeamClient) QueryFailedToScoreStats(t *Team) *TSFailedToScoreQuery {
	query := (&TSFailedToScoreClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(tsfailedtoscore.Table, tsfailedtoscore.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, team.FailedToScoreStatsTable, team.FailedToScoreStatsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFixturesStats queries the fixtures_stats edge of a Team.
func (c *TeamClient) QueryFixturesStats(t *Team) *TSFixturesQuery {
	query := (&TSFixturesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(tsfixtures.Table, tsfixtures.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, team.FixturesStatsTable, team.FixturesStatsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGoalsStats queries the goals_stats edge of a Team.
func (c *TeamClient) QueryGoalsStats(t *Team) *TSGoalsQuery {
	query := (&TSGoalsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(tsgoals.Table, tsgoals.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, team.GoalsStatsTable, team.GoalsStatsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLineups queries the lineups edge of a Team.
func (c *TeamClient) QueryLineups(t *Team) *TSLineupsQuery {
	query := (&TSLineupsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(tslineups.Table, tslineups.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, team.LineupsTable, team.LineupsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPenaltyStats queries the penalty_stats edge of a Team.
func (c *TeamClient) QueryPenaltyStats(t *Team) *TSPenaltyQuery {
	query := (&TSPenaltyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(tspenalty.Table, tspenalty.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, team.PenaltyStatsTable, team.PenaltyStatsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TeamClient) Hooks() []Hook {
	return c.hooks.Team
}

// Interceptors returns the client interceptors.
func (c *TeamClient) Interceptors() []Interceptor {
	return c.inters.Team
}

func (c *TeamClient) mutate(ctx context.Context, m *TeamMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TeamCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TeamUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TeamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TeamDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Team mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Birth, Club, Coach, Country, Fixture, FixtureEvents, FixtureLineups, League,
		MatchPlayer, PSDefense, PSFairplay, PSGames, PSPenalty, PSShooting,
		PSSubstitutes, PSTechnical, Player, PlayerStats, Season, Squad, Standings,
		TSBiggest, TSCards, TSCleanSheet, TSFailedToScore, TSFixtures, TSGoals,
		TSLineups, TSPenalty, Team []ent.Hook
	}
	inters struct {
		Birth, Club, Coach, Country, Fixture, FixtureEvents, FixtureLineups, League,
		MatchPlayer, PSDefense, PSFairplay, PSGames, PSPenalty, PSShooting,
		PSSubstitutes, PSTechnical, Player, PlayerStats, Season, Squad, Standings,
		TSBiggest, TSCards, TSCleanSheet, TSFailedToScore, TSFixtures, TSGoals,
		TSLineups, TSPenalty, Team []ent.Interceptor
	}
)
