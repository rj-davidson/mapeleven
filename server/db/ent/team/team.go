// Code generated by ent, DO NOT EDIT.

package team

import (
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the team type in the database.
	Label = "team"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// EdgeSeason holds the string denoting the season edge name in mutations.
	EdgeSeason = "season"
	// EdgeClub holds the string denoting the club edge name in mutations.
	EdgeClub = "club"
	// EdgeStandings holds the string denoting the standings edge name in mutations.
	EdgeStandings = "standings"
	// EdgeHomeFixtures holds the string denoting the homefixtures edge name in mutations.
	EdgeHomeFixtures = "homeFixtures"
	// EdgeAwayFixtures holds the string denoting the awayfixtures edge name in mutations.
	EdgeAwayFixtures = "awayFixtures"
	// EdgePlayers holds the string denoting the players edge name in mutations.
	EdgePlayers = "players"
	// Table holds the table name of the team in the database.
	Table = "teams"
	// SeasonTable is the table that holds the season relation/edge.
	SeasonTable = "teams"
	// SeasonInverseTable is the table name for the Season entity.
	// It exists in this package in order to avoid circular dependency with the "season" package.
	SeasonInverseTable = "seasons"
	// SeasonColumn is the table column denoting the season relation/edge.
	SeasonColumn = "season_teams"
	// ClubTable is the table that holds the club relation/edge.
	ClubTable = "teams"
	// ClubInverseTable is the table name for the Club entity.
	// It exists in this package in order to avoid circular dependency with the "club" package.
	ClubInverseTable = "clubs"
	// ClubColumn is the table column denoting the club relation/edge.
	ClubColumn = "club_team"
	// StandingsTable is the table that holds the standings relation/edge.
	StandingsTable = "standings"
	// StandingsInverseTable is the table name for the Standings entity.
	// It exists in this package in order to avoid circular dependency with the "standings" package.
	StandingsInverseTable = "standings"
	// StandingsColumn is the table column denoting the standings relation/edge.
	StandingsColumn = "team_standings"
	// HomeFixturesTable is the table that holds the homeFixtures relation/edge.
	HomeFixturesTable = "fixtures"
	// HomeFixturesInverseTable is the table name for the Fixture entity.
	// It exists in this package in order to avoid circular dependency with the "fixture" package.
	HomeFixturesInverseTable = "fixtures"
	// HomeFixturesColumn is the table column denoting the homeFixtures relation/edge.
	HomeFixturesColumn = "team_home_fixtures"
	// AwayFixturesTable is the table that holds the awayFixtures relation/edge.
	AwayFixturesTable = "fixtures"
	// AwayFixturesInverseTable is the table name for the Fixture entity.
	// It exists in this package in order to avoid circular dependency with the "fixture" package.
	AwayFixturesInverseTable = "fixtures"
	// AwayFixturesColumn is the table column denoting the awayFixtures relation/edge.
	AwayFixturesColumn = "team_away_fixtures"
	// PlayersTable is the table that holds the players relation/edge. The primary key declared below.
	PlayersTable = "team_players"
	// PlayersInverseTable is the table name for the Player entity.
	// It exists in this package in order to avoid circular dependency with the "player" package.
	PlayersInverseTable = "players"
)

// Columns holds all SQL columns for team fields.
var Columns = []string{
	FieldID,
}

// ForeignKeys holds the SQL foreign-keys that are owned by the "teams"
// table and are not defined as standalone fields in the schema.
var ForeignKeys = []string{
	"club_team",
	"season_teams",
}

var (
	// PlayersPrimaryKey and PlayersColumn2 are the table columns denoting the
	// primary key for the players relation (M2M).
	PlayersPrimaryKey = []string{"team_id", "player_id"}
)

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	for i := range ForeignKeys {
		if column == ForeignKeys[i] {
			return true
		}
	}
	return false
}

// Order defines the ordering method for the Team queries.
type Order func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) Order {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// BySeasonField orders the results by season field.
func BySeasonField(field string, opts ...sql.OrderTermOption) Order {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newSeasonStep(), sql.OrderByField(field, opts...))
	}
}

// ByClubField orders the results by club field.
func ByClubField(field string, opts ...sql.OrderTermOption) Order {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newClubStep(), sql.OrderByField(field, opts...))
	}
}

// ByStandingsCount orders the results by standings count.
func ByStandingsCount(opts ...sql.OrderTermOption) Order {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newStandingsStep(), opts...)
	}
}

// ByStandings orders the results by standings terms.
func ByStandings(term sql.OrderTerm, terms ...sql.OrderTerm) Order {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newStandingsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByHomeFixturesCount orders the results by homeFixtures count.
func ByHomeFixturesCount(opts ...sql.OrderTermOption) Order {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newHomeFixturesStep(), opts...)
	}
}

// ByHomeFixtures orders the results by homeFixtures terms.
func ByHomeFixtures(term sql.OrderTerm, terms ...sql.OrderTerm) Order {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newHomeFixturesStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByAwayFixturesCount orders the results by awayFixtures count.
func ByAwayFixturesCount(opts ...sql.OrderTermOption) Order {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newAwayFixturesStep(), opts...)
	}
}

// ByAwayFixtures orders the results by awayFixtures terms.
func ByAwayFixtures(term sql.OrderTerm, terms ...sql.OrderTerm) Order {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newAwayFixturesStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByPlayersCount orders the results by players count.
func ByPlayersCount(opts ...sql.OrderTermOption) Order {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newPlayersStep(), opts...)
	}
}

// ByPlayers orders the results by players terms.
func ByPlayers(term sql.OrderTerm, terms ...sql.OrderTerm) Order {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newPlayersStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}
func newSeasonStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(SeasonInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, SeasonTable, SeasonColumn),
	)
}
func newClubStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ClubInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, ClubTable, ClubColumn),
	)
}
func newStandingsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(StandingsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, StandingsTable, StandingsColumn),
	)
}
func newHomeFixturesStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(HomeFixturesInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, HomeFixturesTable, HomeFixturesColumn),
	)
}
func newAwayFixturesStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(AwayFixturesInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, AwayFixturesTable, AwayFixturesColumn),
	)
}
func newPlayersStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(PlayersInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, false, PlayersTable, PlayersPrimaryKey...),
	)
}
