// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"mapeleven/db/ent/birth"
	"mapeleven/db/ent/country"
	"mapeleven/db/ent/fixture"
	"mapeleven/db/ent/league"
	"mapeleven/db/ent/player"
	"mapeleven/db/ent/predicate"
	"mapeleven/db/ent/season"
	"mapeleven/db/ent/standings"
	"mapeleven/db/ent/team"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBirth     = "Birth"
	TypeCountry   = "Country"
	TypeFixture   = "Fixture"
	TypeLeague    = "League"
	TypePlayer    = "Player"
	TypeSeason    = "Season"
	TypeStandings = "Standings"
	TypeTeam      = "Team"
)

// BirthMutation represents an operation that mutates the Birth nodes in the graph.
type BirthMutation struct {
	config
	op            Op
	typ           string
	id            *int
	date          *time.Time
	place         *string
	country       *string
	clearedFields map[string]struct{}
	player        map[int]struct{}
	removedplayer map[int]struct{}
	clearedplayer bool
	done          bool
	oldValue      func(context.Context) (*Birth, error)
	predicates    []predicate.Birth
}

var _ ent.Mutation = (*BirthMutation)(nil)

// birthOption allows management of the mutation configuration using functional options.
type birthOption func(*BirthMutation)

// newBirthMutation creates new mutation for the Birth entity.
func newBirthMutation(c config, op Op, opts ...birthOption) *BirthMutation {
	m := &BirthMutation{
		config:        c,
		op:            op,
		typ:           TypeBirth,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBirthID sets the ID field of the mutation.
func withBirthID(id int) birthOption {
	return func(m *BirthMutation) {
		var (
			err   error
			once  sync.Once
			value *Birth
		)
		m.oldValue = func(ctx context.Context) (*Birth, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Birth.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBirth sets the old Birth of the mutation.
func withBirth(node *Birth) birthOption {
	return func(m *BirthMutation) {
		m.oldValue = func(context.Context) (*Birth, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BirthMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BirthMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BirthMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BirthMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Birth.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDate sets the "date" field.
func (m *BirthMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *BirthMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Birth entity.
// If the Birth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BirthMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *BirthMutation) ResetDate() {
	m.date = nil
}

// SetPlace sets the "place" field.
func (m *BirthMutation) SetPlace(s string) {
	m.place = &s
}

// Place returns the value of the "place" field in the mutation.
func (m *BirthMutation) Place() (r string, exists bool) {
	v := m.place
	if v == nil {
		return
	}
	return *v, true
}

// OldPlace returns the old "place" field's value of the Birth entity.
// If the Birth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BirthMutation) OldPlace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlace: %w", err)
	}
	return oldValue.Place, nil
}

// ResetPlace resets all changes to the "place" field.
func (m *BirthMutation) ResetPlace() {
	m.place = nil
}

// SetCountry sets the "country" field.
func (m *BirthMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *BirthMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Birth entity.
// If the Birth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BirthMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *BirthMutation) ResetCountry() {
	m.country = nil
}

// AddPlayerIDs adds the "player" edge to the Player entity by ids.
func (m *BirthMutation) AddPlayerIDs(ids ...int) {
	if m.player == nil {
		m.player = make(map[int]struct{})
	}
	for i := range ids {
		m.player[ids[i]] = struct{}{}
	}
}

// ClearPlayer clears the "player" edge to the Player entity.
func (m *BirthMutation) ClearPlayer() {
	m.clearedplayer = true
}

// PlayerCleared reports if the "player" edge to the Player entity was cleared.
func (m *BirthMutation) PlayerCleared() bool {
	return m.clearedplayer
}

// RemovePlayerIDs removes the "player" edge to the Player entity by IDs.
func (m *BirthMutation) RemovePlayerIDs(ids ...int) {
	if m.removedplayer == nil {
		m.removedplayer = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.player, ids[i])
		m.removedplayer[ids[i]] = struct{}{}
	}
}

// RemovedPlayer returns the removed IDs of the "player" edge to the Player entity.
func (m *BirthMutation) RemovedPlayerIDs() (ids []int) {
	for id := range m.removedplayer {
		ids = append(ids, id)
	}
	return
}

// PlayerIDs returns the "player" edge IDs in the mutation.
func (m *BirthMutation) PlayerIDs() (ids []int) {
	for id := range m.player {
		ids = append(ids, id)
	}
	return
}

// ResetPlayer resets all changes to the "player" edge.
func (m *BirthMutation) ResetPlayer() {
	m.player = nil
	m.clearedplayer = false
	m.removedplayer = nil
}

// Where appends a list predicates to the BirthMutation builder.
func (m *BirthMutation) Where(ps ...predicate.Birth) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BirthMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BirthMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Birth, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BirthMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BirthMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Birth).
func (m *BirthMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BirthMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.date != nil {
		fields = append(fields, birth.FieldDate)
	}
	if m.place != nil {
		fields = append(fields, birth.FieldPlace)
	}
	if m.country != nil {
		fields = append(fields, birth.FieldCountry)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BirthMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case birth.FieldDate:
		return m.Date()
	case birth.FieldPlace:
		return m.Place()
	case birth.FieldCountry:
		return m.Country()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BirthMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case birth.FieldDate:
		return m.OldDate(ctx)
	case birth.FieldPlace:
		return m.OldPlace(ctx)
	case birth.FieldCountry:
		return m.OldCountry(ctx)
	}
	return nil, fmt.Errorf("unknown Birth field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BirthMutation) SetField(name string, value ent.Value) error {
	switch name {
	case birth.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case birth.FieldPlace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlace(v)
		return nil
	case birth.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	}
	return fmt.Errorf("unknown Birth field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BirthMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BirthMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BirthMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Birth numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BirthMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BirthMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BirthMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Birth nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BirthMutation) ResetField(name string) error {
	switch name {
	case birth.FieldDate:
		m.ResetDate()
		return nil
	case birth.FieldPlace:
		m.ResetPlace()
		return nil
	case birth.FieldCountry:
		m.ResetCountry()
		return nil
	}
	return fmt.Errorf("unknown Birth field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BirthMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.player != nil {
		edges = append(edges, birth.EdgePlayer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BirthMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case birth.EdgePlayer:
		ids := make([]ent.Value, 0, len(m.player))
		for id := range m.player {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BirthMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedplayer != nil {
		edges = append(edges, birth.EdgePlayer)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BirthMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case birth.EdgePlayer:
		ids := make([]ent.Value, 0, len(m.removedplayer))
		for id := range m.removedplayer {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BirthMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedplayer {
		edges = append(edges, birth.EdgePlayer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BirthMutation) EdgeCleared(name string) bool {
	switch name {
	case birth.EdgePlayer:
		return m.clearedplayer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BirthMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Birth unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BirthMutation) ResetEdge(name string) error {
	switch name {
	case birth.EdgePlayer:
		m.ResetPlayer()
		return nil
	}
	return fmt.Errorf("unknown Birth edge %s", name)
}

// CountryMutation represents an operation that mutates the Country nodes in the graph.
type CountryMutation struct {
	config
	op             Op
	typ            string
	id             *int
	code           *string
	name           *string
	flag           *string
	clearedFields  map[string]struct{}
	players        map[int]struct{}
	removedplayers map[int]struct{}
	clearedplayers bool
	leagues        map[int]struct{}
	removedleagues map[int]struct{}
	clearedleagues bool
	teams          map[int]struct{}
	removedteams   map[int]struct{}
	clearedteams   bool
	done           bool
	oldValue       func(context.Context) (*Country, error)
	predicates     []predicate.Country
}

var _ ent.Mutation = (*CountryMutation)(nil)

// countryOption allows management of the mutation configuration using functional options.
type countryOption func(*CountryMutation)

// newCountryMutation creates new mutation for the Country entity.
func newCountryMutation(c config, op Op, opts ...countryOption) *CountryMutation {
	m := &CountryMutation{
		config:        c,
		op:            op,
		typ:           TypeCountry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCountryID sets the ID field of the mutation.
func withCountryID(id int) countryOption {
	return func(m *CountryMutation) {
		var (
			err   error
			once  sync.Once
			value *Country
		)
		m.oldValue = func(ctx context.Context) (*Country, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Country.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCountry sets the old Country of the mutation.
func withCountry(node *Country) countryOption {
	return func(m *CountryMutation) {
		m.oldValue = func(context.Context) (*Country, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CountryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CountryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CountryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CountryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Country.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *CountryMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *CountryMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *CountryMutation) ResetCode() {
	m.code = nil
}

// SetName sets the "name" field.
func (m *CountryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CountryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CountryMutation) ResetName() {
	m.name = nil
}

// SetFlag sets the "flag" field.
func (m *CountryMutation) SetFlag(s string) {
	m.flag = &s
}

// Flag returns the value of the "flag" field in the mutation.
func (m *CountryMutation) Flag() (r string, exists bool) {
	v := m.flag
	if v == nil {
		return
	}
	return *v, true
}

// OldFlag returns the old "flag" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldFlag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlag: %w", err)
	}
	return oldValue.Flag, nil
}

// ResetFlag resets all changes to the "flag" field.
func (m *CountryMutation) ResetFlag() {
	m.flag = nil
}

// AddPlayerIDs adds the "players" edge to the Player entity by ids.
func (m *CountryMutation) AddPlayerIDs(ids ...int) {
	if m.players == nil {
		m.players = make(map[int]struct{})
	}
	for i := range ids {
		m.players[ids[i]] = struct{}{}
	}
}

// ClearPlayers clears the "players" edge to the Player entity.
func (m *CountryMutation) ClearPlayers() {
	m.clearedplayers = true
}

// PlayersCleared reports if the "players" edge to the Player entity was cleared.
func (m *CountryMutation) PlayersCleared() bool {
	return m.clearedplayers
}

// RemovePlayerIDs removes the "players" edge to the Player entity by IDs.
func (m *CountryMutation) RemovePlayerIDs(ids ...int) {
	if m.removedplayers == nil {
		m.removedplayers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.players, ids[i])
		m.removedplayers[ids[i]] = struct{}{}
	}
}

// RemovedPlayers returns the removed IDs of the "players" edge to the Player entity.
func (m *CountryMutation) RemovedPlayersIDs() (ids []int) {
	for id := range m.removedplayers {
		ids = append(ids, id)
	}
	return
}

// PlayersIDs returns the "players" edge IDs in the mutation.
func (m *CountryMutation) PlayersIDs() (ids []int) {
	for id := range m.players {
		ids = append(ids, id)
	}
	return
}

// ResetPlayers resets all changes to the "players" edge.
func (m *CountryMutation) ResetPlayers() {
	m.players = nil
	m.clearedplayers = false
	m.removedplayers = nil
}

// AddLeagueIDs adds the "leagues" edge to the League entity by ids.
func (m *CountryMutation) AddLeagueIDs(ids ...int) {
	if m.leagues == nil {
		m.leagues = make(map[int]struct{})
	}
	for i := range ids {
		m.leagues[ids[i]] = struct{}{}
	}
}

// ClearLeagues clears the "leagues" edge to the League entity.
func (m *CountryMutation) ClearLeagues() {
	m.clearedleagues = true
}

// LeaguesCleared reports if the "leagues" edge to the League entity was cleared.
func (m *CountryMutation) LeaguesCleared() bool {
	return m.clearedleagues
}

// RemoveLeagueIDs removes the "leagues" edge to the League entity by IDs.
func (m *CountryMutation) RemoveLeagueIDs(ids ...int) {
	if m.removedleagues == nil {
		m.removedleagues = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.leagues, ids[i])
		m.removedleagues[ids[i]] = struct{}{}
	}
}

// RemovedLeagues returns the removed IDs of the "leagues" edge to the League entity.
func (m *CountryMutation) RemovedLeaguesIDs() (ids []int) {
	for id := range m.removedleagues {
		ids = append(ids, id)
	}
	return
}

// LeaguesIDs returns the "leagues" edge IDs in the mutation.
func (m *CountryMutation) LeaguesIDs() (ids []int) {
	for id := range m.leagues {
		ids = append(ids, id)
	}
	return
}

// ResetLeagues resets all changes to the "leagues" edge.
func (m *CountryMutation) ResetLeagues() {
	m.leagues = nil
	m.clearedleagues = false
	m.removedleagues = nil
}

// AddTeamIDs adds the "teams" edge to the Team entity by ids.
func (m *CountryMutation) AddTeamIDs(ids ...int) {
	if m.teams == nil {
		m.teams = make(map[int]struct{})
	}
	for i := range ids {
		m.teams[ids[i]] = struct{}{}
	}
}

// ClearTeams clears the "teams" edge to the Team entity.
func (m *CountryMutation) ClearTeams() {
	m.clearedteams = true
}

// TeamsCleared reports if the "teams" edge to the Team entity was cleared.
func (m *CountryMutation) TeamsCleared() bool {
	return m.clearedteams
}

// RemoveTeamIDs removes the "teams" edge to the Team entity by IDs.
func (m *CountryMutation) RemoveTeamIDs(ids ...int) {
	if m.removedteams == nil {
		m.removedteams = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.teams, ids[i])
		m.removedteams[ids[i]] = struct{}{}
	}
}

// RemovedTeams returns the removed IDs of the "teams" edge to the Team entity.
func (m *CountryMutation) RemovedTeamsIDs() (ids []int) {
	for id := range m.removedteams {
		ids = append(ids, id)
	}
	return
}

// TeamsIDs returns the "teams" edge IDs in the mutation.
func (m *CountryMutation) TeamsIDs() (ids []int) {
	for id := range m.teams {
		ids = append(ids, id)
	}
	return
}

// ResetTeams resets all changes to the "teams" edge.
func (m *CountryMutation) ResetTeams() {
	m.teams = nil
	m.clearedteams = false
	m.removedteams = nil
}

// Where appends a list predicates to the CountryMutation builder.
func (m *CountryMutation) Where(ps ...predicate.Country) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CountryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CountryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Country, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CountryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CountryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Country).
func (m *CountryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CountryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.code != nil {
		fields = append(fields, country.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, country.FieldName)
	}
	if m.flag != nil {
		fields = append(fields, country.FieldFlag)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CountryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case country.FieldCode:
		return m.Code()
	case country.FieldName:
		return m.Name()
	case country.FieldFlag:
		return m.Flag()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CountryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case country.FieldCode:
		return m.OldCode(ctx)
	case country.FieldName:
		return m.OldName(ctx)
	case country.FieldFlag:
		return m.OldFlag(ctx)
	}
	return nil, fmt.Errorf("unknown Country field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case country.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case country.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case country.FieldFlag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlag(v)
		return nil
	}
	return fmt.Errorf("unknown Country field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CountryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CountryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Country numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CountryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CountryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CountryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Country nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CountryMutation) ResetField(name string) error {
	switch name {
	case country.FieldCode:
		m.ResetCode()
		return nil
	case country.FieldName:
		m.ResetName()
		return nil
	case country.FieldFlag:
		m.ResetFlag()
		return nil
	}
	return fmt.Errorf("unknown Country field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CountryMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.players != nil {
		edges = append(edges, country.EdgePlayers)
	}
	if m.leagues != nil {
		edges = append(edges, country.EdgeLeagues)
	}
	if m.teams != nil {
		edges = append(edges, country.EdgeTeams)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CountryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case country.EdgePlayers:
		ids := make([]ent.Value, 0, len(m.players))
		for id := range m.players {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeLeagues:
		ids := make([]ent.Value, 0, len(m.leagues))
		for id := range m.leagues {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.teams))
		for id := range m.teams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CountryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedplayers != nil {
		edges = append(edges, country.EdgePlayers)
	}
	if m.removedleagues != nil {
		edges = append(edges, country.EdgeLeagues)
	}
	if m.removedteams != nil {
		edges = append(edges, country.EdgeTeams)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CountryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case country.EdgePlayers:
		ids := make([]ent.Value, 0, len(m.removedplayers))
		for id := range m.removedplayers {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeLeagues:
		ids := make([]ent.Value, 0, len(m.removedleagues))
		for id := range m.removedleagues {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.removedteams))
		for id := range m.removedteams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CountryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedplayers {
		edges = append(edges, country.EdgePlayers)
	}
	if m.clearedleagues {
		edges = append(edges, country.EdgeLeagues)
	}
	if m.clearedteams {
		edges = append(edges, country.EdgeTeams)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CountryMutation) EdgeCleared(name string) bool {
	switch name {
	case country.EdgePlayers:
		return m.clearedplayers
	case country.EdgeLeagues:
		return m.clearedleagues
	case country.EdgeTeams:
		return m.clearedteams
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CountryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Country unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CountryMutation) ResetEdge(name string) error {
	switch name {
	case country.EdgePlayers:
		m.ResetPlayers()
		return nil
	case country.EdgeLeagues:
		m.ResetLeagues()
		return nil
	case country.EdgeTeams:
		m.ResetTeams()
		return nil
	}
	return fmt.Errorf("unknown Country edge %s", name)
}

// FixtureMutation represents an operation that mutates the Fixture nodes in the graph.
type FixtureMutation struct {
	config
	op               Op
	typ              string
	id               *int
	slug             *string
	apiFootballId    *int
	addapiFootballId *int
	referee          *string
	timezone         *string
	date             *time.Time
	elapsed          *int
	addelapsed       *int
	round            *int
	addround         *int
	status           *string
	homeTeamScore    *int
	addhomeTeamScore *int
	awayTeamScore    *int
	addawayTeamScore *int
	clearedFields    map[string]struct{}
	homeTeam         *int
	clearedhomeTeam  bool
	awayTeam         *int
	clearedawayTeam  bool
	season           *int
	clearedseason    bool
	done             bool
	oldValue         func(context.Context) (*Fixture, error)
	predicates       []predicate.Fixture
}

var _ ent.Mutation = (*FixtureMutation)(nil)

// fixtureOption allows management of the mutation configuration using functional options.
type fixtureOption func(*FixtureMutation)

// newFixtureMutation creates new mutation for the Fixture entity.
func newFixtureMutation(c config, op Op, opts ...fixtureOption) *FixtureMutation {
	m := &FixtureMutation{
		config:        c,
		op:            op,
		typ:           TypeFixture,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFixtureID sets the ID field of the mutation.
func withFixtureID(id int) fixtureOption {
	return func(m *FixtureMutation) {
		var (
			err   error
			once  sync.Once
			value *Fixture
		)
		m.oldValue = func(ctx context.Context) (*Fixture, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Fixture.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFixture sets the old Fixture of the mutation.
func withFixture(node *Fixture) fixtureOption {
	return func(m *FixtureMutation) {
		m.oldValue = func(context.Context) (*Fixture, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FixtureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FixtureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FixtureMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FixtureMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Fixture.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSlug sets the "slug" field.
func (m *FixtureMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *FixtureMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Fixture entity.
// If the Fixture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixtureMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *FixtureMutation) ResetSlug() {
	m.slug = nil
}

// SetApiFootballId sets the "apiFootballId" field.
func (m *FixtureMutation) SetApiFootballId(i int) {
	m.apiFootballId = &i
	m.addapiFootballId = nil
}

// ApiFootballId returns the value of the "apiFootballId" field in the mutation.
func (m *FixtureMutation) ApiFootballId() (r int, exists bool) {
	v := m.apiFootballId
	if v == nil {
		return
	}
	return *v, true
}

// OldApiFootballId returns the old "apiFootballId" field's value of the Fixture entity.
// If the Fixture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixtureMutation) OldApiFootballId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApiFootballId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApiFootballId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApiFootballId: %w", err)
	}
	return oldValue.ApiFootballId, nil
}

// AddApiFootballId adds i to the "apiFootballId" field.
func (m *FixtureMutation) AddApiFootballId(i int) {
	if m.addapiFootballId != nil {
		*m.addapiFootballId += i
	} else {
		m.addapiFootballId = &i
	}
}

// AddedApiFootballId returns the value that was added to the "apiFootballId" field in this mutation.
func (m *FixtureMutation) AddedApiFootballId() (r int, exists bool) {
	v := m.addapiFootballId
	if v == nil {
		return
	}
	return *v, true
}

// ResetApiFootballId resets all changes to the "apiFootballId" field.
func (m *FixtureMutation) ResetApiFootballId() {
	m.apiFootballId = nil
	m.addapiFootballId = nil
}

// SetReferee sets the "referee" field.
func (m *FixtureMutation) SetReferee(s string) {
	m.referee = &s
}

// Referee returns the value of the "referee" field in the mutation.
func (m *FixtureMutation) Referee() (r string, exists bool) {
	v := m.referee
	if v == nil {
		return
	}
	return *v, true
}

// OldReferee returns the old "referee" field's value of the Fixture entity.
// If the Fixture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixtureMutation) OldReferee(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferee: %w", err)
	}
	return oldValue.Referee, nil
}

// ClearReferee clears the value of the "referee" field.
func (m *FixtureMutation) ClearReferee() {
	m.referee = nil
	m.clearedFields[fixture.FieldReferee] = struct{}{}
}

// RefereeCleared returns if the "referee" field was cleared in this mutation.
func (m *FixtureMutation) RefereeCleared() bool {
	_, ok := m.clearedFields[fixture.FieldReferee]
	return ok
}

// ResetReferee resets all changes to the "referee" field.
func (m *FixtureMutation) ResetReferee() {
	m.referee = nil
	delete(m.clearedFields, fixture.FieldReferee)
}

// SetTimezone sets the "timezone" field.
func (m *FixtureMutation) SetTimezone(s string) {
	m.timezone = &s
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *FixtureMutation) Timezone() (r string, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the Fixture entity.
// If the Fixture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixtureMutation) OldTimezone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// ClearTimezone clears the value of the "timezone" field.
func (m *FixtureMutation) ClearTimezone() {
	m.timezone = nil
	m.clearedFields[fixture.FieldTimezone] = struct{}{}
}

// TimezoneCleared returns if the "timezone" field was cleared in this mutation.
func (m *FixtureMutation) TimezoneCleared() bool {
	_, ok := m.clearedFields[fixture.FieldTimezone]
	return ok
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *FixtureMutation) ResetTimezone() {
	m.timezone = nil
	delete(m.clearedFields, fixture.FieldTimezone)
}

// SetDate sets the "date" field.
func (m *FixtureMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *FixtureMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Fixture entity.
// If the Fixture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixtureMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *FixtureMutation) ResetDate() {
	m.date = nil
}

// SetElapsed sets the "elapsed" field.
func (m *FixtureMutation) SetElapsed(i int) {
	m.elapsed = &i
	m.addelapsed = nil
}

// Elapsed returns the value of the "elapsed" field in the mutation.
func (m *FixtureMutation) Elapsed() (r int, exists bool) {
	v := m.elapsed
	if v == nil {
		return
	}
	return *v, true
}

// OldElapsed returns the old "elapsed" field's value of the Fixture entity.
// If the Fixture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixtureMutation) OldElapsed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElapsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElapsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElapsed: %w", err)
	}
	return oldValue.Elapsed, nil
}

// AddElapsed adds i to the "elapsed" field.
func (m *FixtureMutation) AddElapsed(i int) {
	if m.addelapsed != nil {
		*m.addelapsed += i
	} else {
		m.addelapsed = &i
	}
}

// AddedElapsed returns the value that was added to the "elapsed" field in this mutation.
func (m *FixtureMutation) AddedElapsed() (r int, exists bool) {
	v := m.addelapsed
	if v == nil {
		return
	}
	return *v, true
}

// ClearElapsed clears the value of the "elapsed" field.
func (m *FixtureMutation) ClearElapsed() {
	m.elapsed = nil
	m.addelapsed = nil
	m.clearedFields[fixture.FieldElapsed] = struct{}{}
}

// ElapsedCleared returns if the "elapsed" field was cleared in this mutation.
func (m *FixtureMutation) ElapsedCleared() bool {
	_, ok := m.clearedFields[fixture.FieldElapsed]
	return ok
}

// ResetElapsed resets all changes to the "elapsed" field.
func (m *FixtureMutation) ResetElapsed() {
	m.elapsed = nil
	m.addelapsed = nil
	delete(m.clearedFields, fixture.FieldElapsed)
}

// SetRound sets the "round" field.
func (m *FixtureMutation) SetRound(i int) {
	m.round = &i
	m.addround = nil
}

// Round returns the value of the "round" field in the mutation.
func (m *FixtureMutation) Round() (r int, exists bool) {
	v := m.round
	if v == nil {
		return
	}
	return *v, true
}

// OldRound returns the old "round" field's value of the Fixture entity.
// If the Fixture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixtureMutation) OldRound(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRound is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRound requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRound: %w", err)
	}
	return oldValue.Round, nil
}

// AddRound adds i to the "round" field.
func (m *FixtureMutation) AddRound(i int) {
	if m.addround != nil {
		*m.addround += i
	} else {
		m.addround = &i
	}
}

// AddedRound returns the value that was added to the "round" field in this mutation.
func (m *FixtureMutation) AddedRound() (r int, exists bool) {
	v := m.addround
	if v == nil {
		return
	}
	return *v, true
}

// ClearRound clears the value of the "round" field.
func (m *FixtureMutation) ClearRound() {
	m.round = nil
	m.addround = nil
	m.clearedFields[fixture.FieldRound] = struct{}{}
}

// RoundCleared returns if the "round" field was cleared in this mutation.
func (m *FixtureMutation) RoundCleared() bool {
	_, ok := m.clearedFields[fixture.FieldRound]
	return ok
}

// ResetRound resets all changes to the "round" field.
func (m *FixtureMutation) ResetRound() {
	m.round = nil
	m.addround = nil
	delete(m.clearedFields, fixture.FieldRound)
}

// SetStatus sets the "status" field.
func (m *FixtureMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *FixtureMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Fixture entity.
// If the Fixture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixtureMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *FixtureMutation) ResetStatus() {
	m.status = nil
}

// SetHomeTeamScore sets the "homeTeamScore" field.
func (m *FixtureMutation) SetHomeTeamScore(i int) {
	m.homeTeamScore = &i
	m.addhomeTeamScore = nil
}

// HomeTeamScore returns the value of the "homeTeamScore" field in the mutation.
func (m *FixtureMutation) HomeTeamScore() (r int, exists bool) {
	v := m.homeTeamScore
	if v == nil {
		return
	}
	return *v, true
}

// OldHomeTeamScore returns the old "homeTeamScore" field's value of the Fixture entity.
// If the Fixture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixtureMutation) OldHomeTeamScore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomeTeamScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomeTeamScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomeTeamScore: %w", err)
	}
	return oldValue.HomeTeamScore, nil
}

// AddHomeTeamScore adds i to the "homeTeamScore" field.
func (m *FixtureMutation) AddHomeTeamScore(i int) {
	if m.addhomeTeamScore != nil {
		*m.addhomeTeamScore += i
	} else {
		m.addhomeTeamScore = &i
	}
}

// AddedHomeTeamScore returns the value that was added to the "homeTeamScore" field in this mutation.
func (m *FixtureMutation) AddedHomeTeamScore() (r int, exists bool) {
	v := m.addhomeTeamScore
	if v == nil {
		return
	}
	return *v, true
}

// ClearHomeTeamScore clears the value of the "homeTeamScore" field.
func (m *FixtureMutation) ClearHomeTeamScore() {
	m.homeTeamScore = nil
	m.addhomeTeamScore = nil
	m.clearedFields[fixture.FieldHomeTeamScore] = struct{}{}
}

// HomeTeamScoreCleared returns if the "homeTeamScore" field was cleared in this mutation.
func (m *FixtureMutation) HomeTeamScoreCleared() bool {
	_, ok := m.clearedFields[fixture.FieldHomeTeamScore]
	return ok
}

// ResetHomeTeamScore resets all changes to the "homeTeamScore" field.
func (m *FixtureMutation) ResetHomeTeamScore() {
	m.homeTeamScore = nil
	m.addhomeTeamScore = nil
	delete(m.clearedFields, fixture.FieldHomeTeamScore)
}

// SetAwayTeamScore sets the "awayTeamScore" field.
func (m *FixtureMutation) SetAwayTeamScore(i int) {
	m.awayTeamScore = &i
	m.addawayTeamScore = nil
}

// AwayTeamScore returns the value of the "awayTeamScore" field in the mutation.
func (m *FixtureMutation) AwayTeamScore() (r int, exists bool) {
	v := m.awayTeamScore
	if v == nil {
		return
	}
	return *v, true
}

// OldAwayTeamScore returns the old "awayTeamScore" field's value of the Fixture entity.
// If the Fixture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixtureMutation) OldAwayTeamScore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAwayTeamScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAwayTeamScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAwayTeamScore: %w", err)
	}
	return oldValue.AwayTeamScore, nil
}

// AddAwayTeamScore adds i to the "awayTeamScore" field.
func (m *FixtureMutation) AddAwayTeamScore(i int) {
	if m.addawayTeamScore != nil {
		*m.addawayTeamScore += i
	} else {
		m.addawayTeamScore = &i
	}
}

// AddedAwayTeamScore returns the value that was added to the "awayTeamScore" field in this mutation.
func (m *FixtureMutation) AddedAwayTeamScore() (r int, exists bool) {
	v := m.addawayTeamScore
	if v == nil {
		return
	}
	return *v, true
}

// ClearAwayTeamScore clears the value of the "awayTeamScore" field.
func (m *FixtureMutation) ClearAwayTeamScore() {
	m.awayTeamScore = nil
	m.addawayTeamScore = nil
	m.clearedFields[fixture.FieldAwayTeamScore] = struct{}{}
}

// AwayTeamScoreCleared returns if the "awayTeamScore" field was cleared in this mutation.
func (m *FixtureMutation) AwayTeamScoreCleared() bool {
	_, ok := m.clearedFields[fixture.FieldAwayTeamScore]
	return ok
}

// ResetAwayTeamScore resets all changes to the "awayTeamScore" field.
func (m *FixtureMutation) ResetAwayTeamScore() {
	m.awayTeamScore = nil
	m.addawayTeamScore = nil
	delete(m.clearedFields, fixture.FieldAwayTeamScore)
}

// SetHomeTeamID sets the "homeTeam" edge to the Team entity by id.
func (m *FixtureMutation) SetHomeTeamID(id int) {
	m.homeTeam = &id
}

// ClearHomeTeam clears the "homeTeam" edge to the Team entity.
func (m *FixtureMutation) ClearHomeTeam() {
	m.clearedhomeTeam = true
}

// HomeTeamCleared reports if the "homeTeam" edge to the Team entity was cleared.
func (m *FixtureMutation) HomeTeamCleared() bool {
	return m.clearedhomeTeam
}

// HomeTeamID returns the "homeTeam" edge ID in the mutation.
func (m *FixtureMutation) HomeTeamID() (id int, exists bool) {
	if m.homeTeam != nil {
		return *m.homeTeam, true
	}
	return
}

// HomeTeamIDs returns the "homeTeam" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HomeTeamID instead. It exists only for internal usage by the builders.
func (m *FixtureMutation) HomeTeamIDs() (ids []int) {
	if id := m.homeTeam; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHomeTeam resets all changes to the "homeTeam" edge.
func (m *FixtureMutation) ResetHomeTeam() {
	m.homeTeam = nil
	m.clearedhomeTeam = false
}

// SetAwayTeamID sets the "awayTeam" edge to the Team entity by id.
func (m *FixtureMutation) SetAwayTeamID(id int) {
	m.awayTeam = &id
}

// ClearAwayTeam clears the "awayTeam" edge to the Team entity.
func (m *FixtureMutation) ClearAwayTeam() {
	m.clearedawayTeam = true
}

// AwayTeamCleared reports if the "awayTeam" edge to the Team entity was cleared.
func (m *FixtureMutation) AwayTeamCleared() bool {
	return m.clearedawayTeam
}

// AwayTeamID returns the "awayTeam" edge ID in the mutation.
func (m *FixtureMutation) AwayTeamID() (id int, exists bool) {
	if m.awayTeam != nil {
		return *m.awayTeam, true
	}
	return
}

// AwayTeamIDs returns the "awayTeam" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AwayTeamID instead. It exists only for internal usage by the builders.
func (m *FixtureMutation) AwayTeamIDs() (ids []int) {
	if id := m.awayTeam; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAwayTeam resets all changes to the "awayTeam" edge.
func (m *FixtureMutation) ResetAwayTeam() {
	m.awayTeam = nil
	m.clearedawayTeam = false
}

// SetSeasonID sets the "season" edge to the Season entity by id.
func (m *FixtureMutation) SetSeasonID(id int) {
	m.season = &id
}

// ClearSeason clears the "season" edge to the Season entity.
func (m *FixtureMutation) ClearSeason() {
	m.clearedseason = true
}

// SeasonCleared reports if the "season" edge to the Season entity was cleared.
func (m *FixtureMutation) SeasonCleared() bool {
	return m.clearedseason
}

// SeasonID returns the "season" edge ID in the mutation.
func (m *FixtureMutation) SeasonID() (id int, exists bool) {
	if m.season != nil {
		return *m.season, true
	}
	return
}

// SeasonIDs returns the "season" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SeasonID instead. It exists only for internal usage by the builders.
func (m *FixtureMutation) SeasonIDs() (ids []int) {
	if id := m.season; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSeason resets all changes to the "season" edge.
func (m *FixtureMutation) ResetSeason() {
	m.season = nil
	m.clearedseason = false
}

// Where appends a list predicates to the FixtureMutation builder.
func (m *FixtureMutation) Where(ps ...predicate.Fixture) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FixtureMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FixtureMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Fixture, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FixtureMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FixtureMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Fixture).
func (m *FixtureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FixtureMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.slug != nil {
		fields = append(fields, fixture.FieldSlug)
	}
	if m.apiFootballId != nil {
		fields = append(fields, fixture.FieldApiFootballId)
	}
	if m.referee != nil {
		fields = append(fields, fixture.FieldReferee)
	}
	if m.timezone != nil {
		fields = append(fields, fixture.FieldTimezone)
	}
	if m.date != nil {
		fields = append(fields, fixture.FieldDate)
	}
	if m.elapsed != nil {
		fields = append(fields, fixture.FieldElapsed)
	}
	if m.round != nil {
		fields = append(fields, fixture.FieldRound)
	}
	if m.status != nil {
		fields = append(fields, fixture.FieldStatus)
	}
	if m.homeTeamScore != nil {
		fields = append(fields, fixture.FieldHomeTeamScore)
	}
	if m.awayTeamScore != nil {
		fields = append(fields, fixture.FieldAwayTeamScore)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FixtureMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fixture.FieldSlug:
		return m.Slug()
	case fixture.FieldApiFootballId:
		return m.ApiFootballId()
	case fixture.FieldReferee:
		return m.Referee()
	case fixture.FieldTimezone:
		return m.Timezone()
	case fixture.FieldDate:
		return m.Date()
	case fixture.FieldElapsed:
		return m.Elapsed()
	case fixture.FieldRound:
		return m.Round()
	case fixture.FieldStatus:
		return m.Status()
	case fixture.FieldHomeTeamScore:
		return m.HomeTeamScore()
	case fixture.FieldAwayTeamScore:
		return m.AwayTeamScore()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FixtureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fixture.FieldSlug:
		return m.OldSlug(ctx)
	case fixture.FieldApiFootballId:
		return m.OldApiFootballId(ctx)
	case fixture.FieldReferee:
		return m.OldReferee(ctx)
	case fixture.FieldTimezone:
		return m.OldTimezone(ctx)
	case fixture.FieldDate:
		return m.OldDate(ctx)
	case fixture.FieldElapsed:
		return m.OldElapsed(ctx)
	case fixture.FieldRound:
		return m.OldRound(ctx)
	case fixture.FieldStatus:
		return m.OldStatus(ctx)
	case fixture.FieldHomeTeamScore:
		return m.OldHomeTeamScore(ctx)
	case fixture.FieldAwayTeamScore:
		return m.OldAwayTeamScore(ctx)
	}
	return nil, fmt.Errorf("unknown Fixture field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FixtureMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fixture.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case fixture.FieldApiFootballId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApiFootballId(v)
		return nil
	case fixture.FieldReferee:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferee(v)
		return nil
	case fixture.FieldTimezone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	case fixture.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case fixture.FieldElapsed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElapsed(v)
		return nil
	case fixture.FieldRound:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRound(v)
		return nil
	case fixture.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case fixture.FieldHomeTeamScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomeTeamScore(v)
		return nil
	case fixture.FieldAwayTeamScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAwayTeamScore(v)
		return nil
	}
	return fmt.Errorf("unknown Fixture field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FixtureMutation) AddedFields() []string {
	var fields []string
	if m.addapiFootballId != nil {
		fields = append(fields, fixture.FieldApiFootballId)
	}
	if m.addelapsed != nil {
		fields = append(fields, fixture.FieldElapsed)
	}
	if m.addround != nil {
		fields = append(fields, fixture.FieldRound)
	}
	if m.addhomeTeamScore != nil {
		fields = append(fields, fixture.FieldHomeTeamScore)
	}
	if m.addawayTeamScore != nil {
		fields = append(fields, fixture.FieldAwayTeamScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FixtureMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case fixture.FieldApiFootballId:
		return m.AddedApiFootballId()
	case fixture.FieldElapsed:
		return m.AddedElapsed()
	case fixture.FieldRound:
		return m.AddedRound()
	case fixture.FieldHomeTeamScore:
		return m.AddedHomeTeamScore()
	case fixture.FieldAwayTeamScore:
		return m.AddedAwayTeamScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FixtureMutation) AddField(name string, value ent.Value) error {
	switch name {
	case fixture.FieldApiFootballId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddApiFootballId(v)
		return nil
	case fixture.FieldElapsed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddElapsed(v)
		return nil
	case fixture.FieldRound:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRound(v)
		return nil
	case fixture.FieldHomeTeamScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHomeTeamScore(v)
		return nil
	case fixture.FieldAwayTeamScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAwayTeamScore(v)
		return nil
	}
	return fmt.Errorf("unknown Fixture numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FixtureMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(fixture.FieldReferee) {
		fields = append(fields, fixture.FieldReferee)
	}
	if m.FieldCleared(fixture.FieldTimezone) {
		fields = append(fields, fixture.FieldTimezone)
	}
	if m.FieldCleared(fixture.FieldElapsed) {
		fields = append(fields, fixture.FieldElapsed)
	}
	if m.FieldCleared(fixture.FieldRound) {
		fields = append(fields, fixture.FieldRound)
	}
	if m.FieldCleared(fixture.FieldHomeTeamScore) {
		fields = append(fields, fixture.FieldHomeTeamScore)
	}
	if m.FieldCleared(fixture.FieldAwayTeamScore) {
		fields = append(fields, fixture.FieldAwayTeamScore)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FixtureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FixtureMutation) ClearField(name string) error {
	switch name {
	case fixture.FieldReferee:
		m.ClearReferee()
		return nil
	case fixture.FieldTimezone:
		m.ClearTimezone()
		return nil
	case fixture.FieldElapsed:
		m.ClearElapsed()
		return nil
	case fixture.FieldRound:
		m.ClearRound()
		return nil
	case fixture.FieldHomeTeamScore:
		m.ClearHomeTeamScore()
		return nil
	case fixture.FieldAwayTeamScore:
		m.ClearAwayTeamScore()
		return nil
	}
	return fmt.Errorf("unknown Fixture nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FixtureMutation) ResetField(name string) error {
	switch name {
	case fixture.FieldSlug:
		m.ResetSlug()
		return nil
	case fixture.FieldApiFootballId:
		m.ResetApiFootballId()
		return nil
	case fixture.FieldReferee:
		m.ResetReferee()
		return nil
	case fixture.FieldTimezone:
		m.ResetTimezone()
		return nil
	case fixture.FieldDate:
		m.ResetDate()
		return nil
	case fixture.FieldElapsed:
		m.ResetElapsed()
		return nil
	case fixture.FieldRound:
		m.ResetRound()
		return nil
	case fixture.FieldStatus:
		m.ResetStatus()
		return nil
	case fixture.FieldHomeTeamScore:
		m.ResetHomeTeamScore()
		return nil
	case fixture.FieldAwayTeamScore:
		m.ResetAwayTeamScore()
		return nil
	}
	return fmt.Errorf("unknown Fixture field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FixtureMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.homeTeam != nil {
		edges = append(edges, fixture.EdgeHomeTeam)
	}
	if m.awayTeam != nil {
		edges = append(edges, fixture.EdgeAwayTeam)
	}
	if m.season != nil {
		edges = append(edges, fixture.EdgeSeason)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FixtureMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case fixture.EdgeHomeTeam:
		if id := m.homeTeam; id != nil {
			return []ent.Value{*id}
		}
	case fixture.EdgeAwayTeam:
		if id := m.awayTeam; id != nil {
			return []ent.Value{*id}
		}
	case fixture.EdgeSeason:
		if id := m.season; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FixtureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FixtureMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FixtureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedhomeTeam {
		edges = append(edges, fixture.EdgeHomeTeam)
	}
	if m.clearedawayTeam {
		edges = append(edges, fixture.EdgeAwayTeam)
	}
	if m.clearedseason {
		edges = append(edges, fixture.EdgeSeason)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FixtureMutation) EdgeCleared(name string) bool {
	switch name {
	case fixture.EdgeHomeTeam:
		return m.clearedhomeTeam
	case fixture.EdgeAwayTeam:
		return m.clearedawayTeam
	case fixture.EdgeSeason:
		return m.clearedseason
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FixtureMutation) ClearEdge(name string) error {
	switch name {
	case fixture.EdgeHomeTeam:
		m.ClearHomeTeam()
		return nil
	case fixture.EdgeAwayTeam:
		m.ClearAwayTeam()
		return nil
	case fixture.EdgeSeason:
		m.ClearSeason()
		return nil
	}
	return fmt.Errorf("unknown Fixture unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FixtureMutation) ResetEdge(name string) error {
	switch name {
	case fixture.EdgeHomeTeam:
		m.ResetHomeTeam()
		return nil
	case fixture.EdgeAwayTeam:
		m.ResetAwayTeam()
		return nil
	case fixture.EdgeSeason:
		m.ResetSeason()
		return nil
	}
	return fmt.Errorf("unknown Fixture edge %s", name)
}

// LeagueMutation represents an operation that mutates the League nodes in the graph.
type LeagueMutation struct {
	config
	op               Op
	typ              string
	id               *int
	footballApiId    *int
	addfootballApiId *int
	slug             *string
	name             *string
	_type            *league.Type
	logo             *string
	clearedFields    map[string]struct{}
	country          *int
	clearedcountry   bool
	season           map[int]struct{}
	removedseason    map[int]struct{}
	clearedseason    bool
	done             bool
	oldValue         func(context.Context) (*League, error)
	predicates       []predicate.League
}

var _ ent.Mutation = (*LeagueMutation)(nil)

// leagueOption allows management of the mutation configuration using functional options.
type leagueOption func(*LeagueMutation)

// newLeagueMutation creates new mutation for the League entity.
func newLeagueMutation(c config, op Op, opts ...leagueOption) *LeagueMutation {
	m := &LeagueMutation{
		config:        c,
		op:            op,
		typ:           TypeLeague,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLeagueID sets the ID field of the mutation.
func withLeagueID(id int) leagueOption {
	return func(m *LeagueMutation) {
		var (
			err   error
			once  sync.Once
			value *League
		)
		m.oldValue = func(ctx context.Context) (*League, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().League.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLeague sets the old League of the mutation.
func withLeague(node *League) leagueOption {
	return func(m *LeagueMutation) {
		m.oldValue = func(context.Context) (*League, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LeagueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LeagueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LeagueMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LeagueMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().League.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFootballApiId sets the "footballApiId" field.
func (m *LeagueMutation) SetFootballApiId(i int) {
	m.footballApiId = &i
	m.addfootballApiId = nil
}

// FootballApiId returns the value of the "footballApiId" field in the mutation.
func (m *LeagueMutation) FootballApiId() (r int, exists bool) {
	v := m.footballApiId
	if v == nil {
		return
	}
	return *v, true
}

// OldFootballApiId returns the old "footballApiId" field's value of the League entity.
// If the League object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeagueMutation) OldFootballApiId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFootballApiId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFootballApiId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFootballApiId: %w", err)
	}
	return oldValue.FootballApiId, nil
}

// AddFootballApiId adds i to the "footballApiId" field.
func (m *LeagueMutation) AddFootballApiId(i int) {
	if m.addfootballApiId != nil {
		*m.addfootballApiId += i
	} else {
		m.addfootballApiId = &i
	}
}

// AddedFootballApiId returns the value that was added to the "footballApiId" field in this mutation.
func (m *LeagueMutation) AddedFootballApiId() (r int, exists bool) {
	v := m.addfootballApiId
	if v == nil {
		return
	}
	return *v, true
}

// ResetFootballApiId resets all changes to the "footballApiId" field.
func (m *LeagueMutation) ResetFootballApiId() {
	m.footballApiId = nil
	m.addfootballApiId = nil
}

// SetSlug sets the "slug" field.
func (m *LeagueMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *LeagueMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the League entity.
// If the League object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeagueMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *LeagueMutation) ResetSlug() {
	m.slug = nil
}

// SetName sets the "name" field.
func (m *LeagueMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LeagueMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the League entity.
// If the League object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeagueMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LeagueMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *LeagueMutation) SetType(l league.Type) {
	m._type = &l
}

// GetType returns the value of the "type" field in the mutation.
func (m *LeagueMutation) GetType() (r league.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the League entity.
// If the League object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeagueMutation) OldType(ctx context.Context) (v league.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *LeagueMutation) ResetType() {
	m._type = nil
}

// SetLogo sets the "logo" field.
func (m *LeagueMutation) SetLogo(s string) {
	m.logo = &s
}

// Logo returns the value of the "logo" field in the mutation.
func (m *LeagueMutation) Logo() (r string, exists bool) {
	v := m.logo
	if v == nil {
		return
	}
	return *v, true
}

// OldLogo returns the old "logo" field's value of the League entity.
// If the League object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeagueMutation) OldLogo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogo: %w", err)
	}
	return oldValue.Logo, nil
}

// ResetLogo resets all changes to the "logo" field.
func (m *LeagueMutation) ResetLogo() {
	m.logo = nil
}

// SetCountryID sets the "country" edge to the Country entity by id.
func (m *LeagueMutation) SetCountryID(id int) {
	m.country = &id
}

// ClearCountry clears the "country" edge to the Country entity.
func (m *LeagueMutation) ClearCountry() {
	m.clearedcountry = true
}

// CountryCleared reports if the "country" edge to the Country entity was cleared.
func (m *LeagueMutation) CountryCleared() bool {
	return m.clearedcountry
}

// CountryID returns the "country" edge ID in the mutation.
func (m *LeagueMutation) CountryID() (id int, exists bool) {
	if m.country != nil {
		return *m.country, true
	}
	return
}

// CountryIDs returns the "country" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CountryID instead. It exists only for internal usage by the builders.
func (m *LeagueMutation) CountryIDs() (ids []int) {
	if id := m.country; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCountry resets all changes to the "country" edge.
func (m *LeagueMutation) ResetCountry() {
	m.country = nil
	m.clearedcountry = false
}

// AddSeasonIDs adds the "season" edge to the Season entity by ids.
func (m *LeagueMutation) AddSeasonIDs(ids ...int) {
	if m.season == nil {
		m.season = make(map[int]struct{})
	}
	for i := range ids {
		m.season[ids[i]] = struct{}{}
	}
}

// ClearSeason clears the "season" edge to the Season entity.
func (m *LeagueMutation) ClearSeason() {
	m.clearedseason = true
}

// SeasonCleared reports if the "season" edge to the Season entity was cleared.
func (m *LeagueMutation) SeasonCleared() bool {
	return m.clearedseason
}

// RemoveSeasonIDs removes the "season" edge to the Season entity by IDs.
func (m *LeagueMutation) RemoveSeasonIDs(ids ...int) {
	if m.removedseason == nil {
		m.removedseason = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.season, ids[i])
		m.removedseason[ids[i]] = struct{}{}
	}
}

// RemovedSeason returns the removed IDs of the "season" edge to the Season entity.
func (m *LeagueMutation) RemovedSeasonIDs() (ids []int) {
	for id := range m.removedseason {
		ids = append(ids, id)
	}
	return
}

// SeasonIDs returns the "season" edge IDs in the mutation.
func (m *LeagueMutation) SeasonIDs() (ids []int) {
	for id := range m.season {
		ids = append(ids, id)
	}
	return
}

// ResetSeason resets all changes to the "season" edge.
func (m *LeagueMutation) ResetSeason() {
	m.season = nil
	m.clearedseason = false
	m.removedseason = nil
}

// Where appends a list predicates to the LeagueMutation builder.
func (m *LeagueMutation) Where(ps ...predicate.League) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LeagueMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LeagueMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.League, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LeagueMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LeagueMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (League).
func (m *LeagueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LeagueMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.footballApiId != nil {
		fields = append(fields, league.FieldFootballApiId)
	}
	if m.slug != nil {
		fields = append(fields, league.FieldSlug)
	}
	if m.name != nil {
		fields = append(fields, league.FieldName)
	}
	if m._type != nil {
		fields = append(fields, league.FieldType)
	}
	if m.logo != nil {
		fields = append(fields, league.FieldLogo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LeagueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case league.FieldFootballApiId:
		return m.FootballApiId()
	case league.FieldSlug:
		return m.Slug()
	case league.FieldName:
		return m.Name()
	case league.FieldType:
		return m.GetType()
	case league.FieldLogo:
		return m.Logo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LeagueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case league.FieldFootballApiId:
		return m.OldFootballApiId(ctx)
	case league.FieldSlug:
		return m.OldSlug(ctx)
	case league.FieldName:
		return m.OldName(ctx)
	case league.FieldType:
		return m.OldType(ctx)
	case league.FieldLogo:
		return m.OldLogo(ctx)
	}
	return nil, fmt.Errorf("unknown League field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LeagueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case league.FieldFootballApiId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFootballApiId(v)
		return nil
	case league.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case league.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case league.FieldType:
		v, ok := value.(league.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case league.FieldLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogo(v)
		return nil
	}
	return fmt.Errorf("unknown League field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LeagueMutation) AddedFields() []string {
	var fields []string
	if m.addfootballApiId != nil {
		fields = append(fields, league.FieldFootballApiId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LeagueMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case league.FieldFootballApiId:
		return m.AddedFootballApiId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LeagueMutation) AddField(name string, value ent.Value) error {
	switch name {
	case league.FieldFootballApiId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFootballApiId(v)
		return nil
	}
	return fmt.Errorf("unknown League numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LeagueMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LeagueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LeagueMutation) ClearField(name string) error {
	return fmt.Errorf("unknown League nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LeagueMutation) ResetField(name string) error {
	switch name {
	case league.FieldFootballApiId:
		m.ResetFootballApiId()
		return nil
	case league.FieldSlug:
		m.ResetSlug()
		return nil
	case league.FieldName:
		m.ResetName()
		return nil
	case league.FieldType:
		m.ResetType()
		return nil
	case league.FieldLogo:
		m.ResetLogo()
		return nil
	}
	return fmt.Errorf("unknown League field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LeagueMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.country != nil {
		edges = append(edges, league.EdgeCountry)
	}
	if m.season != nil {
		edges = append(edges, league.EdgeSeason)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LeagueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case league.EdgeCountry:
		if id := m.country; id != nil {
			return []ent.Value{*id}
		}
	case league.EdgeSeason:
		ids := make([]ent.Value, 0, len(m.season))
		for id := range m.season {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LeagueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedseason != nil {
		edges = append(edges, league.EdgeSeason)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LeagueMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case league.EdgeSeason:
		ids := make([]ent.Value, 0, len(m.removedseason))
		for id := range m.removedseason {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LeagueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcountry {
		edges = append(edges, league.EdgeCountry)
	}
	if m.clearedseason {
		edges = append(edges, league.EdgeSeason)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LeagueMutation) EdgeCleared(name string) bool {
	switch name {
	case league.EdgeCountry:
		return m.clearedcountry
	case league.EdgeSeason:
		return m.clearedseason
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LeagueMutation) ClearEdge(name string) error {
	switch name {
	case league.EdgeCountry:
		m.ClearCountry()
		return nil
	}
	return fmt.Errorf("unknown League unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LeagueMutation) ResetEdge(name string) error {
	switch name {
	case league.EdgeCountry:
		m.ResetCountry()
		return nil
	case league.EdgeSeason:
		m.ResetSeason()
		return nil
	}
	return fmt.Errorf("unknown League edge %s", name)
}

// PlayerMutation represents an operation that mutates the Player nodes in the graph.
type PlayerMutation struct {
	config
	op            Op
	typ           string
	id            *int
	slug          *string
	name          *string
	firstname     *string
	lastname      *string
	age           *int
	addage        *int
	height        *float64
	addheight     *float64
	weight        *float64
	addweight     *float64
	injured       *bool
	photo         *string
	clearedFields map[string]struct{}
	birth         *int
	clearedbirth  bool
	done          bool
	oldValue      func(context.Context) (*Player, error)
	predicates    []predicate.Player
}

var _ ent.Mutation = (*PlayerMutation)(nil)

// playerOption allows management of the mutation configuration using functional options.
type playerOption func(*PlayerMutation)

// newPlayerMutation creates new mutation for the Player entity.
func newPlayerMutation(c config, op Op, opts ...playerOption) *PlayerMutation {
	m := &PlayerMutation{
		config:        c,
		op:            op,
		typ:           TypePlayer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlayerID sets the ID field of the mutation.
func withPlayerID(id int) playerOption {
	return func(m *PlayerMutation) {
		var (
			err   error
			once  sync.Once
			value *Player
		)
		m.oldValue = func(ctx context.Context) (*Player, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Player.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlayer sets the old Player of the mutation.
func withPlayer(node *Player) playerOption {
	return func(m *PlayerMutation) {
		m.oldValue = func(context.Context) (*Player, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlayerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlayerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Player entities.
func (m *PlayerMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlayerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlayerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Player.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSlug sets the "slug" field.
func (m *PlayerMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *PlayerMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *PlayerMutation) ResetSlug() {
	m.slug = nil
}

// SetName sets the "name" field.
func (m *PlayerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PlayerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PlayerMutation) ResetName() {
	m.name = nil
}

// SetFirstname sets the "firstname" field.
func (m *PlayerMutation) SetFirstname(s string) {
	m.firstname = &s
}

// Firstname returns the value of the "firstname" field in the mutation.
func (m *PlayerMutation) Firstname() (r string, exists bool) {
	v := m.firstname
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstname returns the old "firstname" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldFirstname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstname: %w", err)
	}
	return oldValue.Firstname, nil
}

// ResetFirstname resets all changes to the "firstname" field.
func (m *PlayerMutation) ResetFirstname() {
	m.firstname = nil
}

// SetLastname sets the "lastname" field.
func (m *PlayerMutation) SetLastname(s string) {
	m.lastname = &s
}

// Lastname returns the value of the "lastname" field in the mutation.
func (m *PlayerMutation) Lastname() (r string, exists bool) {
	v := m.lastname
	if v == nil {
		return
	}
	return *v, true
}

// OldLastname returns the old "lastname" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldLastname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastname: %w", err)
	}
	return oldValue.Lastname, nil
}

// ResetLastname resets all changes to the "lastname" field.
func (m *PlayerMutation) ResetLastname() {
	m.lastname = nil
}

// SetAge sets the "age" field.
func (m *PlayerMutation) SetAge(i int) {
	m.age = &i
	m.addage = nil
}

// Age returns the value of the "age" field in the mutation.
func (m *PlayerMutation) Age() (r int, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old "age" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldAge(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds i to the "age" field.
func (m *PlayerMutation) AddAge(i int) {
	if m.addage != nil {
		*m.addage += i
	} else {
		m.addage = &i
	}
}

// AddedAge returns the value that was added to the "age" field in this mutation.
func (m *PlayerMutation) AddedAge() (r int, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ResetAge resets all changes to the "age" field.
func (m *PlayerMutation) ResetAge() {
	m.age = nil
	m.addage = nil
}

// SetHeight sets the "height" field.
func (m *PlayerMutation) SetHeight(f float64) {
	m.height = &f
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *PlayerMutation) Height() (r float64, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldHeight(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds f to the "height" field.
func (m *PlayerMutation) AddHeight(f float64) {
	if m.addheight != nil {
		*m.addheight += f
	} else {
		m.addheight = &f
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *PlayerMutation) AddedHeight() (r float64, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ResetHeight resets all changes to the "height" field.
func (m *PlayerMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
}

// SetWeight sets the "weight" field.
func (m *PlayerMutation) SetWeight(f float64) {
	m.weight = &f
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *PlayerMutation) Weight() (r float64, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldWeight(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds f to the "weight" field.
func (m *PlayerMutation) AddWeight(f float64) {
	if m.addweight != nil {
		*m.addweight += f
	} else {
		m.addweight = &f
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *PlayerMutation) AddedWeight() (r float64, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeight resets all changes to the "weight" field.
func (m *PlayerMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
}

// SetInjured sets the "injured" field.
func (m *PlayerMutation) SetInjured(b bool) {
	m.injured = &b
}

// Injured returns the value of the "injured" field in the mutation.
func (m *PlayerMutation) Injured() (r bool, exists bool) {
	v := m.injured
	if v == nil {
		return
	}
	return *v, true
}

// OldInjured returns the old "injured" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldInjured(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInjured is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInjured requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInjured: %w", err)
	}
	return oldValue.Injured, nil
}

// ResetInjured resets all changes to the "injured" field.
func (m *PlayerMutation) ResetInjured() {
	m.injured = nil
}

// SetPhoto sets the "photo" field.
func (m *PlayerMutation) SetPhoto(s string) {
	m.photo = &s
}

// Photo returns the value of the "photo" field in the mutation.
func (m *PlayerMutation) Photo() (r string, exists bool) {
	v := m.photo
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoto returns the old "photo" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldPhoto(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoto is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoto requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoto: %w", err)
	}
	return oldValue.Photo, nil
}

// ResetPhoto resets all changes to the "photo" field.
func (m *PlayerMutation) ResetPhoto() {
	m.photo = nil
}

// SetBirthID sets the "birth" edge to the Birth entity by id.
func (m *PlayerMutation) SetBirthID(id int) {
	m.birth = &id
}

// ClearBirth clears the "birth" edge to the Birth entity.
func (m *PlayerMutation) ClearBirth() {
	m.clearedbirth = true
}

// BirthCleared reports if the "birth" edge to the Birth entity was cleared.
func (m *PlayerMutation) BirthCleared() bool {
	return m.clearedbirth
}

// BirthID returns the "birth" edge ID in the mutation.
func (m *PlayerMutation) BirthID() (id int, exists bool) {
	if m.birth != nil {
		return *m.birth, true
	}
	return
}

// BirthIDs returns the "birth" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BirthID instead. It exists only for internal usage by the builders.
func (m *PlayerMutation) BirthIDs() (ids []int) {
	if id := m.birth; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBirth resets all changes to the "birth" edge.
func (m *PlayerMutation) ResetBirth() {
	m.birth = nil
	m.clearedbirth = false
}

// Where appends a list predicates to the PlayerMutation builder.
func (m *PlayerMutation) Where(ps ...predicate.Player) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlayerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlayerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Player, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlayerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlayerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Player).
func (m *PlayerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlayerMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.slug != nil {
		fields = append(fields, player.FieldSlug)
	}
	if m.name != nil {
		fields = append(fields, player.FieldName)
	}
	if m.firstname != nil {
		fields = append(fields, player.FieldFirstname)
	}
	if m.lastname != nil {
		fields = append(fields, player.FieldLastname)
	}
	if m.age != nil {
		fields = append(fields, player.FieldAge)
	}
	if m.height != nil {
		fields = append(fields, player.FieldHeight)
	}
	if m.weight != nil {
		fields = append(fields, player.FieldWeight)
	}
	if m.injured != nil {
		fields = append(fields, player.FieldInjured)
	}
	if m.photo != nil {
		fields = append(fields, player.FieldPhoto)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlayerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case player.FieldSlug:
		return m.Slug()
	case player.FieldName:
		return m.Name()
	case player.FieldFirstname:
		return m.Firstname()
	case player.FieldLastname:
		return m.Lastname()
	case player.FieldAge:
		return m.Age()
	case player.FieldHeight:
		return m.Height()
	case player.FieldWeight:
		return m.Weight()
	case player.FieldInjured:
		return m.Injured()
	case player.FieldPhoto:
		return m.Photo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlayerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case player.FieldSlug:
		return m.OldSlug(ctx)
	case player.FieldName:
		return m.OldName(ctx)
	case player.FieldFirstname:
		return m.OldFirstname(ctx)
	case player.FieldLastname:
		return m.OldLastname(ctx)
	case player.FieldAge:
		return m.OldAge(ctx)
	case player.FieldHeight:
		return m.OldHeight(ctx)
	case player.FieldWeight:
		return m.OldWeight(ctx)
	case player.FieldInjured:
		return m.OldInjured(ctx)
	case player.FieldPhoto:
		return m.OldPhoto(ctx)
	}
	return nil, fmt.Errorf("unknown Player field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlayerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case player.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case player.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case player.FieldFirstname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstname(v)
		return nil
	case player.FieldLastname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastname(v)
		return nil
	case player.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case player.FieldHeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case player.FieldWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case player.FieldInjured:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInjured(v)
		return nil
	case player.FieldPhoto:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoto(v)
		return nil
	}
	return fmt.Errorf("unknown Player field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlayerMutation) AddedFields() []string {
	var fields []string
	if m.addage != nil {
		fields = append(fields, player.FieldAge)
	}
	if m.addheight != nil {
		fields = append(fields, player.FieldHeight)
	}
	if m.addweight != nil {
		fields = append(fields, player.FieldWeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlayerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case player.FieldAge:
		return m.AddedAge()
	case player.FieldHeight:
		return m.AddedHeight()
	case player.FieldWeight:
		return m.AddedWeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlayerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case player.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	case player.FieldHeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	case player.FieldWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	}
	return fmt.Errorf("unknown Player numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlayerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlayerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlayerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Player nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlayerMutation) ResetField(name string) error {
	switch name {
	case player.FieldSlug:
		m.ResetSlug()
		return nil
	case player.FieldName:
		m.ResetName()
		return nil
	case player.FieldFirstname:
		m.ResetFirstname()
		return nil
	case player.FieldLastname:
		m.ResetLastname()
		return nil
	case player.FieldAge:
		m.ResetAge()
		return nil
	case player.FieldHeight:
		m.ResetHeight()
		return nil
	case player.FieldWeight:
		m.ResetWeight()
		return nil
	case player.FieldInjured:
		m.ResetInjured()
		return nil
	case player.FieldPhoto:
		m.ResetPhoto()
		return nil
	}
	return fmt.Errorf("unknown Player field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlayerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.birth != nil {
		edges = append(edges, player.EdgeBirth)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlayerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case player.EdgeBirth:
		if id := m.birth; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlayerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlayerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlayerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbirth {
		edges = append(edges, player.EdgeBirth)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlayerMutation) EdgeCleared(name string) bool {
	switch name {
	case player.EdgeBirth:
		return m.clearedbirth
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlayerMutation) ClearEdge(name string) error {
	switch name {
	case player.EdgeBirth:
		m.ClearBirth()
		return nil
	}
	return fmt.Errorf("unknown Player unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlayerMutation) ResetEdge(name string) error {
	switch name {
	case player.EdgeBirth:
		m.ResetBirth()
		return nil
	}
	return fmt.Errorf("unknown Player edge %s", name)
}

// SeasonMutation represents an operation that mutates the Season nodes in the graph.
type SeasonMutation struct {
	config
	op               Op
	typ              string
	id               *int
	slug             *string
	year             *int
	addyear          *int
	start_date       *time.Time
	end_date         *time.Time
	current          *bool
	clearedFields    map[string]struct{}
	league           *int
	clearedleague    bool
	fixtures         map[int]struct{}
	removedfixtures  map[int]struct{}
	clearedfixtures  bool
	standings        map[int]struct{}
	removedstandings map[int]struct{}
	clearedstandings bool
	done             bool
	oldValue         func(context.Context) (*Season, error)
	predicates       []predicate.Season
}

var _ ent.Mutation = (*SeasonMutation)(nil)

// seasonOption allows management of the mutation configuration using functional options.
type seasonOption func(*SeasonMutation)

// newSeasonMutation creates new mutation for the Season entity.
func newSeasonMutation(c config, op Op, opts ...seasonOption) *SeasonMutation {
	m := &SeasonMutation{
		config:        c,
		op:            op,
		typ:           TypeSeason,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSeasonID sets the ID field of the mutation.
func withSeasonID(id int) seasonOption {
	return func(m *SeasonMutation) {
		var (
			err   error
			once  sync.Once
			value *Season
		)
		m.oldValue = func(ctx context.Context) (*Season, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Season.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSeason sets the old Season of the mutation.
func withSeason(node *Season) seasonOption {
	return func(m *SeasonMutation) {
		m.oldValue = func(context.Context) (*Season, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SeasonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SeasonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SeasonMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SeasonMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Season.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSlug sets the "slug" field.
func (m *SeasonMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *SeasonMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Season entity.
// If the Season object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeasonMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *SeasonMutation) ResetSlug() {
	m.slug = nil
}

// SetYear sets the "year" field.
func (m *SeasonMutation) SetYear(i int) {
	m.year = &i
	m.addyear = nil
}

// Year returns the value of the "year" field in the mutation.
func (m *SeasonMutation) Year() (r int, exists bool) {
	v := m.year
	if v == nil {
		return
	}
	return *v, true
}

// OldYear returns the old "year" field's value of the Season entity.
// If the Season object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeasonMutation) OldYear(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYear: %w", err)
	}
	return oldValue.Year, nil
}

// AddYear adds i to the "year" field.
func (m *SeasonMutation) AddYear(i int) {
	if m.addyear != nil {
		*m.addyear += i
	} else {
		m.addyear = &i
	}
}

// AddedYear returns the value that was added to the "year" field in this mutation.
func (m *SeasonMutation) AddedYear() (r int, exists bool) {
	v := m.addyear
	if v == nil {
		return
	}
	return *v, true
}

// ResetYear resets all changes to the "year" field.
func (m *SeasonMutation) ResetYear() {
	m.year = nil
	m.addyear = nil
}

// SetStartDate sets the "start_date" field.
func (m *SeasonMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *SeasonMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Season entity.
// If the Season object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeasonMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *SeasonMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *SeasonMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *SeasonMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Season entity.
// If the Season object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeasonMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *SeasonMutation) ResetEndDate() {
	m.end_date = nil
}

// SetCurrent sets the "current" field.
func (m *SeasonMutation) SetCurrent(b bool) {
	m.current = &b
}

// Current returns the value of the "current" field in the mutation.
func (m *SeasonMutation) Current() (r bool, exists bool) {
	v := m.current
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrent returns the old "current" field's value of the Season entity.
// If the Season object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeasonMutation) OldCurrent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrent: %w", err)
	}
	return oldValue.Current, nil
}

// ResetCurrent resets all changes to the "current" field.
func (m *SeasonMutation) ResetCurrent() {
	m.current = nil
}

// SetLeagueID sets the "league" edge to the League entity by id.
func (m *SeasonMutation) SetLeagueID(id int) {
	m.league = &id
}

// ClearLeague clears the "league" edge to the League entity.
func (m *SeasonMutation) ClearLeague() {
	m.clearedleague = true
}

// LeagueCleared reports if the "league" edge to the League entity was cleared.
func (m *SeasonMutation) LeagueCleared() bool {
	return m.clearedleague
}

// LeagueID returns the "league" edge ID in the mutation.
func (m *SeasonMutation) LeagueID() (id int, exists bool) {
	if m.league != nil {
		return *m.league, true
	}
	return
}

// LeagueIDs returns the "league" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LeagueID instead. It exists only for internal usage by the builders.
func (m *SeasonMutation) LeagueIDs() (ids []int) {
	if id := m.league; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLeague resets all changes to the "league" edge.
func (m *SeasonMutation) ResetLeague() {
	m.league = nil
	m.clearedleague = false
}

// AddFixtureIDs adds the "fixtures" edge to the Fixture entity by ids.
func (m *SeasonMutation) AddFixtureIDs(ids ...int) {
	if m.fixtures == nil {
		m.fixtures = make(map[int]struct{})
	}
	for i := range ids {
		m.fixtures[ids[i]] = struct{}{}
	}
}

// ClearFixtures clears the "fixtures" edge to the Fixture entity.
func (m *SeasonMutation) ClearFixtures() {
	m.clearedfixtures = true
}

// FixturesCleared reports if the "fixtures" edge to the Fixture entity was cleared.
func (m *SeasonMutation) FixturesCleared() bool {
	return m.clearedfixtures
}

// RemoveFixtureIDs removes the "fixtures" edge to the Fixture entity by IDs.
func (m *SeasonMutation) RemoveFixtureIDs(ids ...int) {
	if m.removedfixtures == nil {
		m.removedfixtures = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.fixtures, ids[i])
		m.removedfixtures[ids[i]] = struct{}{}
	}
}

// RemovedFixtures returns the removed IDs of the "fixtures" edge to the Fixture entity.
func (m *SeasonMutation) RemovedFixturesIDs() (ids []int) {
	for id := range m.removedfixtures {
		ids = append(ids, id)
	}
	return
}

// FixturesIDs returns the "fixtures" edge IDs in the mutation.
func (m *SeasonMutation) FixturesIDs() (ids []int) {
	for id := range m.fixtures {
		ids = append(ids, id)
	}
	return
}

// ResetFixtures resets all changes to the "fixtures" edge.
func (m *SeasonMutation) ResetFixtures() {
	m.fixtures = nil
	m.clearedfixtures = false
	m.removedfixtures = nil
}

// AddStandingIDs adds the "standings" edge to the Standings entity by ids.
func (m *SeasonMutation) AddStandingIDs(ids ...int) {
	if m.standings == nil {
		m.standings = make(map[int]struct{})
	}
	for i := range ids {
		m.standings[ids[i]] = struct{}{}
	}
}

// ClearStandings clears the "standings" edge to the Standings entity.
func (m *SeasonMutation) ClearStandings() {
	m.clearedstandings = true
}

// StandingsCleared reports if the "standings" edge to the Standings entity was cleared.
func (m *SeasonMutation) StandingsCleared() bool {
	return m.clearedstandings
}

// RemoveStandingIDs removes the "standings" edge to the Standings entity by IDs.
func (m *SeasonMutation) RemoveStandingIDs(ids ...int) {
	if m.removedstandings == nil {
		m.removedstandings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.standings, ids[i])
		m.removedstandings[ids[i]] = struct{}{}
	}
}

// RemovedStandings returns the removed IDs of the "standings" edge to the Standings entity.
func (m *SeasonMutation) RemovedStandingsIDs() (ids []int) {
	for id := range m.removedstandings {
		ids = append(ids, id)
	}
	return
}

// StandingsIDs returns the "standings" edge IDs in the mutation.
func (m *SeasonMutation) StandingsIDs() (ids []int) {
	for id := range m.standings {
		ids = append(ids, id)
	}
	return
}

// ResetStandings resets all changes to the "standings" edge.
func (m *SeasonMutation) ResetStandings() {
	m.standings = nil
	m.clearedstandings = false
	m.removedstandings = nil
}

// Where appends a list predicates to the SeasonMutation builder.
func (m *SeasonMutation) Where(ps ...predicate.Season) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SeasonMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SeasonMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Season, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SeasonMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SeasonMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Season).
func (m *SeasonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SeasonMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.slug != nil {
		fields = append(fields, season.FieldSlug)
	}
	if m.year != nil {
		fields = append(fields, season.FieldYear)
	}
	if m.start_date != nil {
		fields = append(fields, season.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, season.FieldEndDate)
	}
	if m.current != nil {
		fields = append(fields, season.FieldCurrent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SeasonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case season.FieldSlug:
		return m.Slug()
	case season.FieldYear:
		return m.Year()
	case season.FieldStartDate:
		return m.StartDate()
	case season.FieldEndDate:
		return m.EndDate()
	case season.FieldCurrent:
		return m.Current()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SeasonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case season.FieldSlug:
		return m.OldSlug(ctx)
	case season.FieldYear:
		return m.OldYear(ctx)
	case season.FieldStartDate:
		return m.OldStartDate(ctx)
	case season.FieldEndDate:
		return m.OldEndDate(ctx)
	case season.FieldCurrent:
		return m.OldCurrent(ctx)
	}
	return nil, fmt.Errorf("unknown Season field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeasonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case season.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case season.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYear(v)
		return nil
	case season.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case season.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case season.FieldCurrent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrent(v)
		return nil
	}
	return fmt.Errorf("unknown Season field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SeasonMutation) AddedFields() []string {
	var fields []string
	if m.addyear != nil {
		fields = append(fields, season.FieldYear)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SeasonMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case season.FieldYear:
		return m.AddedYear()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeasonMutation) AddField(name string, value ent.Value) error {
	switch name {
	case season.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYear(v)
		return nil
	}
	return fmt.Errorf("unknown Season numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SeasonMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SeasonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SeasonMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Season nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SeasonMutation) ResetField(name string) error {
	switch name {
	case season.FieldSlug:
		m.ResetSlug()
		return nil
	case season.FieldYear:
		m.ResetYear()
		return nil
	case season.FieldStartDate:
		m.ResetStartDate()
		return nil
	case season.FieldEndDate:
		m.ResetEndDate()
		return nil
	case season.FieldCurrent:
		m.ResetCurrent()
		return nil
	}
	return fmt.Errorf("unknown Season field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SeasonMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.league != nil {
		edges = append(edges, season.EdgeLeague)
	}
	if m.fixtures != nil {
		edges = append(edges, season.EdgeFixtures)
	}
	if m.standings != nil {
		edges = append(edges, season.EdgeStandings)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SeasonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case season.EdgeLeague:
		if id := m.league; id != nil {
			return []ent.Value{*id}
		}
	case season.EdgeFixtures:
		ids := make([]ent.Value, 0, len(m.fixtures))
		for id := range m.fixtures {
			ids = append(ids, id)
		}
		return ids
	case season.EdgeStandings:
		ids := make([]ent.Value, 0, len(m.standings))
		for id := range m.standings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SeasonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedfixtures != nil {
		edges = append(edges, season.EdgeFixtures)
	}
	if m.removedstandings != nil {
		edges = append(edges, season.EdgeStandings)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SeasonMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case season.EdgeFixtures:
		ids := make([]ent.Value, 0, len(m.removedfixtures))
		for id := range m.removedfixtures {
			ids = append(ids, id)
		}
		return ids
	case season.EdgeStandings:
		ids := make([]ent.Value, 0, len(m.removedstandings))
		for id := range m.removedstandings {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SeasonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedleague {
		edges = append(edges, season.EdgeLeague)
	}
	if m.clearedfixtures {
		edges = append(edges, season.EdgeFixtures)
	}
	if m.clearedstandings {
		edges = append(edges, season.EdgeStandings)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SeasonMutation) EdgeCleared(name string) bool {
	switch name {
	case season.EdgeLeague:
		return m.clearedleague
	case season.EdgeFixtures:
		return m.clearedfixtures
	case season.EdgeStandings:
		return m.clearedstandings
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SeasonMutation) ClearEdge(name string) error {
	switch name {
	case season.EdgeLeague:
		m.ClearLeague()
		return nil
	}
	return fmt.Errorf("unknown Season unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SeasonMutation) ResetEdge(name string) error {
	switch name {
	case season.EdgeLeague:
		m.ResetLeague()
		return nil
	case season.EdgeFixtures:
		m.ResetFixtures()
		return nil
	case season.EdgeStandings:
		m.ResetStandings()
		return nil
	}
	return fmt.Errorf("unknown Season edge %s", name)
}

// StandingsMutation represents an operation that mutates the Standings nodes in the graph.
type StandingsMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	rank                *int
	addrank             *int
	points              *int
	addpoints           *int
	goalsDiff           *int
	addgoalsDiff        *int
	group               *string
	form                *string
	status              *string
	description         *string
	allPlayed           *int
	addallPlayed        *int
	allWin              *int
	addallWin           *int
	allDraw             *int
	addallDraw          *int
	allLose             *int
	addallLose          *int
	allGoalsFor         *int
	addallGoalsFor      *int
	allGoalsAgainst     *int
	addallGoalsAgainst  *int
	homePlayed          *int
	addhomePlayed       *int
	homeWin             *int
	addhomeWin          *int
	homeDraw            *int
	addhomeDraw         *int
	homeLose            *int
	addhomeLose         *int
	homeGoalsFor        *int
	addhomeGoalsFor     *int
	homeGoalsAgainst    *int
	addhomeGoalsAgainst *int
	awayPlayed          *int
	addawayPlayed       *int
	awayWin             *int
	addawayWin          *int
	awayDraw            *int
	addawayDraw         *int
	awayLose            *int
	addawayLose         *int
	awayGoalsFor        *int
	addawayGoalsFor     *int
	awayGoalsAgainst    *int
	addawayGoalsAgainst *int
	_LastUpdated        *time.Time
	clearedFields       map[string]struct{}
	team                *int
	clearedteam         bool
	season              *int
	clearedseason       bool
	done                bool
	oldValue            func(context.Context) (*Standings, error)
	predicates          []predicate.Standings
}

var _ ent.Mutation = (*StandingsMutation)(nil)

// standingsOption allows management of the mutation configuration using functional options.
type standingsOption func(*StandingsMutation)

// newStandingsMutation creates new mutation for the Standings entity.
func newStandingsMutation(c config, op Op, opts ...standingsOption) *StandingsMutation {
	m := &StandingsMutation{
		config:        c,
		op:            op,
		typ:           TypeStandings,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStandingsID sets the ID field of the mutation.
func withStandingsID(id int) standingsOption {
	return func(m *StandingsMutation) {
		var (
			err   error
			once  sync.Once
			value *Standings
		)
		m.oldValue = func(ctx context.Context) (*Standings, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Standings.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStandings sets the old Standings of the mutation.
func withStandings(node *Standings) standingsOption {
	return func(m *StandingsMutation) {
		m.oldValue = func(context.Context) (*Standings, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StandingsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StandingsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StandingsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StandingsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Standings.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRank sets the "rank" field.
func (m *StandingsMutation) SetRank(i int) {
	m.rank = &i
	m.addrank = nil
}

// Rank returns the value of the "rank" field in the mutation.
func (m *StandingsMutation) Rank() (r int, exists bool) {
	v := m.rank
	if v == nil {
		return
	}
	return *v, true
}

// OldRank returns the old "rank" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldRank(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRank: %w", err)
	}
	return oldValue.Rank, nil
}

// AddRank adds i to the "rank" field.
func (m *StandingsMutation) AddRank(i int) {
	if m.addrank != nil {
		*m.addrank += i
	} else {
		m.addrank = &i
	}
}

// AddedRank returns the value that was added to the "rank" field in this mutation.
func (m *StandingsMutation) AddedRank() (r int, exists bool) {
	v := m.addrank
	if v == nil {
		return
	}
	return *v, true
}

// ResetRank resets all changes to the "rank" field.
func (m *StandingsMutation) ResetRank() {
	m.rank = nil
	m.addrank = nil
}

// SetPoints sets the "points" field.
func (m *StandingsMutation) SetPoints(i int) {
	m.points = &i
	m.addpoints = nil
}

// Points returns the value of the "points" field in the mutation.
func (m *StandingsMutation) Points() (r int, exists bool) {
	v := m.points
	if v == nil {
		return
	}
	return *v, true
}

// OldPoints returns the old "points" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldPoints(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoints: %w", err)
	}
	return oldValue.Points, nil
}

// AddPoints adds i to the "points" field.
func (m *StandingsMutation) AddPoints(i int) {
	if m.addpoints != nil {
		*m.addpoints += i
	} else {
		m.addpoints = &i
	}
}

// AddedPoints returns the value that was added to the "points" field in this mutation.
func (m *StandingsMutation) AddedPoints() (r int, exists bool) {
	v := m.addpoints
	if v == nil {
		return
	}
	return *v, true
}

// ResetPoints resets all changes to the "points" field.
func (m *StandingsMutation) ResetPoints() {
	m.points = nil
	m.addpoints = nil
}

// SetGoalsDiff sets the "goalsDiff" field.
func (m *StandingsMutation) SetGoalsDiff(i int) {
	m.goalsDiff = &i
	m.addgoalsDiff = nil
}

// GoalsDiff returns the value of the "goalsDiff" field in the mutation.
func (m *StandingsMutation) GoalsDiff() (r int, exists bool) {
	v := m.goalsDiff
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsDiff returns the old "goalsDiff" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldGoalsDiff(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsDiff is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsDiff requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsDiff: %w", err)
	}
	return oldValue.GoalsDiff, nil
}

// AddGoalsDiff adds i to the "goalsDiff" field.
func (m *StandingsMutation) AddGoalsDiff(i int) {
	if m.addgoalsDiff != nil {
		*m.addgoalsDiff += i
	} else {
		m.addgoalsDiff = &i
	}
}

// AddedGoalsDiff returns the value that was added to the "goalsDiff" field in this mutation.
func (m *StandingsMutation) AddedGoalsDiff() (r int, exists bool) {
	v := m.addgoalsDiff
	if v == nil {
		return
	}
	return *v, true
}

// ResetGoalsDiff resets all changes to the "goalsDiff" field.
func (m *StandingsMutation) ResetGoalsDiff() {
	m.goalsDiff = nil
	m.addgoalsDiff = nil
}

// SetGroup sets the "group" field.
func (m *StandingsMutation) SetGroup(s string) {
	m.group = &s
}

// Group returns the value of the "group" field in the mutation.
func (m *StandingsMutation) Group() (r string, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroup returns the old "group" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldGroup(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroup: %w", err)
	}
	return oldValue.Group, nil
}

// ResetGroup resets all changes to the "group" field.
func (m *StandingsMutation) ResetGroup() {
	m.group = nil
}

// SetForm sets the "form" field.
func (m *StandingsMutation) SetForm(s string) {
	m.form = &s
}

// Form returns the value of the "form" field in the mutation.
func (m *StandingsMutation) Form() (r string, exists bool) {
	v := m.form
	if v == nil {
		return
	}
	return *v, true
}

// OldForm returns the old "form" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldForm(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForm: %w", err)
	}
	return oldValue.Form, nil
}

// ResetForm resets all changes to the "form" field.
func (m *StandingsMutation) ResetForm() {
	m.form = nil
}

// SetStatus sets the "status" field.
func (m *StandingsMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *StandingsMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *StandingsMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[standings.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *StandingsMutation) StatusCleared() bool {
	_, ok := m.clearedFields[standings.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *StandingsMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, standings.FieldStatus)
}

// SetDescription sets the "description" field.
func (m *StandingsMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *StandingsMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *StandingsMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[standings.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *StandingsMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[standings.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *StandingsMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, standings.FieldDescription)
}

// SetAllPlayed sets the "allPlayed" field.
func (m *StandingsMutation) SetAllPlayed(i int) {
	m.allPlayed = &i
	m.addallPlayed = nil
}

// AllPlayed returns the value of the "allPlayed" field in the mutation.
func (m *StandingsMutation) AllPlayed() (r int, exists bool) {
	v := m.allPlayed
	if v == nil {
		return
	}
	return *v, true
}

// OldAllPlayed returns the old "allPlayed" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldAllPlayed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllPlayed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllPlayed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllPlayed: %w", err)
	}
	return oldValue.AllPlayed, nil
}

// AddAllPlayed adds i to the "allPlayed" field.
func (m *StandingsMutation) AddAllPlayed(i int) {
	if m.addallPlayed != nil {
		*m.addallPlayed += i
	} else {
		m.addallPlayed = &i
	}
}

// AddedAllPlayed returns the value that was added to the "allPlayed" field in this mutation.
func (m *StandingsMutation) AddedAllPlayed() (r int, exists bool) {
	v := m.addallPlayed
	if v == nil {
		return
	}
	return *v, true
}

// ResetAllPlayed resets all changes to the "allPlayed" field.
func (m *StandingsMutation) ResetAllPlayed() {
	m.allPlayed = nil
	m.addallPlayed = nil
}

// SetAllWin sets the "allWin" field.
func (m *StandingsMutation) SetAllWin(i int) {
	m.allWin = &i
	m.addallWin = nil
}

// AllWin returns the value of the "allWin" field in the mutation.
func (m *StandingsMutation) AllWin() (r int, exists bool) {
	v := m.allWin
	if v == nil {
		return
	}
	return *v, true
}

// OldAllWin returns the old "allWin" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldAllWin(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllWin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllWin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllWin: %w", err)
	}
	return oldValue.AllWin, nil
}

// AddAllWin adds i to the "allWin" field.
func (m *StandingsMutation) AddAllWin(i int) {
	if m.addallWin != nil {
		*m.addallWin += i
	} else {
		m.addallWin = &i
	}
}

// AddedAllWin returns the value that was added to the "allWin" field in this mutation.
func (m *StandingsMutation) AddedAllWin() (r int, exists bool) {
	v := m.addallWin
	if v == nil {
		return
	}
	return *v, true
}

// ResetAllWin resets all changes to the "allWin" field.
func (m *StandingsMutation) ResetAllWin() {
	m.allWin = nil
	m.addallWin = nil
}

// SetAllDraw sets the "allDraw" field.
func (m *StandingsMutation) SetAllDraw(i int) {
	m.allDraw = &i
	m.addallDraw = nil
}

// AllDraw returns the value of the "allDraw" field in the mutation.
func (m *StandingsMutation) AllDraw() (r int, exists bool) {
	v := m.allDraw
	if v == nil {
		return
	}
	return *v, true
}

// OldAllDraw returns the old "allDraw" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldAllDraw(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllDraw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllDraw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllDraw: %w", err)
	}
	return oldValue.AllDraw, nil
}

// AddAllDraw adds i to the "allDraw" field.
func (m *StandingsMutation) AddAllDraw(i int) {
	if m.addallDraw != nil {
		*m.addallDraw += i
	} else {
		m.addallDraw = &i
	}
}

// AddedAllDraw returns the value that was added to the "allDraw" field in this mutation.
func (m *StandingsMutation) AddedAllDraw() (r int, exists bool) {
	v := m.addallDraw
	if v == nil {
		return
	}
	return *v, true
}

// ResetAllDraw resets all changes to the "allDraw" field.
func (m *StandingsMutation) ResetAllDraw() {
	m.allDraw = nil
	m.addallDraw = nil
}

// SetAllLose sets the "allLose" field.
func (m *StandingsMutation) SetAllLose(i int) {
	m.allLose = &i
	m.addallLose = nil
}

// AllLose returns the value of the "allLose" field in the mutation.
func (m *StandingsMutation) AllLose() (r int, exists bool) {
	v := m.allLose
	if v == nil {
		return
	}
	return *v, true
}

// OldAllLose returns the old "allLose" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldAllLose(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllLose is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllLose requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllLose: %w", err)
	}
	return oldValue.AllLose, nil
}

// AddAllLose adds i to the "allLose" field.
func (m *StandingsMutation) AddAllLose(i int) {
	if m.addallLose != nil {
		*m.addallLose += i
	} else {
		m.addallLose = &i
	}
}

// AddedAllLose returns the value that was added to the "allLose" field in this mutation.
func (m *StandingsMutation) AddedAllLose() (r int, exists bool) {
	v := m.addallLose
	if v == nil {
		return
	}
	return *v, true
}

// ResetAllLose resets all changes to the "allLose" field.
func (m *StandingsMutation) ResetAllLose() {
	m.allLose = nil
	m.addallLose = nil
}

// SetAllGoalsFor sets the "allGoalsFor" field.
func (m *StandingsMutation) SetAllGoalsFor(i int) {
	m.allGoalsFor = &i
	m.addallGoalsFor = nil
}

// AllGoalsFor returns the value of the "allGoalsFor" field in the mutation.
func (m *StandingsMutation) AllGoalsFor() (r int, exists bool) {
	v := m.allGoalsFor
	if v == nil {
		return
	}
	return *v, true
}

// OldAllGoalsFor returns the old "allGoalsFor" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldAllGoalsFor(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllGoalsFor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllGoalsFor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllGoalsFor: %w", err)
	}
	return oldValue.AllGoalsFor, nil
}

// AddAllGoalsFor adds i to the "allGoalsFor" field.
func (m *StandingsMutation) AddAllGoalsFor(i int) {
	if m.addallGoalsFor != nil {
		*m.addallGoalsFor += i
	} else {
		m.addallGoalsFor = &i
	}
}

// AddedAllGoalsFor returns the value that was added to the "allGoalsFor" field in this mutation.
func (m *StandingsMutation) AddedAllGoalsFor() (r int, exists bool) {
	v := m.addallGoalsFor
	if v == nil {
		return
	}
	return *v, true
}

// ResetAllGoalsFor resets all changes to the "allGoalsFor" field.
func (m *StandingsMutation) ResetAllGoalsFor() {
	m.allGoalsFor = nil
	m.addallGoalsFor = nil
}

// SetAllGoalsAgainst sets the "allGoalsAgainst" field.
func (m *StandingsMutation) SetAllGoalsAgainst(i int) {
	m.allGoalsAgainst = &i
	m.addallGoalsAgainst = nil
}

// AllGoalsAgainst returns the value of the "allGoalsAgainst" field in the mutation.
func (m *StandingsMutation) AllGoalsAgainst() (r int, exists bool) {
	v := m.allGoalsAgainst
	if v == nil {
		return
	}
	return *v, true
}

// OldAllGoalsAgainst returns the old "allGoalsAgainst" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldAllGoalsAgainst(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllGoalsAgainst is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllGoalsAgainst requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllGoalsAgainst: %w", err)
	}
	return oldValue.AllGoalsAgainst, nil
}

// AddAllGoalsAgainst adds i to the "allGoalsAgainst" field.
func (m *StandingsMutation) AddAllGoalsAgainst(i int) {
	if m.addallGoalsAgainst != nil {
		*m.addallGoalsAgainst += i
	} else {
		m.addallGoalsAgainst = &i
	}
}

// AddedAllGoalsAgainst returns the value that was added to the "allGoalsAgainst" field in this mutation.
func (m *StandingsMutation) AddedAllGoalsAgainst() (r int, exists bool) {
	v := m.addallGoalsAgainst
	if v == nil {
		return
	}
	return *v, true
}

// ResetAllGoalsAgainst resets all changes to the "allGoalsAgainst" field.
func (m *StandingsMutation) ResetAllGoalsAgainst() {
	m.allGoalsAgainst = nil
	m.addallGoalsAgainst = nil
}

// SetHomePlayed sets the "homePlayed" field.
func (m *StandingsMutation) SetHomePlayed(i int) {
	m.homePlayed = &i
	m.addhomePlayed = nil
}

// HomePlayed returns the value of the "homePlayed" field in the mutation.
func (m *StandingsMutation) HomePlayed() (r int, exists bool) {
	v := m.homePlayed
	if v == nil {
		return
	}
	return *v, true
}

// OldHomePlayed returns the old "homePlayed" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldHomePlayed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomePlayed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomePlayed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomePlayed: %w", err)
	}
	return oldValue.HomePlayed, nil
}

// AddHomePlayed adds i to the "homePlayed" field.
func (m *StandingsMutation) AddHomePlayed(i int) {
	if m.addhomePlayed != nil {
		*m.addhomePlayed += i
	} else {
		m.addhomePlayed = &i
	}
}

// AddedHomePlayed returns the value that was added to the "homePlayed" field in this mutation.
func (m *StandingsMutation) AddedHomePlayed() (r int, exists bool) {
	v := m.addhomePlayed
	if v == nil {
		return
	}
	return *v, true
}

// ResetHomePlayed resets all changes to the "homePlayed" field.
func (m *StandingsMutation) ResetHomePlayed() {
	m.homePlayed = nil
	m.addhomePlayed = nil
}

// SetHomeWin sets the "homeWin" field.
func (m *StandingsMutation) SetHomeWin(i int) {
	m.homeWin = &i
	m.addhomeWin = nil
}

// HomeWin returns the value of the "homeWin" field in the mutation.
func (m *StandingsMutation) HomeWin() (r int, exists bool) {
	v := m.homeWin
	if v == nil {
		return
	}
	return *v, true
}

// OldHomeWin returns the old "homeWin" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldHomeWin(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomeWin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomeWin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomeWin: %w", err)
	}
	return oldValue.HomeWin, nil
}

// AddHomeWin adds i to the "homeWin" field.
func (m *StandingsMutation) AddHomeWin(i int) {
	if m.addhomeWin != nil {
		*m.addhomeWin += i
	} else {
		m.addhomeWin = &i
	}
}

// AddedHomeWin returns the value that was added to the "homeWin" field in this mutation.
func (m *StandingsMutation) AddedHomeWin() (r int, exists bool) {
	v := m.addhomeWin
	if v == nil {
		return
	}
	return *v, true
}

// ResetHomeWin resets all changes to the "homeWin" field.
func (m *StandingsMutation) ResetHomeWin() {
	m.homeWin = nil
	m.addhomeWin = nil
}

// SetHomeDraw sets the "homeDraw" field.
func (m *StandingsMutation) SetHomeDraw(i int) {
	m.homeDraw = &i
	m.addhomeDraw = nil
}

// HomeDraw returns the value of the "homeDraw" field in the mutation.
func (m *StandingsMutation) HomeDraw() (r int, exists bool) {
	v := m.homeDraw
	if v == nil {
		return
	}
	return *v, true
}

// OldHomeDraw returns the old "homeDraw" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldHomeDraw(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomeDraw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomeDraw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomeDraw: %w", err)
	}
	return oldValue.HomeDraw, nil
}

// AddHomeDraw adds i to the "homeDraw" field.
func (m *StandingsMutation) AddHomeDraw(i int) {
	if m.addhomeDraw != nil {
		*m.addhomeDraw += i
	} else {
		m.addhomeDraw = &i
	}
}

// AddedHomeDraw returns the value that was added to the "homeDraw" field in this mutation.
func (m *StandingsMutation) AddedHomeDraw() (r int, exists bool) {
	v := m.addhomeDraw
	if v == nil {
		return
	}
	return *v, true
}

// ResetHomeDraw resets all changes to the "homeDraw" field.
func (m *StandingsMutation) ResetHomeDraw() {
	m.homeDraw = nil
	m.addhomeDraw = nil
}

// SetHomeLose sets the "homeLose" field.
func (m *StandingsMutation) SetHomeLose(i int) {
	m.homeLose = &i
	m.addhomeLose = nil
}

// HomeLose returns the value of the "homeLose" field in the mutation.
func (m *StandingsMutation) HomeLose() (r int, exists bool) {
	v := m.homeLose
	if v == nil {
		return
	}
	return *v, true
}

// OldHomeLose returns the old "homeLose" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldHomeLose(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomeLose is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomeLose requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomeLose: %w", err)
	}
	return oldValue.HomeLose, nil
}

// AddHomeLose adds i to the "homeLose" field.
func (m *StandingsMutation) AddHomeLose(i int) {
	if m.addhomeLose != nil {
		*m.addhomeLose += i
	} else {
		m.addhomeLose = &i
	}
}

// AddedHomeLose returns the value that was added to the "homeLose" field in this mutation.
func (m *StandingsMutation) AddedHomeLose() (r int, exists bool) {
	v := m.addhomeLose
	if v == nil {
		return
	}
	return *v, true
}

// ResetHomeLose resets all changes to the "homeLose" field.
func (m *StandingsMutation) ResetHomeLose() {
	m.homeLose = nil
	m.addhomeLose = nil
}

// SetHomeGoalsFor sets the "homeGoalsFor" field.
func (m *StandingsMutation) SetHomeGoalsFor(i int) {
	m.homeGoalsFor = &i
	m.addhomeGoalsFor = nil
}

// HomeGoalsFor returns the value of the "homeGoalsFor" field in the mutation.
func (m *StandingsMutation) HomeGoalsFor() (r int, exists bool) {
	v := m.homeGoalsFor
	if v == nil {
		return
	}
	return *v, true
}

// OldHomeGoalsFor returns the old "homeGoalsFor" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldHomeGoalsFor(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomeGoalsFor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomeGoalsFor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomeGoalsFor: %w", err)
	}
	return oldValue.HomeGoalsFor, nil
}

// AddHomeGoalsFor adds i to the "homeGoalsFor" field.
func (m *StandingsMutation) AddHomeGoalsFor(i int) {
	if m.addhomeGoalsFor != nil {
		*m.addhomeGoalsFor += i
	} else {
		m.addhomeGoalsFor = &i
	}
}

// AddedHomeGoalsFor returns the value that was added to the "homeGoalsFor" field in this mutation.
func (m *StandingsMutation) AddedHomeGoalsFor() (r int, exists bool) {
	v := m.addhomeGoalsFor
	if v == nil {
		return
	}
	return *v, true
}

// ResetHomeGoalsFor resets all changes to the "homeGoalsFor" field.
func (m *StandingsMutation) ResetHomeGoalsFor() {
	m.homeGoalsFor = nil
	m.addhomeGoalsFor = nil
}

// SetHomeGoalsAgainst sets the "homeGoalsAgainst" field.
func (m *StandingsMutation) SetHomeGoalsAgainst(i int) {
	m.homeGoalsAgainst = &i
	m.addhomeGoalsAgainst = nil
}

// HomeGoalsAgainst returns the value of the "homeGoalsAgainst" field in the mutation.
func (m *StandingsMutation) HomeGoalsAgainst() (r int, exists bool) {
	v := m.homeGoalsAgainst
	if v == nil {
		return
	}
	return *v, true
}

// OldHomeGoalsAgainst returns the old "homeGoalsAgainst" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldHomeGoalsAgainst(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomeGoalsAgainst is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomeGoalsAgainst requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomeGoalsAgainst: %w", err)
	}
	return oldValue.HomeGoalsAgainst, nil
}

// AddHomeGoalsAgainst adds i to the "homeGoalsAgainst" field.
func (m *StandingsMutation) AddHomeGoalsAgainst(i int) {
	if m.addhomeGoalsAgainst != nil {
		*m.addhomeGoalsAgainst += i
	} else {
		m.addhomeGoalsAgainst = &i
	}
}

// AddedHomeGoalsAgainst returns the value that was added to the "homeGoalsAgainst" field in this mutation.
func (m *StandingsMutation) AddedHomeGoalsAgainst() (r int, exists bool) {
	v := m.addhomeGoalsAgainst
	if v == nil {
		return
	}
	return *v, true
}

// ResetHomeGoalsAgainst resets all changes to the "homeGoalsAgainst" field.
func (m *StandingsMutation) ResetHomeGoalsAgainst() {
	m.homeGoalsAgainst = nil
	m.addhomeGoalsAgainst = nil
}

// SetAwayPlayed sets the "awayPlayed" field.
func (m *StandingsMutation) SetAwayPlayed(i int) {
	m.awayPlayed = &i
	m.addawayPlayed = nil
}

// AwayPlayed returns the value of the "awayPlayed" field in the mutation.
func (m *StandingsMutation) AwayPlayed() (r int, exists bool) {
	v := m.awayPlayed
	if v == nil {
		return
	}
	return *v, true
}

// OldAwayPlayed returns the old "awayPlayed" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldAwayPlayed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAwayPlayed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAwayPlayed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAwayPlayed: %w", err)
	}
	return oldValue.AwayPlayed, nil
}

// AddAwayPlayed adds i to the "awayPlayed" field.
func (m *StandingsMutation) AddAwayPlayed(i int) {
	if m.addawayPlayed != nil {
		*m.addawayPlayed += i
	} else {
		m.addawayPlayed = &i
	}
}

// AddedAwayPlayed returns the value that was added to the "awayPlayed" field in this mutation.
func (m *StandingsMutation) AddedAwayPlayed() (r int, exists bool) {
	v := m.addawayPlayed
	if v == nil {
		return
	}
	return *v, true
}

// ResetAwayPlayed resets all changes to the "awayPlayed" field.
func (m *StandingsMutation) ResetAwayPlayed() {
	m.awayPlayed = nil
	m.addawayPlayed = nil
}

// SetAwayWin sets the "awayWin" field.
func (m *StandingsMutation) SetAwayWin(i int) {
	m.awayWin = &i
	m.addawayWin = nil
}

// AwayWin returns the value of the "awayWin" field in the mutation.
func (m *StandingsMutation) AwayWin() (r int, exists bool) {
	v := m.awayWin
	if v == nil {
		return
	}
	return *v, true
}

// OldAwayWin returns the old "awayWin" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldAwayWin(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAwayWin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAwayWin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAwayWin: %w", err)
	}
	return oldValue.AwayWin, nil
}

// AddAwayWin adds i to the "awayWin" field.
func (m *StandingsMutation) AddAwayWin(i int) {
	if m.addawayWin != nil {
		*m.addawayWin += i
	} else {
		m.addawayWin = &i
	}
}

// AddedAwayWin returns the value that was added to the "awayWin" field in this mutation.
func (m *StandingsMutation) AddedAwayWin() (r int, exists bool) {
	v := m.addawayWin
	if v == nil {
		return
	}
	return *v, true
}

// ResetAwayWin resets all changes to the "awayWin" field.
func (m *StandingsMutation) ResetAwayWin() {
	m.awayWin = nil
	m.addawayWin = nil
}

// SetAwayDraw sets the "awayDraw" field.
func (m *StandingsMutation) SetAwayDraw(i int) {
	m.awayDraw = &i
	m.addawayDraw = nil
}

// AwayDraw returns the value of the "awayDraw" field in the mutation.
func (m *StandingsMutation) AwayDraw() (r int, exists bool) {
	v := m.awayDraw
	if v == nil {
		return
	}
	return *v, true
}

// OldAwayDraw returns the old "awayDraw" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldAwayDraw(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAwayDraw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAwayDraw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAwayDraw: %w", err)
	}
	return oldValue.AwayDraw, nil
}

// AddAwayDraw adds i to the "awayDraw" field.
func (m *StandingsMutation) AddAwayDraw(i int) {
	if m.addawayDraw != nil {
		*m.addawayDraw += i
	} else {
		m.addawayDraw = &i
	}
}

// AddedAwayDraw returns the value that was added to the "awayDraw" field in this mutation.
func (m *StandingsMutation) AddedAwayDraw() (r int, exists bool) {
	v := m.addawayDraw
	if v == nil {
		return
	}
	return *v, true
}

// ResetAwayDraw resets all changes to the "awayDraw" field.
func (m *StandingsMutation) ResetAwayDraw() {
	m.awayDraw = nil
	m.addawayDraw = nil
}

// SetAwayLose sets the "awayLose" field.
func (m *StandingsMutation) SetAwayLose(i int) {
	m.awayLose = &i
	m.addawayLose = nil
}

// AwayLose returns the value of the "awayLose" field in the mutation.
func (m *StandingsMutation) AwayLose() (r int, exists bool) {
	v := m.awayLose
	if v == nil {
		return
	}
	return *v, true
}

// OldAwayLose returns the old "awayLose" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldAwayLose(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAwayLose is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAwayLose requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAwayLose: %w", err)
	}
	return oldValue.AwayLose, nil
}

// AddAwayLose adds i to the "awayLose" field.
func (m *StandingsMutation) AddAwayLose(i int) {
	if m.addawayLose != nil {
		*m.addawayLose += i
	} else {
		m.addawayLose = &i
	}
}

// AddedAwayLose returns the value that was added to the "awayLose" field in this mutation.
func (m *StandingsMutation) AddedAwayLose() (r int, exists bool) {
	v := m.addawayLose
	if v == nil {
		return
	}
	return *v, true
}

// ResetAwayLose resets all changes to the "awayLose" field.
func (m *StandingsMutation) ResetAwayLose() {
	m.awayLose = nil
	m.addawayLose = nil
}

// SetAwayGoalsFor sets the "awayGoalsFor" field.
func (m *StandingsMutation) SetAwayGoalsFor(i int) {
	m.awayGoalsFor = &i
	m.addawayGoalsFor = nil
}

// AwayGoalsFor returns the value of the "awayGoalsFor" field in the mutation.
func (m *StandingsMutation) AwayGoalsFor() (r int, exists bool) {
	v := m.awayGoalsFor
	if v == nil {
		return
	}
	return *v, true
}

// OldAwayGoalsFor returns the old "awayGoalsFor" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldAwayGoalsFor(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAwayGoalsFor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAwayGoalsFor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAwayGoalsFor: %w", err)
	}
	return oldValue.AwayGoalsFor, nil
}

// AddAwayGoalsFor adds i to the "awayGoalsFor" field.
func (m *StandingsMutation) AddAwayGoalsFor(i int) {
	if m.addawayGoalsFor != nil {
		*m.addawayGoalsFor += i
	} else {
		m.addawayGoalsFor = &i
	}
}

// AddedAwayGoalsFor returns the value that was added to the "awayGoalsFor" field in this mutation.
func (m *StandingsMutation) AddedAwayGoalsFor() (r int, exists bool) {
	v := m.addawayGoalsFor
	if v == nil {
		return
	}
	return *v, true
}

// ResetAwayGoalsFor resets all changes to the "awayGoalsFor" field.
func (m *StandingsMutation) ResetAwayGoalsFor() {
	m.awayGoalsFor = nil
	m.addawayGoalsFor = nil
}

// SetAwayGoalsAgainst sets the "awayGoalsAgainst" field.
func (m *StandingsMutation) SetAwayGoalsAgainst(i int) {
	m.awayGoalsAgainst = &i
	m.addawayGoalsAgainst = nil
}

// AwayGoalsAgainst returns the value of the "awayGoalsAgainst" field in the mutation.
func (m *StandingsMutation) AwayGoalsAgainst() (r int, exists bool) {
	v := m.awayGoalsAgainst
	if v == nil {
		return
	}
	return *v, true
}

// OldAwayGoalsAgainst returns the old "awayGoalsAgainst" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldAwayGoalsAgainst(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAwayGoalsAgainst is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAwayGoalsAgainst requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAwayGoalsAgainst: %w", err)
	}
	return oldValue.AwayGoalsAgainst, nil
}

// AddAwayGoalsAgainst adds i to the "awayGoalsAgainst" field.
func (m *StandingsMutation) AddAwayGoalsAgainst(i int) {
	if m.addawayGoalsAgainst != nil {
		*m.addawayGoalsAgainst += i
	} else {
		m.addawayGoalsAgainst = &i
	}
}

// AddedAwayGoalsAgainst returns the value that was added to the "awayGoalsAgainst" field in this mutation.
func (m *StandingsMutation) AddedAwayGoalsAgainst() (r int, exists bool) {
	v := m.addawayGoalsAgainst
	if v == nil {
		return
	}
	return *v, true
}

// ResetAwayGoalsAgainst resets all changes to the "awayGoalsAgainst" field.
func (m *StandingsMutation) ResetAwayGoalsAgainst() {
	m.awayGoalsAgainst = nil
	m.addawayGoalsAgainst = nil
}

// SetLastUpdated sets the "LastUpdated" field.
func (m *StandingsMutation) SetLastUpdated(t time.Time) {
	m._LastUpdated = &t
}

// LastUpdated returns the value of the "LastUpdated" field in the mutation.
func (m *StandingsMutation) LastUpdated() (r time.Time, exists bool) {
	v := m._LastUpdated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "LastUpdated" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ResetLastUpdated resets all changes to the "LastUpdated" field.
func (m *StandingsMutation) ResetLastUpdated() {
	m._LastUpdated = nil
}

// SetTeamID sets the "team" edge to the Team entity by id.
func (m *StandingsMutation) SetTeamID(id int) {
	m.team = &id
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *StandingsMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *StandingsMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamID returns the "team" edge ID in the mutation.
func (m *StandingsMutation) TeamID() (id int, exists bool) {
	if m.team != nil {
		return *m.team, true
	}
	return
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *StandingsMutation) TeamIDs() (ids []int) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *StandingsMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// SetSeasonID sets the "season" edge to the Season entity by id.
func (m *StandingsMutation) SetSeasonID(id int) {
	m.season = &id
}

// ClearSeason clears the "season" edge to the Season entity.
func (m *StandingsMutation) ClearSeason() {
	m.clearedseason = true
}

// SeasonCleared reports if the "season" edge to the Season entity was cleared.
func (m *StandingsMutation) SeasonCleared() bool {
	return m.clearedseason
}

// SeasonID returns the "season" edge ID in the mutation.
func (m *StandingsMutation) SeasonID() (id int, exists bool) {
	if m.season != nil {
		return *m.season, true
	}
	return
}

// SeasonIDs returns the "season" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SeasonID instead. It exists only for internal usage by the builders.
func (m *StandingsMutation) SeasonIDs() (ids []int) {
	if id := m.season; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSeason resets all changes to the "season" edge.
func (m *StandingsMutation) ResetSeason() {
	m.season = nil
	m.clearedseason = false
}

// Where appends a list predicates to the StandingsMutation builder.
func (m *StandingsMutation) Where(ps ...predicate.Standings) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StandingsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StandingsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Standings, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StandingsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StandingsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Standings).
func (m *StandingsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StandingsMutation) Fields() []string {
	fields := make([]string, 0, 26)
	if m.rank != nil {
		fields = append(fields, standings.FieldRank)
	}
	if m.points != nil {
		fields = append(fields, standings.FieldPoints)
	}
	if m.goalsDiff != nil {
		fields = append(fields, standings.FieldGoalsDiff)
	}
	if m.group != nil {
		fields = append(fields, standings.FieldGroup)
	}
	if m.form != nil {
		fields = append(fields, standings.FieldForm)
	}
	if m.status != nil {
		fields = append(fields, standings.FieldStatus)
	}
	if m.description != nil {
		fields = append(fields, standings.FieldDescription)
	}
	if m.allPlayed != nil {
		fields = append(fields, standings.FieldAllPlayed)
	}
	if m.allWin != nil {
		fields = append(fields, standings.FieldAllWin)
	}
	if m.allDraw != nil {
		fields = append(fields, standings.FieldAllDraw)
	}
	if m.allLose != nil {
		fields = append(fields, standings.FieldAllLose)
	}
	if m.allGoalsFor != nil {
		fields = append(fields, standings.FieldAllGoalsFor)
	}
	if m.allGoalsAgainst != nil {
		fields = append(fields, standings.FieldAllGoalsAgainst)
	}
	if m.homePlayed != nil {
		fields = append(fields, standings.FieldHomePlayed)
	}
	if m.homeWin != nil {
		fields = append(fields, standings.FieldHomeWin)
	}
	if m.homeDraw != nil {
		fields = append(fields, standings.FieldHomeDraw)
	}
	if m.homeLose != nil {
		fields = append(fields, standings.FieldHomeLose)
	}
	if m.homeGoalsFor != nil {
		fields = append(fields, standings.FieldHomeGoalsFor)
	}
	if m.homeGoalsAgainst != nil {
		fields = append(fields, standings.FieldHomeGoalsAgainst)
	}
	if m.awayPlayed != nil {
		fields = append(fields, standings.FieldAwayPlayed)
	}
	if m.awayWin != nil {
		fields = append(fields, standings.FieldAwayWin)
	}
	if m.awayDraw != nil {
		fields = append(fields, standings.FieldAwayDraw)
	}
	if m.awayLose != nil {
		fields = append(fields, standings.FieldAwayLose)
	}
	if m.awayGoalsFor != nil {
		fields = append(fields, standings.FieldAwayGoalsFor)
	}
	if m.awayGoalsAgainst != nil {
		fields = append(fields, standings.FieldAwayGoalsAgainst)
	}
	if m._LastUpdated != nil {
		fields = append(fields, standings.FieldLastUpdated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StandingsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case standings.FieldRank:
		return m.Rank()
	case standings.FieldPoints:
		return m.Points()
	case standings.FieldGoalsDiff:
		return m.GoalsDiff()
	case standings.FieldGroup:
		return m.Group()
	case standings.FieldForm:
		return m.Form()
	case standings.FieldStatus:
		return m.Status()
	case standings.FieldDescription:
		return m.Description()
	case standings.FieldAllPlayed:
		return m.AllPlayed()
	case standings.FieldAllWin:
		return m.AllWin()
	case standings.FieldAllDraw:
		return m.AllDraw()
	case standings.FieldAllLose:
		return m.AllLose()
	case standings.FieldAllGoalsFor:
		return m.AllGoalsFor()
	case standings.FieldAllGoalsAgainst:
		return m.AllGoalsAgainst()
	case standings.FieldHomePlayed:
		return m.HomePlayed()
	case standings.FieldHomeWin:
		return m.HomeWin()
	case standings.FieldHomeDraw:
		return m.HomeDraw()
	case standings.FieldHomeLose:
		return m.HomeLose()
	case standings.FieldHomeGoalsFor:
		return m.HomeGoalsFor()
	case standings.FieldHomeGoalsAgainst:
		return m.HomeGoalsAgainst()
	case standings.FieldAwayPlayed:
		return m.AwayPlayed()
	case standings.FieldAwayWin:
		return m.AwayWin()
	case standings.FieldAwayDraw:
		return m.AwayDraw()
	case standings.FieldAwayLose:
		return m.AwayLose()
	case standings.FieldAwayGoalsFor:
		return m.AwayGoalsFor()
	case standings.FieldAwayGoalsAgainst:
		return m.AwayGoalsAgainst()
	case standings.FieldLastUpdated:
		return m.LastUpdated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StandingsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case standings.FieldRank:
		return m.OldRank(ctx)
	case standings.FieldPoints:
		return m.OldPoints(ctx)
	case standings.FieldGoalsDiff:
		return m.OldGoalsDiff(ctx)
	case standings.FieldGroup:
		return m.OldGroup(ctx)
	case standings.FieldForm:
		return m.OldForm(ctx)
	case standings.FieldStatus:
		return m.OldStatus(ctx)
	case standings.FieldDescription:
		return m.OldDescription(ctx)
	case standings.FieldAllPlayed:
		return m.OldAllPlayed(ctx)
	case standings.FieldAllWin:
		return m.OldAllWin(ctx)
	case standings.FieldAllDraw:
		return m.OldAllDraw(ctx)
	case standings.FieldAllLose:
		return m.OldAllLose(ctx)
	case standings.FieldAllGoalsFor:
		return m.OldAllGoalsFor(ctx)
	case standings.FieldAllGoalsAgainst:
		return m.OldAllGoalsAgainst(ctx)
	case standings.FieldHomePlayed:
		return m.OldHomePlayed(ctx)
	case standings.FieldHomeWin:
		return m.OldHomeWin(ctx)
	case standings.FieldHomeDraw:
		return m.OldHomeDraw(ctx)
	case standings.FieldHomeLose:
		return m.OldHomeLose(ctx)
	case standings.FieldHomeGoalsFor:
		return m.OldHomeGoalsFor(ctx)
	case standings.FieldHomeGoalsAgainst:
		return m.OldHomeGoalsAgainst(ctx)
	case standings.FieldAwayPlayed:
		return m.OldAwayPlayed(ctx)
	case standings.FieldAwayWin:
		return m.OldAwayWin(ctx)
	case standings.FieldAwayDraw:
		return m.OldAwayDraw(ctx)
	case standings.FieldAwayLose:
		return m.OldAwayLose(ctx)
	case standings.FieldAwayGoalsFor:
		return m.OldAwayGoalsFor(ctx)
	case standings.FieldAwayGoalsAgainst:
		return m.OldAwayGoalsAgainst(ctx)
	case standings.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	}
	return nil, fmt.Errorf("unknown Standings field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StandingsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case standings.FieldRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRank(v)
		return nil
	case standings.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoints(v)
		return nil
	case standings.FieldGoalsDiff:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsDiff(v)
		return nil
	case standings.FieldGroup:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroup(v)
		return nil
	case standings.FieldForm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForm(v)
		return nil
	case standings.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case standings.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case standings.FieldAllPlayed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllPlayed(v)
		return nil
	case standings.FieldAllWin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllWin(v)
		return nil
	case standings.FieldAllDraw:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllDraw(v)
		return nil
	case standings.FieldAllLose:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllLose(v)
		return nil
	case standings.FieldAllGoalsFor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllGoalsFor(v)
		return nil
	case standings.FieldAllGoalsAgainst:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllGoalsAgainst(v)
		return nil
	case standings.FieldHomePlayed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomePlayed(v)
		return nil
	case standings.FieldHomeWin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomeWin(v)
		return nil
	case standings.FieldHomeDraw:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomeDraw(v)
		return nil
	case standings.FieldHomeLose:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomeLose(v)
		return nil
	case standings.FieldHomeGoalsFor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomeGoalsFor(v)
		return nil
	case standings.FieldHomeGoalsAgainst:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomeGoalsAgainst(v)
		return nil
	case standings.FieldAwayPlayed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAwayPlayed(v)
		return nil
	case standings.FieldAwayWin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAwayWin(v)
		return nil
	case standings.FieldAwayDraw:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAwayDraw(v)
		return nil
	case standings.FieldAwayLose:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAwayLose(v)
		return nil
	case standings.FieldAwayGoalsFor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAwayGoalsFor(v)
		return nil
	case standings.FieldAwayGoalsAgainst:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAwayGoalsAgainst(v)
		return nil
	case standings.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	}
	return fmt.Errorf("unknown Standings field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StandingsMutation) AddedFields() []string {
	var fields []string
	if m.addrank != nil {
		fields = append(fields, standings.FieldRank)
	}
	if m.addpoints != nil {
		fields = append(fields, standings.FieldPoints)
	}
	if m.addgoalsDiff != nil {
		fields = append(fields, standings.FieldGoalsDiff)
	}
	if m.addallPlayed != nil {
		fields = append(fields, standings.FieldAllPlayed)
	}
	if m.addallWin != nil {
		fields = append(fields, standings.FieldAllWin)
	}
	if m.addallDraw != nil {
		fields = append(fields, standings.FieldAllDraw)
	}
	if m.addallLose != nil {
		fields = append(fields, standings.FieldAllLose)
	}
	if m.addallGoalsFor != nil {
		fields = append(fields, standings.FieldAllGoalsFor)
	}
	if m.addallGoalsAgainst != nil {
		fields = append(fields, standings.FieldAllGoalsAgainst)
	}
	if m.addhomePlayed != nil {
		fields = append(fields, standings.FieldHomePlayed)
	}
	if m.addhomeWin != nil {
		fields = append(fields, standings.FieldHomeWin)
	}
	if m.addhomeDraw != nil {
		fields = append(fields, standings.FieldHomeDraw)
	}
	if m.addhomeLose != nil {
		fields = append(fields, standings.FieldHomeLose)
	}
	if m.addhomeGoalsFor != nil {
		fields = append(fields, standings.FieldHomeGoalsFor)
	}
	if m.addhomeGoalsAgainst != nil {
		fields = append(fields, standings.FieldHomeGoalsAgainst)
	}
	if m.addawayPlayed != nil {
		fields = append(fields, standings.FieldAwayPlayed)
	}
	if m.addawayWin != nil {
		fields = append(fields, standings.FieldAwayWin)
	}
	if m.addawayDraw != nil {
		fields = append(fields, standings.FieldAwayDraw)
	}
	if m.addawayLose != nil {
		fields = append(fields, standings.FieldAwayLose)
	}
	if m.addawayGoalsFor != nil {
		fields = append(fields, standings.FieldAwayGoalsFor)
	}
	if m.addawayGoalsAgainst != nil {
		fields = append(fields, standings.FieldAwayGoalsAgainst)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StandingsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case standings.FieldRank:
		return m.AddedRank()
	case standings.FieldPoints:
		return m.AddedPoints()
	case standings.FieldGoalsDiff:
		return m.AddedGoalsDiff()
	case standings.FieldAllPlayed:
		return m.AddedAllPlayed()
	case standings.FieldAllWin:
		return m.AddedAllWin()
	case standings.FieldAllDraw:
		return m.AddedAllDraw()
	case standings.FieldAllLose:
		return m.AddedAllLose()
	case standings.FieldAllGoalsFor:
		return m.AddedAllGoalsFor()
	case standings.FieldAllGoalsAgainst:
		return m.AddedAllGoalsAgainst()
	case standings.FieldHomePlayed:
		return m.AddedHomePlayed()
	case standings.FieldHomeWin:
		return m.AddedHomeWin()
	case standings.FieldHomeDraw:
		return m.AddedHomeDraw()
	case standings.FieldHomeLose:
		return m.AddedHomeLose()
	case standings.FieldHomeGoalsFor:
		return m.AddedHomeGoalsFor()
	case standings.FieldHomeGoalsAgainst:
		return m.AddedHomeGoalsAgainst()
	case standings.FieldAwayPlayed:
		return m.AddedAwayPlayed()
	case standings.FieldAwayWin:
		return m.AddedAwayWin()
	case standings.FieldAwayDraw:
		return m.AddedAwayDraw()
	case standings.FieldAwayLose:
		return m.AddedAwayLose()
	case standings.FieldAwayGoalsFor:
		return m.AddedAwayGoalsFor()
	case standings.FieldAwayGoalsAgainst:
		return m.AddedAwayGoalsAgainst()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StandingsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case standings.FieldRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRank(v)
		return nil
	case standings.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoints(v)
		return nil
	case standings.FieldGoalsDiff:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGoalsDiff(v)
		return nil
	case standings.FieldAllPlayed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAllPlayed(v)
		return nil
	case standings.FieldAllWin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAllWin(v)
		return nil
	case standings.FieldAllDraw:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAllDraw(v)
		return nil
	case standings.FieldAllLose:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAllLose(v)
		return nil
	case standings.FieldAllGoalsFor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAllGoalsFor(v)
		return nil
	case standings.FieldAllGoalsAgainst:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAllGoalsAgainst(v)
		return nil
	case standings.FieldHomePlayed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHomePlayed(v)
		return nil
	case standings.FieldHomeWin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHomeWin(v)
		return nil
	case standings.FieldHomeDraw:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHomeDraw(v)
		return nil
	case standings.FieldHomeLose:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHomeLose(v)
		return nil
	case standings.FieldHomeGoalsFor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHomeGoalsFor(v)
		return nil
	case standings.FieldHomeGoalsAgainst:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHomeGoalsAgainst(v)
		return nil
	case standings.FieldAwayPlayed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAwayPlayed(v)
		return nil
	case standings.FieldAwayWin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAwayWin(v)
		return nil
	case standings.FieldAwayDraw:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAwayDraw(v)
		return nil
	case standings.FieldAwayLose:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAwayLose(v)
		return nil
	case standings.FieldAwayGoalsFor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAwayGoalsFor(v)
		return nil
	case standings.FieldAwayGoalsAgainst:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAwayGoalsAgainst(v)
		return nil
	}
	return fmt.Errorf("unknown Standings numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StandingsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(standings.FieldStatus) {
		fields = append(fields, standings.FieldStatus)
	}
	if m.FieldCleared(standings.FieldDescription) {
		fields = append(fields, standings.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StandingsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StandingsMutation) ClearField(name string) error {
	switch name {
	case standings.FieldStatus:
		m.ClearStatus()
		return nil
	case standings.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Standings nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StandingsMutation) ResetField(name string) error {
	switch name {
	case standings.FieldRank:
		m.ResetRank()
		return nil
	case standings.FieldPoints:
		m.ResetPoints()
		return nil
	case standings.FieldGoalsDiff:
		m.ResetGoalsDiff()
		return nil
	case standings.FieldGroup:
		m.ResetGroup()
		return nil
	case standings.FieldForm:
		m.ResetForm()
		return nil
	case standings.FieldStatus:
		m.ResetStatus()
		return nil
	case standings.FieldDescription:
		m.ResetDescription()
		return nil
	case standings.FieldAllPlayed:
		m.ResetAllPlayed()
		return nil
	case standings.FieldAllWin:
		m.ResetAllWin()
		return nil
	case standings.FieldAllDraw:
		m.ResetAllDraw()
		return nil
	case standings.FieldAllLose:
		m.ResetAllLose()
		return nil
	case standings.FieldAllGoalsFor:
		m.ResetAllGoalsFor()
		return nil
	case standings.FieldAllGoalsAgainst:
		m.ResetAllGoalsAgainst()
		return nil
	case standings.FieldHomePlayed:
		m.ResetHomePlayed()
		return nil
	case standings.FieldHomeWin:
		m.ResetHomeWin()
		return nil
	case standings.FieldHomeDraw:
		m.ResetHomeDraw()
		return nil
	case standings.FieldHomeLose:
		m.ResetHomeLose()
		return nil
	case standings.FieldHomeGoalsFor:
		m.ResetHomeGoalsFor()
		return nil
	case standings.FieldHomeGoalsAgainst:
		m.ResetHomeGoalsAgainst()
		return nil
	case standings.FieldAwayPlayed:
		m.ResetAwayPlayed()
		return nil
	case standings.FieldAwayWin:
		m.ResetAwayWin()
		return nil
	case standings.FieldAwayDraw:
		m.ResetAwayDraw()
		return nil
	case standings.FieldAwayLose:
		m.ResetAwayLose()
		return nil
	case standings.FieldAwayGoalsFor:
		m.ResetAwayGoalsFor()
		return nil
	case standings.FieldAwayGoalsAgainst:
		m.ResetAwayGoalsAgainst()
		return nil
	case standings.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown Standings field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StandingsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.team != nil {
		edges = append(edges, standings.EdgeTeam)
	}
	if m.season != nil {
		edges = append(edges, standings.EdgeSeason)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StandingsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case standings.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	case standings.EdgeSeason:
		if id := m.season; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StandingsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StandingsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StandingsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedteam {
		edges = append(edges, standings.EdgeTeam)
	}
	if m.clearedseason {
		edges = append(edges, standings.EdgeSeason)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StandingsMutation) EdgeCleared(name string) bool {
	switch name {
	case standings.EdgeTeam:
		return m.clearedteam
	case standings.EdgeSeason:
		return m.clearedseason
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StandingsMutation) ClearEdge(name string) error {
	switch name {
	case standings.EdgeTeam:
		m.ClearTeam()
		return nil
	case standings.EdgeSeason:
		m.ClearSeason()
		return nil
	}
	return fmt.Errorf("unknown Standings unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StandingsMutation) ResetEdge(name string) error {
	switch name {
	case standings.EdgeTeam:
		m.ResetTeam()
		return nil
	case standings.EdgeSeason:
		m.ResetSeason()
		return nil
	}
	return fmt.Errorf("unknown Standings edge %s", name)
}

// TeamMutation represents an operation that mutates the Team nodes in the graph.
type TeamMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	slug                *string
	name                *string
	code                *string
	founded             *int
	addfounded          *int
	national            *bool
	logo                *string
	clearedFields       map[string]struct{}
	standings           map[int]struct{}
	removedstandings    map[int]struct{}
	clearedstandings    bool
	country             *int
	clearedcountry      bool
	homeFixtures        map[int]struct{}
	removedhomeFixtures map[int]struct{}
	clearedhomeFixtures bool
	awayFixtures        map[int]struct{}
	removedawayFixtures map[int]struct{}
	clearedawayFixtures bool
	done                bool
	oldValue            func(context.Context) (*Team, error)
	predicates          []predicate.Team
}

var _ ent.Mutation = (*TeamMutation)(nil)

// teamOption allows management of the mutation configuration using functional options.
type teamOption func(*TeamMutation)

// newTeamMutation creates new mutation for the Team entity.
func newTeamMutation(c config, op Op, opts ...teamOption) *TeamMutation {
	m := &TeamMutation{
		config:        c,
		op:            op,
		typ:           TypeTeam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamID sets the ID field of the mutation.
func withTeamID(id int) teamOption {
	return func(m *TeamMutation) {
		var (
			err   error
			once  sync.Once
			value *Team
		)
		m.oldValue = func(ctx context.Context) (*Team, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Team.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeam sets the old Team of the mutation.
func withTeam(node *Team) teamOption {
	return func(m *TeamMutation) {
		m.oldValue = func(context.Context) (*Team, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Team entities.
func (m *TeamMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Team.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSlug sets the "slug" field.
func (m *TeamMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *TeamMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *TeamMutation) ResetSlug() {
	m.slug = nil
}

// SetName sets the "name" field.
func (m *TeamMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TeamMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TeamMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *TeamMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *TeamMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *TeamMutation) ResetCode() {
	m.code = nil
}

// SetFounded sets the "founded" field.
func (m *TeamMutation) SetFounded(i int) {
	m.founded = &i
	m.addfounded = nil
}

// Founded returns the value of the "founded" field in the mutation.
func (m *TeamMutation) Founded() (r int, exists bool) {
	v := m.founded
	if v == nil {
		return
	}
	return *v, true
}

// OldFounded returns the old "founded" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldFounded(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFounded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFounded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFounded: %w", err)
	}
	return oldValue.Founded, nil
}

// AddFounded adds i to the "founded" field.
func (m *TeamMutation) AddFounded(i int) {
	if m.addfounded != nil {
		*m.addfounded += i
	} else {
		m.addfounded = &i
	}
}

// AddedFounded returns the value that was added to the "founded" field in this mutation.
func (m *TeamMutation) AddedFounded() (r int, exists bool) {
	v := m.addfounded
	if v == nil {
		return
	}
	return *v, true
}

// ResetFounded resets all changes to the "founded" field.
func (m *TeamMutation) ResetFounded() {
	m.founded = nil
	m.addfounded = nil
}

// SetNational sets the "national" field.
func (m *TeamMutation) SetNational(b bool) {
	m.national = &b
}

// National returns the value of the "national" field in the mutation.
func (m *TeamMutation) National() (r bool, exists bool) {
	v := m.national
	if v == nil {
		return
	}
	return *v, true
}

// OldNational returns the old "national" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldNational(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNational is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNational requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNational: %w", err)
	}
	return oldValue.National, nil
}

// ResetNational resets all changes to the "national" field.
func (m *TeamMutation) ResetNational() {
	m.national = nil
}

// SetLogo sets the "logo" field.
func (m *TeamMutation) SetLogo(s string) {
	m.logo = &s
}

// Logo returns the value of the "logo" field in the mutation.
func (m *TeamMutation) Logo() (r string, exists bool) {
	v := m.logo
	if v == nil {
		return
	}
	return *v, true
}

// OldLogo returns the old "logo" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldLogo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogo: %w", err)
	}
	return oldValue.Logo, nil
}

// ResetLogo resets all changes to the "logo" field.
func (m *TeamMutation) ResetLogo() {
	m.logo = nil
}

// AddStandingIDs adds the "standings" edge to the Standings entity by ids.
func (m *TeamMutation) AddStandingIDs(ids ...int) {
	if m.standings == nil {
		m.standings = make(map[int]struct{})
	}
	for i := range ids {
		m.standings[ids[i]] = struct{}{}
	}
}

// ClearStandings clears the "standings" edge to the Standings entity.
func (m *TeamMutation) ClearStandings() {
	m.clearedstandings = true
}

// StandingsCleared reports if the "standings" edge to the Standings entity was cleared.
func (m *TeamMutation) StandingsCleared() bool {
	return m.clearedstandings
}

// RemoveStandingIDs removes the "standings" edge to the Standings entity by IDs.
func (m *TeamMutation) RemoveStandingIDs(ids ...int) {
	if m.removedstandings == nil {
		m.removedstandings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.standings, ids[i])
		m.removedstandings[ids[i]] = struct{}{}
	}
}

// RemovedStandings returns the removed IDs of the "standings" edge to the Standings entity.
func (m *TeamMutation) RemovedStandingsIDs() (ids []int) {
	for id := range m.removedstandings {
		ids = append(ids, id)
	}
	return
}

// StandingsIDs returns the "standings" edge IDs in the mutation.
func (m *TeamMutation) StandingsIDs() (ids []int) {
	for id := range m.standings {
		ids = append(ids, id)
	}
	return
}

// ResetStandings resets all changes to the "standings" edge.
func (m *TeamMutation) ResetStandings() {
	m.standings = nil
	m.clearedstandings = false
	m.removedstandings = nil
}

// SetCountryID sets the "country" edge to the Country entity by id.
func (m *TeamMutation) SetCountryID(id int) {
	m.country = &id
}

// ClearCountry clears the "country" edge to the Country entity.
func (m *TeamMutation) ClearCountry() {
	m.clearedcountry = true
}

// CountryCleared reports if the "country" edge to the Country entity was cleared.
func (m *TeamMutation) CountryCleared() bool {
	return m.clearedcountry
}

// CountryID returns the "country" edge ID in the mutation.
func (m *TeamMutation) CountryID() (id int, exists bool) {
	if m.country != nil {
		return *m.country, true
	}
	return
}

// CountryIDs returns the "country" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CountryID instead. It exists only for internal usage by the builders.
func (m *TeamMutation) CountryIDs() (ids []int) {
	if id := m.country; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCountry resets all changes to the "country" edge.
func (m *TeamMutation) ResetCountry() {
	m.country = nil
	m.clearedcountry = false
}

// AddHomeFixtureIDs adds the "homeFixtures" edge to the Fixture entity by ids.
func (m *TeamMutation) AddHomeFixtureIDs(ids ...int) {
	if m.homeFixtures == nil {
		m.homeFixtures = make(map[int]struct{})
	}
	for i := range ids {
		m.homeFixtures[ids[i]] = struct{}{}
	}
}

// ClearHomeFixtures clears the "homeFixtures" edge to the Fixture entity.
func (m *TeamMutation) ClearHomeFixtures() {
	m.clearedhomeFixtures = true
}

// HomeFixturesCleared reports if the "homeFixtures" edge to the Fixture entity was cleared.
func (m *TeamMutation) HomeFixturesCleared() bool {
	return m.clearedhomeFixtures
}

// RemoveHomeFixtureIDs removes the "homeFixtures" edge to the Fixture entity by IDs.
func (m *TeamMutation) RemoveHomeFixtureIDs(ids ...int) {
	if m.removedhomeFixtures == nil {
		m.removedhomeFixtures = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.homeFixtures, ids[i])
		m.removedhomeFixtures[ids[i]] = struct{}{}
	}
}

// RemovedHomeFixtures returns the removed IDs of the "homeFixtures" edge to the Fixture entity.
func (m *TeamMutation) RemovedHomeFixturesIDs() (ids []int) {
	for id := range m.removedhomeFixtures {
		ids = append(ids, id)
	}
	return
}

// HomeFixturesIDs returns the "homeFixtures" edge IDs in the mutation.
func (m *TeamMutation) HomeFixturesIDs() (ids []int) {
	for id := range m.homeFixtures {
		ids = append(ids, id)
	}
	return
}

// ResetHomeFixtures resets all changes to the "homeFixtures" edge.
func (m *TeamMutation) ResetHomeFixtures() {
	m.homeFixtures = nil
	m.clearedhomeFixtures = false
	m.removedhomeFixtures = nil
}

// AddAwayFixtureIDs adds the "awayFixtures" edge to the Fixture entity by ids.
func (m *TeamMutation) AddAwayFixtureIDs(ids ...int) {
	if m.awayFixtures == nil {
		m.awayFixtures = make(map[int]struct{})
	}
	for i := range ids {
		m.awayFixtures[ids[i]] = struct{}{}
	}
}

// ClearAwayFixtures clears the "awayFixtures" edge to the Fixture entity.
func (m *TeamMutation) ClearAwayFixtures() {
	m.clearedawayFixtures = true
}

// AwayFixturesCleared reports if the "awayFixtures" edge to the Fixture entity was cleared.
func (m *TeamMutation) AwayFixturesCleared() bool {
	return m.clearedawayFixtures
}

// RemoveAwayFixtureIDs removes the "awayFixtures" edge to the Fixture entity by IDs.
func (m *TeamMutation) RemoveAwayFixtureIDs(ids ...int) {
	if m.removedawayFixtures == nil {
		m.removedawayFixtures = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.awayFixtures, ids[i])
		m.removedawayFixtures[ids[i]] = struct{}{}
	}
}

// RemovedAwayFixtures returns the removed IDs of the "awayFixtures" edge to the Fixture entity.
func (m *TeamMutation) RemovedAwayFixturesIDs() (ids []int) {
	for id := range m.removedawayFixtures {
		ids = append(ids, id)
	}
	return
}

// AwayFixturesIDs returns the "awayFixtures" edge IDs in the mutation.
func (m *TeamMutation) AwayFixturesIDs() (ids []int) {
	for id := range m.awayFixtures {
		ids = append(ids, id)
	}
	return
}

// ResetAwayFixtures resets all changes to the "awayFixtures" edge.
func (m *TeamMutation) ResetAwayFixtures() {
	m.awayFixtures = nil
	m.clearedawayFixtures = false
	m.removedawayFixtures = nil
}

// Where appends a list predicates to the TeamMutation builder.
func (m *TeamMutation) Where(ps ...predicate.Team) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TeamMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TeamMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Team, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TeamMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TeamMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Team).
func (m *TeamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.slug != nil {
		fields = append(fields, team.FieldSlug)
	}
	if m.name != nil {
		fields = append(fields, team.FieldName)
	}
	if m.code != nil {
		fields = append(fields, team.FieldCode)
	}
	if m.founded != nil {
		fields = append(fields, team.FieldFounded)
	}
	if m.national != nil {
		fields = append(fields, team.FieldNational)
	}
	if m.logo != nil {
		fields = append(fields, team.FieldLogo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case team.FieldSlug:
		return m.Slug()
	case team.FieldName:
		return m.Name()
	case team.FieldCode:
		return m.Code()
	case team.FieldFounded:
		return m.Founded()
	case team.FieldNational:
		return m.National()
	case team.FieldLogo:
		return m.Logo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case team.FieldSlug:
		return m.OldSlug(ctx)
	case team.FieldName:
		return m.OldName(ctx)
	case team.FieldCode:
		return m.OldCode(ctx)
	case team.FieldFounded:
		return m.OldFounded(ctx)
	case team.FieldNational:
		return m.OldNational(ctx)
	case team.FieldLogo:
		return m.OldLogo(ctx)
	}
	return nil, fmt.Errorf("unknown Team field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case team.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case team.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case team.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case team.FieldFounded:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFounded(v)
		return nil
	case team.FieldNational:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNational(v)
		return nil
	case team.FieldLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogo(v)
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamMutation) AddedFields() []string {
	var fields []string
	if m.addfounded != nil {
		fields = append(fields, team.FieldFounded)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case team.FieldFounded:
		return m.AddedFounded()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) AddField(name string, value ent.Value) error {
	switch name {
	case team.FieldFounded:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFounded(v)
		return nil
	}
	return fmt.Errorf("unknown Team numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Team nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamMutation) ResetField(name string) error {
	switch name {
	case team.FieldSlug:
		m.ResetSlug()
		return nil
	case team.FieldName:
		m.ResetName()
		return nil
	case team.FieldCode:
		m.ResetCode()
		return nil
	case team.FieldFounded:
		m.ResetFounded()
		return nil
	case team.FieldNational:
		m.ResetNational()
		return nil
	case team.FieldLogo:
		m.ResetLogo()
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.standings != nil {
		edges = append(edges, team.EdgeStandings)
	}
	if m.country != nil {
		edges = append(edges, team.EdgeCountry)
	}
	if m.homeFixtures != nil {
		edges = append(edges, team.EdgeHomeFixtures)
	}
	if m.awayFixtures != nil {
		edges = append(edges, team.EdgeAwayFixtures)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeStandings:
		ids := make([]ent.Value, 0, len(m.standings))
		for id := range m.standings {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeCountry:
		if id := m.country; id != nil {
			return []ent.Value{*id}
		}
	case team.EdgeHomeFixtures:
		ids := make([]ent.Value, 0, len(m.homeFixtures))
		for id := range m.homeFixtures {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeAwayFixtures:
		ids := make([]ent.Value, 0, len(m.awayFixtures))
		for id := range m.awayFixtures {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedstandings != nil {
		edges = append(edges, team.EdgeStandings)
	}
	if m.removedhomeFixtures != nil {
		edges = append(edges, team.EdgeHomeFixtures)
	}
	if m.removedawayFixtures != nil {
		edges = append(edges, team.EdgeAwayFixtures)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeStandings:
		ids := make([]ent.Value, 0, len(m.removedstandings))
		for id := range m.removedstandings {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeHomeFixtures:
		ids := make([]ent.Value, 0, len(m.removedhomeFixtures))
		for id := range m.removedhomeFixtures {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeAwayFixtures:
		ids := make([]ent.Value, 0, len(m.removedawayFixtures))
		for id := range m.removedawayFixtures {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedstandings {
		edges = append(edges, team.EdgeStandings)
	}
	if m.clearedcountry {
		edges = append(edges, team.EdgeCountry)
	}
	if m.clearedhomeFixtures {
		edges = append(edges, team.EdgeHomeFixtures)
	}
	if m.clearedawayFixtures {
		edges = append(edges, team.EdgeAwayFixtures)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamMutation) EdgeCleared(name string) bool {
	switch name {
	case team.EdgeStandings:
		return m.clearedstandings
	case team.EdgeCountry:
		return m.clearedcountry
	case team.EdgeHomeFixtures:
		return m.clearedhomeFixtures
	case team.EdgeAwayFixtures:
		return m.clearedawayFixtures
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamMutation) ClearEdge(name string) error {
	switch name {
	case team.EdgeCountry:
		m.ClearCountry()
		return nil
	}
	return fmt.Errorf("unknown Team unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamMutation) ResetEdge(name string) error {
	switch name {
	case team.EdgeStandings:
		m.ResetStandings()
		return nil
	case team.EdgeCountry:
		m.ResetCountry()
		return nil
	case team.EdgeHomeFixtures:
		m.ResetHomeFixtures()
		return nil
	case team.EdgeAwayFixtures:
		m.ResetAwayFixtures()
		return nil
	}
	return fmt.Errorf("unknown Team edge %s", name)
}
