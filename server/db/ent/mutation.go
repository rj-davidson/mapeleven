// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"mapeleven/db/ent/birth"
	"mapeleven/db/ent/club"
	"mapeleven/db/ent/coach"
	"mapeleven/db/ent/country"
	"mapeleven/db/ent/fixture"
	"mapeleven/db/ent/fixtureevents"
	"mapeleven/db/ent/fixturelineups"
	"mapeleven/db/ent/league"
	"mapeleven/db/ent/matchplayer"
	"mapeleven/db/ent/player"
	"mapeleven/db/ent/predicate"
	"mapeleven/db/ent/season"
	"mapeleven/db/ent/squad"
	"mapeleven/db/ent/standings"
	"mapeleven/db/ent/team"
	"mapeleven/db/ent/tsbiggest"
	"mapeleven/db/ent/tscards"
	"mapeleven/db/ent/tscleansheet"
	"mapeleven/db/ent/tsfailedtoscore"
	"mapeleven/db/ent/tsfixtures"
	"mapeleven/db/ent/tsgoals"
	"mapeleven/db/ent/tslineups"
	"mapeleven/db/ent/tspenalty"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBirth           = "Birth"
	TypeClub            = "Club"
	TypeCoach           = "Coach"
	TypeCountry         = "Country"
	TypeFixture         = "Fixture"
	TypeFixtureEvents   = "FixtureEvents"
	TypeFixtureLineups  = "FixtureLineups"
	TypeLeague          = "League"
	TypeMatchPlayer     = "MatchPlayer"
	TypePlayer          = "Player"
	TypeSeason          = "Season"
	TypeSquad           = "Squad"
	TypeStandings       = "Standings"
	TypeTSBiggest       = "TSBiggest"
	TypeTSCards         = "TSCards"
	TypeTSCleanSheet    = "TSCleanSheet"
	TypeTSFailedToScore = "TSFailedToScore"
	TypeTSFixtures      = "TSFixtures"
	TypeTSGoals         = "TSGoals"
	TypeTSLineups       = "TSLineups"
	TypeTSPenalty       = "TSPenalty"
	TypeTeam            = "Team"
)

// BirthMutation represents an operation that mutates the Birth nodes in the graph.
type BirthMutation struct {
	config
	op            Op
	typ           string
	id            *int
	date          *time.Time
	place         *string
	country       *string
	clearedFields map[string]struct{}
	player        map[int]struct{}
	removedplayer map[int]struct{}
	clearedplayer bool
	done          bool
	oldValue      func(context.Context) (*Birth, error)
	predicates    []predicate.Birth
}

var _ ent.Mutation = (*BirthMutation)(nil)

// birthOption allows management of the mutation configuration using functional options.
type birthOption func(*BirthMutation)

// newBirthMutation creates new mutation for the Birth entity.
func newBirthMutation(c config, op Op, opts ...birthOption) *BirthMutation {
	m := &BirthMutation{
		config:        c,
		op:            op,
		typ:           TypeBirth,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBirthID sets the ID field of the mutation.
func withBirthID(id int) birthOption {
	return func(m *BirthMutation) {
		var (
			err   error
			once  sync.Once
			value *Birth
		)
		m.oldValue = func(ctx context.Context) (*Birth, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Birth.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBirth sets the old Birth of the mutation.
func withBirth(node *Birth) birthOption {
	return func(m *BirthMutation) {
		m.oldValue = func(context.Context) (*Birth, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BirthMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BirthMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BirthMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BirthMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Birth.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDate sets the "date" field.
func (m *BirthMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *BirthMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Birth entity.
// If the Birth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BirthMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *BirthMutation) ResetDate() {
	m.date = nil
}

// SetPlace sets the "place" field.
func (m *BirthMutation) SetPlace(s string) {
	m.place = &s
}

// Place returns the value of the "place" field in the mutation.
func (m *BirthMutation) Place() (r string, exists bool) {
	v := m.place
	if v == nil {
		return
	}
	return *v, true
}

// OldPlace returns the old "place" field's value of the Birth entity.
// If the Birth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BirthMutation) OldPlace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlace: %w", err)
	}
	return oldValue.Place, nil
}

// ResetPlace resets all changes to the "place" field.
func (m *BirthMutation) ResetPlace() {
	m.place = nil
}

// SetCountry sets the "country" field.
func (m *BirthMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *BirthMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Birth entity.
// If the Birth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BirthMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *BirthMutation) ResetCountry() {
	m.country = nil
}

// AddPlayerIDs adds the "player" edge to the Player entity by ids.
func (m *BirthMutation) AddPlayerIDs(ids ...int) {
	if m.player == nil {
		m.player = make(map[int]struct{})
	}
	for i := range ids {
		m.player[ids[i]] = struct{}{}
	}
}

// ClearPlayer clears the "player" edge to the Player entity.
func (m *BirthMutation) ClearPlayer() {
	m.clearedplayer = true
}

// PlayerCleared reports if the "player" edge to the Player entity was cleared.
func (m *BirthMutation) PlayerCleared() bool {
	return m.clearedplayer
}

// RemovePlayerIDs removes the "player" edge to the Player entity by IDs.
func (m *BirthMutation) RemovePlayerIDs(ids ...int) {
	if m.removedplayer == nil {
		m.removedplayer = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.player, ids[i])
		m.removedplayer[ids[i]] = struct{}{}
	}
}

// RemovedPlayer returns the removed IDs of the "player" edge to the Player entity.
func (m *BirthMutation) RemovedPlayerIDs() (ids []int) {
	for id := range m.removedplayer {
		ids = append(ids, id)
	}
	return
}

// PlayerIDs returns the "player" edge IDs in the mutation.
func (m *BirthMutation) PlayerIDs() (ids []int) {
	for id := range m.player {
		ids = append(ids, id)
	}
	return
}

// ResetPlayer resets all changes to the "player" edge.
func (m *BirthMutation) ResetPlayer() {
	m.player = nil
	m.clearedplayer = false
	m.removedplayer = nil
}

// Where appends a list predicates to the BirthMutation builder.
func (m *BirthMutation) Where(ps ...predicate.Birth) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BirthMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BirthMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Birth, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BirthMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BirthMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Birth).
func (m *BirthMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BirthMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.date != nil {
		fields = append(fields, birth.FieldDate)
	}
	if m.place != nil {
		fields = append(fields, birth.FieldPlace)
	}
	if m.country != nil {
		fields = append(fields, birth.FieldCountry)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BirthMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case birth.FieldDate:
		return m.Date()
	case birth.FieldPlace:
		return m.Place()
	case birth.FieldCountry:
		return m.Country()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BirthMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case birth.FieldDate:
		return m.OldDate(ctx)
	case birth.FieldPlace:
		return m.OldPlace(ctx)
	case birth.FieldCountry:
		return m.OldCountry(ctx)
	}
	return nil, fmt.Errorf("unknown Birth field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BirthMutation) SetField(name string, value ent.Value) error {
	switch name {
	case birth.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case birth.FieldPlace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlace(v)
		return nil
	case birth.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	}
	return fmt.Errorf("unknown Birth field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BirthMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BirthMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BirthMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Birth numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BirthMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BirthMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BirthMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Birth nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BirthMutation) ResetField(name string) error {
	switch name {
	case birth.FieldDate:
		m.ResetDate()
		return nil
	case birth.FieldPlace:
		m.ResetPlace()
		return nil
	case birth.FieldCountry:
		m.ResetCountry()
		return nil
	}
	return fmt.Errorf("unknown Birth field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BirthMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.player != nil {
		edges = append(edges, birth.EdgePlayer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BirthMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case birth.EdgePlayer:
		ids := make([]ent.Value, 0, len(m.player))
		for id := range m.player {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BirthMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedplayer != nil {
		edges = append(edges, birth.EdgePlayer)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BirthMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case birth.EdgePlayer:
		ids := make([]ent.Value, 0, len(m.removedplayer))
		for id := range m.removedplayer {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BirthMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedplayer {
		edges = append(edges, birth.EdgePlayer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BirthMutation) EdgeCleared(name string) bool {
	switch name {
	case birth.EdgePlayer:
		return m.clearedplayer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BirthMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Birth unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BirthMutation) ResetEdge(name string) error {
	switch name {
	case birth.EdgePlayer:
		m.ResetPlayer()
		return nil
	}
	return fmt.Errorf("unknown Birth edge %s", name)
}

// ClubMutation represents an operation that mutates the Club nodes in the graph.
type ClubMutation struct {
	config
	op               Op
	typ              string
	id               *int
	apiFootballId    *int
	addapiFootballId *int
	slug             *string
	name             *string
	code             *string
	founded          *int
	addfounded       *int
	national         *bool
	logo             *string
	clearedFields    map[string]struct{}
	country          *int
	clearedcountry   bool
	team             map[int]struct{}
	removedteam      map[int]struct{}
	clearedteam      bool
	done             bool
	oldValue         func(context.Context) (*Club, error)
	predicates       []predicate.Club
}

var _ ent.Mutation = (*ClubMutation)(nil)

// clubOption allows management of the mutation configuration using functional options.
type clubOption func(*ClubMutation)

// newClubMutation creates new mutation for the Club entity.
func newClubMutation(c config, op Op, opts ...clubOption) *ClubMutation {
	m := &ClubMutation{
		config:        c,
		op:            op,
		typ:           TypeClub,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClubID sets the ID field of the mutation.
func withClubID(id int) clubOption {
	return func(m *ClubMutation) {
		var (
			err   error
			once  sync.Once
			value *Club
		)
		m.oldValue = func(ctx context.Context) (*Club, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Club.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClub sets the old Club of the mutation.
func withClub(node *Club) clubOption {
	return func(m *ClubMutation) {
		m.oldValue = func(context.Context) (*Club, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClubMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClubMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClubMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClubMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Club.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetApiFootballId sets the "apiFootballId" field.
func (m *ClubMutation) SetApiFootballId(i int) {
	m.apiFootballId = &i
	m.addapiFootballId = nil
}

// ApiFootballId returns the value of the "apiFootballId" field in the mutation.
func (m *ClubMutation) ApiFootballId() (r int, exists bool) {
	v := m.apiFootballId
	if v == nil {
		return
	}
	return *v, true
}

// OldApiFootballId returns the old "apiFootballId" field's value of the Club entity.
// If the Club object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubMutation) OldApiFootballId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApiFootballId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApiFootballId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApiFootballId: %w", err)
	}
	return oldValue.ApiFootballId, nil
}

// AddApiFootballId adds i to the "apiFootballId" field.
func (m *ClubMutation) AddApiFootballId(i int) {
	if m.addapiFootballId != nil {
		*m.addapiFootballId += i
	} else {
		m.addapiFootballId = &i
	}
}

// AddedApiFootballId returns the value that was added to the "apiFootballId" field in this mutation.
func (m *ClubMutation) AddedApiFootballId() (r int, exists bool) {
	v := m.addapiFootballId
	if v == nil {
		return
	}
	return *v, true
}

// ResetApiFootballId resets all changes to the "apiFootballId" field.
func (m *ClubMutation) ResetApiFootballId() {
	m.apiFootballId = nil
	m.addapiFootballId = nil
}

// SetSlug sets the "slug" field.
func (m *ClubMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *ClubMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Club entity.
// If the Club object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *ClubMutation) ResetSlug() {
	m.slug = nil
}

// SetName sets the "name" field.
func (m *ClubMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ClubMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Club entity.
// If the Club object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ClubMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *ClubMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ClubMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Club entity.
// If the Club object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *ClubMutation) ResetCode() {
	m.code = nil
}

// SetFounded sets the "founded" field.
func (m *ClubMutation) SetFounded(i int) {
	m.founded = &i
	m.addfounded = nil
}

// Founded returns the value of the "founded" field in the mutation.
func (m *ClubMutation) Founded() (r int, exists bool) {
	v := m.founded
	if v == nil {
		return
	}
	return *v, true
}

// OldFounded returns the old "founded" field's value of the Club entity.
// If the Club object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubMutation) OldFounded(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFounded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFounded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFounded: %w", err)
	}
	return oldValue.Founded, nil
}

// AddFounded adds i to the "founded" field.
func (m *ClubMutation) AddFounded(i int) {
	if m.addfounded != nil {
		*m.addfounded += i
	} else {
		m.addfounded = &i
	}
}

// AddedFounded returns the value that was added to the "founded" field in this mutation.
func (m *ClubMutation) AddedFounded() (r int, exists bool) {
	v := m.addfounded
	if v == nil {
		return
	}
	return *v, true
}

// ResetFounded resets all changes to the "founded" field.
func (m *ClubMutation) ResetFounded() {
	m.founded = nil
	m.addfounded = nil
}

// SetNational sets the "national" field.
func (m *ClubMutation) SetNational(b bool) {
	m.national = &b
}

// National returns the value of the "national" field in the mutation.
func (m *ClubMutation) National() (r bool, exists bool) {
	v := m.national
	if v == nil {
		return
	}
	return *v, true
}

// OldNational returns the old "national" field's value of the Club entity.
// If the Club object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubMutation) OldNational(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNational is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNational requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNational: %w", err)
	}
	return oldValue.National, nil
}

// ResetNational resets all changes to the "national" field.
func (m *ClubMutation) ResetNational() {
	m.national = nil
}

// SetLogo sets the "logo" field.
func (m *ClubMutation) SetLogo(s string) {
	m.logo = &s
}

// Logo returns the value of the "logo" field in the mutation.
func (m *ClubMutation) Logo() (r string, exists bool) {
	v := m.logo
	if v == nil {
		return
	}
	return *v, true
}

// OldLogo returns the old "logo" field's value of the Club entity.
// If the Club object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubMutation) OldLogo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogo: %w", err)
	}
	return oldValue.Logo, nil
}

// ResetLogo resets all changes to the "logo" field.
func (m *ClubMutation) ResetLogo() {
	m.logo = nil
}

// SetCountryID sets the "country" edge to the Country entity by id.
func (m *ClubMutation) SetCountryID(id int) {
	m.country = &id
}

// ClearCountry clears the "country" edge to the Country entity.
func (m *ClubMutation) ClearCountry() {
	m.clearedcountry = true
}

// CountryCleared reports if the "country" edge to the Country entity was cleared.
func (m *ClubMutation) CountryCleared() bool {
	return m.clearedcountry
}

// CountryID returns the "country" edge ID in the mutation.
func (m *ClubMutation) CountryID() (id int, exists bool) {
	if m.country != nil {
		return *m.country, true
	}
	return
}

// CountryIDs returns the "country" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CountryID instead. It exists only for internal usage by the builders.
func (m *ClubMutation) CountryIDs() (ids []int) {
	if id := m.country; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCountry resets all changes to the "country" edge.
func (m *ClubMutation) ResetCountry() {
	m.country = nil
	m.clearedcountry = false
}

// AddTeamIDs adds the "team" edge to the Team entity by ids.
func (m *ClubMutation) AddTeamIDs(ids ...int) {
	if m.team == nil {
		m.team = make(map[int]struct{})
	}
	for i := range ids {
		m.team[ids[i]] = struct{}{}
	}
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *ClubMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *ClubMutation) TeamCleared() bool {
	return m.clearedteam
}

// RemoveTeamIDs removes the "team" edge to the Team entity by IDs.
func (m *ClubMutation) RemoveTeamIDs(ids ...int) {
	if m.removedteam == nil {
		m.removedteam = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.team, ids[i])
		m.removedteam[ids[i]] = struct{}{}
	}
}

// RemovedTeam returns the removed IDs of the "team" edge to the Team entity.
func (m *ClubMutation) RemovedTeamIDs() (ids []int) {
	for id := range m.removedteam {
		ids = append(ids, id)
	}
	return
}

// TeamIDs returns the "team" edge IDs in the mutation.
func (m *ClubMutation) TeamIDs() (ids []int) {
	for id := range m.team {
		ids = append(ids, id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *ClubMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
	m.removedteam = nil
}

// Where appends a list predicates to the ClubMutation builder.
func (m *ClubMutation) Where(ps ...predicate.Club) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ClubMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ClubMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Club, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ClubMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ClubMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Club).
func (m *ClubMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClubMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.apiFootballId != nil {
		fields = append(fields, club.FieldApiFootballId)
	}
	if m.slug != nil {
		fields = append(fields, club.FieldSlug)
	}
	if m.name != nil {
		fields = append(fields, club.FieldName)
	}
	if m.code != nil {
		fields = append(fields, club.FieldCode)
	}
	if m.founded != nil {
		fields = append(fields, club.FieldFounded)
	}
	if m.national != nil {
		fields = append(fields, club.FieldNational)
	}
	if m.logo != nil {
		fields = append(fields, club.FieldLogo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClubMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case club.FieldApiFootballId:
		return m.ApiFootballId()
	case club.FieldSlug:
		return m.Slug()
	case club.FieldName:
		return m.Name()
	case club.FieldCode:
		return m.Code()
	case club.FieldFounded:
		return m.Founded()
	case club.FieldNational:
		return m.National()
	case club.FieldLogo:
		return m.Logo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClubMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case club.FieldApiFootballId:
		return m.OldApiFootballId(ctx)
	case club.FieldSlug:
		return m.OldSlug(ctx)
	case club.FieldName:
		return m.OldName(ctx)
	case club.FieldCode:
		return m.OldCode(ctx)
	case club.FieldFounded:
		return m.OldFounded(ctx)
	case club.FieldNational:
		return m.OldNational(ctx)
	case club.FieldLogo:
		return m.OldLogo(ctx)
	}
	return nil, fmt.Errorf("unknown Club field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClubMutation) SetField(name string, value ent.Value) error {
	switch name {
	case club.FieldApiFootballId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApiFootballId(v)
		return nil
	case club.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case club.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case club.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case club.FieldFounded:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFounded(v)
		return nil
	case club.FieldNational:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNational(v)
		return nil
	case club.FieldLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogo(v)
		return nil
	}
	return fmt.Errorf("unknown Club field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClubMutation) AddedFields() []string {
	var fields []string
	if m.addapiFootballId != nil {
		fields = append(fields, club.FieldApiFootballId)
	}
	if m.addfounded != nil {
		fields = append(fields, club.FieldFounded)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClubMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case club.FieldApiFootballId:
		return m.AddedApiFootballId()
	case club.FieldFounded:
		return m.AddedFounded()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClubMutation) AddField(name string, value ent.Value) error {
	switch name {
	case club.FieldApiFootballId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddApiFootballId(v)
		return nil
	case club.FieldFounded:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFounded(v)
		return nil
	}
	return fmt.Errorf("unknown Club numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClubMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClubMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClubMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Club nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClubMutation) ResetField(name string) error {
	switch name {
	case club.FieldApiFootballId:
		m.ResetApiFootballId()
		return nil
	case club.FieldSlug:
		m.ResetSlug()
		return nil
	case club.FieldName:
		m.ResetName()
		return nil
	case club.FieldCode:
		m.ResetCode()
		return nil
	case club.FieldFounded:
		m.ResetFounded()
		return nil
	case club.FieldNational:
		m.ResetNational()
		return nil
	case club.FieldLogo:
		m.ResetLogo()
		return nil
	}
	return fmt.Errorf("unknown Club field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClubMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.country != nil {
		edges = append(edges, club.EdgeCountry)
	}
	if m.team != nil {
		edges = append(edges, club.EdgeTeam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClubMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case club.EdgeCountry:
		if id := m.country; id != nil {
			return []ent.Value{*id}
		}
	case club.EdgeTeam:
		ids := make([]ent.Value, 0, len(m.team))
		for id := range m.team {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClubMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedteam != nil {
		edges = append(edges, club.EdgeTeam)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClubMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case club.EdgeTeam:
		ids := make([]ent.Value, 0, len(m.removedteam))
		for id := range m.removedteam {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClubMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcountry {
		edges = append(edges, club.EdgeCountry)
	}
	if m.clearedteam {
		edges = append(edges, club.EdgeTeam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClubMutation) EdgeCleared(name string) bool {
	switch name {
	case club.EdgeCountry:
		return m.clearedcountry
	case club.EdgeTeam:
		return m.clearedteam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClubMutation) ClearEdge(name string) error {
	switch name {
	case club.EdgeCountry:
		m.ClearCountry()
		return nil
	}
	return fmt.Errorf("unknown Club unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClubMutation) ResetEdge(name string) error {
	switch name {
	case club.EdgeCountry:
		m.ResetCountry()
		return nil
	case club.EdgeTeam:
		m.ResetTeam()
		return nil
	}
	return fmt.Errorf("unknown Club edge %s", name)
}

// CoachMutation represents an operation that mutates the Coach nodes in the graph.
type CoachMutation struct {
	config
	op               Op
	typ              string
	id               *int
	footballApiId    *int
	addfootballApiId *int
	name             *string
	photo            *string
	lastUpdated      *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Coach, error)
	predicates       []predicate.Coach
}

var _ ent.Mutation = (*CoachMutation)(nil)

// coachOption allows management of the mutation configuration using functional options.
type coachOption func(*CoachMutation)

// newCoachMutation creates new mutation for the Coach entity.
func newCoachMutation(c config, op Op, opts ...coachOption) *CoachMutation {
	m := &CoachMutation{
		config:        c,
		op:            op,
		typ:           TypeCoach,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCoachID sets the ID field of the mutation.
func withCoachID(id int) coachOption {
	return func(m *CoachMutation) {
		var (
			err   error
			once  sync.Once
			value *Coach
		)
		m.oldValue = func(ctx context.Context) (*Coach, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Coach.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCoach sets the old Coach of the mutation.
func withCoach(node *Coach) coachOption {
	return func(m *CoachMutation) {
		m.oldValue = func(context.Context) (*Coach, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CoachMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CoachMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CoachMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CoachMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Coach.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFootballApiId sets the "footballApiId" field.
func (m *CoachMutation) SetFootballApiId(i int) {
	m.footballApiId = &i
	m.addfootballApiId = nil
}

// FootballApiId returns the value of the "footballApiId" field in the mutation.
func (m *CoachMutation) FootballApiId() (r int, exists bool) {
	v := m.footballApiId
	if v == nil {
		return
	}
	return *v, true
}

// OldFootballApiId returns the old "footballApiId" field's value of the Coach entity.
// If the Coach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoachMutation) OldFootballApiId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFootballApiId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFootballApiId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFootballApiId: %w", err)
	}
	return oldValue.FootballApiId, nil
}

// AddFootballApiId adds i to the "footballApiId" field.
func (m *CoachMutation) AddFootballApiId(i int) {
	if m.addfootballApiId != nil {
		*m.addfootballApiId += i
	} else {
		m.addfootballApiId = &i
	}
}

// AddedFootballApiId returns the value that was added to the "footballApiId" field in this mutation.
func (m *CoachMutation) AddedFootballApiId() (r int, exists bool) {
	v := m.addfootballApiId
	if v == nil {
		return
	}
	return *v, true
}

// ResetFootballApiId resets all changes to the "footballApiId" field.
func (m *CoachMutation) ResetFootballApiId() {
	m.footballApiId = nil
	m.addfootballApiId = nil
}

// SetName sets the "name" field.
func (m *CoachMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CoachMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Coach entity.
// If the Coach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoachMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CoachMutation) ResetName() {
	m.name = nil
}

// SetPhoto sets the "photo" field.
func (m *CoachMutation) SetPhoto(s string) {
	m.photo = &s
}

// Photo returns the value of the "photo" field in the mutation.
func (m *CoachMutation) Photo() (r string, exists bool) {
	v := m.photo
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoto returns the old "photo" field's value of the Coach entity.
// If the Coach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoachMutation) OldPhoto(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoto is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoto requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoto: %w", err)
	}
	return oldValue.Photo, nil
}

// ResetPhoto resets all changes to the "photo" field.
func (m *CoachMutation) ResetPhoto() {
	m.photo = nil
}

// SetLastUpdated sets the "lastUpdated" field.
func (m *CoachMutation) SetLastUpdated(t time.Time) {
	m.lastUpdated = &t
}

// LastUpdated returns the value of the "lastUpdated" field in the mutation.
func (m *CoachMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.lastUpdated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "lastUpdated" field's value of the Coach entity.
// If the Coach object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CoachMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ClearLastUpdated clears the value of the "lastUpdated" field.
func (m *CoachMutation) ClearLastUpdated() {
	m.lastUpdated = nil
	m.clearedFields[coach.FieldLastUpdated] = struct{}{}
}

// LastUpdatedCleared returns if the "lastUpdated" field was cleared in this mutation.
func (m *CoachMutation) LastUpdatedCleared() bool {
	_, ok := m.clearedFields[coach.FieldLastUpdated]
	return ok
}

// ResetLastUpdated resets all changes to the "lastUpdated" field.
func (m *CoachMutation) ResetLastUpdated() {
	m.lastUpdated = nil
	delete(m.clearedFields, coach.FieldLastUpdated)
}

// Where appends a list predicates to the CoachMutation builder.
func (m *CoachMutation) Where(ps ...predicate.Coach) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CoachMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CoachMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Coach, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CoachMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CoachMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Coach).
func (m *CoachMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CoachMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.footballApiId != nil {
		fields = append(fields, coach.FieldFootballApiId)
	}
	if m.name != nil {
		fields = append(fields, coach.FieldName)
	}
	if m.photo != nil {
		fields = append(fields, coach.FieldPhoto)
	}
	if m.lastUpdated != nil {
		fields = append(fields, coach.FieldLastUpdated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CoachMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case coach.FieldFootballApiId:
		return m.FootballApiId()
	case coach.FieldName:
		return m.Name()
	case coach.FieldPhoto:
		return m.Photo()
	case coach.FieldLastUpdated:
		return m.LastUpdated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CoachMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case coach.FieldFootballApiId:
		return m.OldFootballApiId(ctx)
	case coach.FieldName:
		return m.OldName(ctx)
	case coach.FieldPhoto:
		return m.OldPhoto(ctx)
	case coach.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	}
	return nil, fmt.Errorf("unknown Coach field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CoachMutation) SetField(name string, value ent.Value) error {
	switch name {
	case coach.FieldFootballApiId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFootballApiId(v)
		return nil
	case coach.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case coach.FieldPhoto:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoto(v)
		return nil
	case coach.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	}
	return fmt.Errorf("unknown Coach field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CoachMutation) AddedFields() []string {
	var fields []string
	if m.addfootballApiId != nil {
		fields = append(fields, coach.FieldFootballApiId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CoachMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case coach.FieldFootballApiId:
		return m.AddedFootballApiId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CoachMutation) AddField(name string, value ent.Value) error {
	switch name {
	case coach.FieldFootballApiId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFootballApiId(v)
		return nil
	}
	return fmt.Errorf("unknown Coach numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CoachMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(coach.FieldLastUpdated) {
		fields = append(fields, coach.FieldLastUpdated)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CoachMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CoachMutation) ClearField(name string) error {
	switch name {
	case coach.FieldLastUpdated:
		m.ClearLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown Coach nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CoachMutation) ResetField(name string) error {
	switch name {
	case coach.FieldFootballApiId:
		m.ResetFootballApiId()
		return nil
	case coach.FieldName:
		m.ResetName()
		return nil
	case coach.FieldPhoto:
		m.ResetPhoto()
		return nil
	case coach.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown Coach field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CoachMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CoachMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CoachMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CoachMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CoachMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CoachMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CoachMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Coach unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CoachMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Coach edge %s", name)
}

// CountryMutation represents an operation that mutates the Country nodes in the graph.
type CountryMutation struct {
	config
	op             Op
	typ            string
	id             *int
	code           *string
	name           *string
	flag           *string
	lastUpdated    *time.Time
	clearedFields  map[string]struct{}
	players        map[int]struct{}
	removedplayers map[int]struct{}
	clearedplayers bool
	leagues        map[int]struct{}
	removedleagues map[int]struct{}
	clearedleagues bool
	clubs          map[int]struct{}
	removedclubs   map[int]struct{}
	clearedclubs   bool
	done           bool
	oldValue       func(context.Context) (*Country, error)
	predicates     []predicate.Country
}

var _ ent.Mutation = (*CountryMutation)(nil)

// countryOption allows management of the mutation configuration using functional options.
type countryOption func(*CountryMutation)

// newCountryMutation creates new mutation for the Country entity.
func newCountryMutation(c config, op Op, opts ...countryOption) *CountryMutation {
	m := &CountryMutation{
		config:        c,
		op:            op,
		typ:           TypeCountry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCountryID sets the ID field of the mutation.
func withCountryID(id int) countryOption {
	return func(m *CountryMutation) {
		var (
			err   error
			once  sync.Once
			value *Country
		)
		m.oldValue = func(ctx context.Context) (*Country, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Country.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCountry sets the old Country of the mutation.
func withCountry(node *Country) countryOption {
	return func(m *CountryMutation) {
		m.oldValue = func(context.Context) (*Country, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CountryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CountryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CountryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CountryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Country.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *CountryMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *CountryMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *CountryMutation) ResetCode() {
	m.code = nil
}

// SetName sets the "name" field.
func (m *CountryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CountryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CountryMutation) ResetName() {
	m.name = nil
}

// SetFlag sets the "flag" field.
func (m *CountryMutation) SetFlag(s string) {
	m.flag = &s
}

// Flag returns the value of the "flag" field in the mutation.
func (m *CountryMutation) Flag() (r string, exists bool) {
	v := m.flag
	if v == nil {
		return
	}
	return *v, true
}

// OldFlag returns the old "flag" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldFlag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlag: %w", err)
	}
	return oldValue.Flag, nil
}

// ResetFlag resets all changes to the "flag" field.
func (m *CountryMutation) ResetFlag() {
	m.flag = nil
}

// SetLastUpdated sets the "lastUpdated" field.
func (m *CountryMutation) SetLastUpdated(t time.Time) {
	m.lastUpdated = &t
}

// LastUpdated returns the value of the "lastUpdated" field in the mutation.
func (m *CountryMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.lastUpdated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "lastUpdated" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ClearLastUpdated clears the value of the "lastUpdated" field.
func (m *CountryMutation) ClearLastUpdated() {
	m.lastUpdated = nil
	m.clearedFields[country.FieldLastUpdated] = struct{}{}
}

// LastUpdatedCleared returns if the "lastUpdated" field was cleared in this mutation.
func (m *CountryMutation) LastUpdatedCleared() bool {
	_, ok := m.clearedFields[country.FieldLastUpdated]
	return ok
}

// ResetLastUpdated resets all changes to the "lastUpdated" field.
func (m *CountryMutation) ResetLastUpdated() {
	m.lastUpdated = nil
	delete(m.clearedFields, country.FieldLastUpdated)
}

// AddPlayerIDs adds the "players" edge to the Player entity by ids.
func (m *CountryMutation) AddPlayerIDs(ids ...int) {
	if m.players == nil {
		m.players = make(map[int]struct{})
	}
	for i := range ids {
		m.players[ids[i]] = struct{}{}
	}
}

// ClearPlayers clears the "players" edge to the Player entity.
func (m *CountryMutation) ClearPlayers() {
	m.clearedplayers = true
}

// PlayersCleared reports if the "players" edge to the Player entity was cleared.
func (m *CountryMutation) PlayersCleared() bool {
	return m.clearedplayers
}

// RemovePlayerIDs removes the "players" edge to the Player entity by IDs.
func (m *CountryMutation) RemovePlayerIDs(ids ...int) {
	if m.removedplayers == nil {
		m.removedplayers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.players, ids[i])
		m.removedplayers[ids[i]] = struct{}{}
	}
}

// RemovedPlayers returns the removed IDs of the "players" edge to the Player entity.
func (m *CountryMutation) RemovedPlayersIDs() (ids []int) {
	for id := range m.removedplayers {
		ids = append(ids, id)
	}
	return
}

// PlayersIDs returns the "players" edge IDs in the mutation.
func (m *CountryMutation) PlayersIDs() (ids []int) {
	for id := range m.players {
		ids = append(ids, id)
	}
	return
}

// ResetPlayers resets all changes to the "players" edge.
func (m *CountryMutation) ResetPlayers() {
	m.players = nil
	m.clearedplayers = false
	m.removedplayers = nil
}

// AddLeagueIDs adds the "leagues" edge to the League entity by ids.
func (m *CountryMutation) AddLeagueIDs(ids ...int) {
	if m.leagues == nil {
		m.leagues = make(map[int]struct{})
	}
	for i := range ids {
		m.leagues[ids[i]] = struct{}{}
	}
}

// ClearLeagues clears the "leagues" edge to the League entity.
func (m *CountryMutation) ClearLeagues() {
	m.clearedleagues = true
}

// LeaguesCleared reports if the "leagues" edge to the League entity was cleared.
func (m *CountryMutation) LeaguesCleared() bool {
	return m.clearedleagues
}

// RemoveLeagueIDs removes the "leagues" edge to the League entity by IDs.
func (m *CountryMutation) RemoveLeagueIDs(ids ...int) {
	if m.removedleagues == nil {
		m.removedleagues = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.leagues, ids[i])
		m.removedleagues[ids[i]] = struct{}{}
	}
}

// RemovedLeagues returns the removed IDs of the "leagues" edge to the League entity.
func (m *CountryMutation) RemovedLeaguesIDs() (ids []int) {
	for id := range m.removedleagues {
		ids = append(ids, id)
	}
	return
}

// LeaguesIDs returns the "leagues" edge IDs in the mutation.
func (m *CountryMutation) LeaguesIDs() (ids []int) {
	for id := range m.leagues {
		ids = append(ids, id)
	}
	return
}

// ResetLeagues resets all changes to the "leagues" edge.
func (m *CountryMutation) ResetLeagues() {
	m.leagues = nil
	m.clearedleagues = false
	m.removedleagues = nil
}

// AddClubIDs adds the "clubs" edge to the Club entity by ids.
func (m *CountryMutation) AddClubIDs(ids ...int) {
	if m.clubs == nil {
		m.clubs = make(map[int]struct{})
	}
	for i := range ids {
		m.clubs[ids[i]] = struct{}{}
	}
}

// ClearClubs clears the "clubs" edge to the Club entity.
func (m *CountryMutation) ClearClubs() {
	m.clearedclubs = true
}

// ClubsCleared reports if the "clubs" edge to the Club entity was cleared.
func (m *CountryMutation) ClubsCleared() bool {
	return m.clearedclubs
}

// RemoveClubIDs removes the "clubs" edge to the Club entity by IDs.
func (m *CountryMutation) RemoveClubIDs(ids ...int) {
	if m.removedclubs == nil {
		m.removedclubs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.clubs, ids[i])
		m.removedclubs[ids[i]] = struct{}{}
	}
}

// RemovedClubs returns the removed IDs of the "clubs" edge to the Club entity.
func (m *CountryMutation) RemovedClubsIDs() (ids []int) {
	for id := range m.removedclubs {
		ids = append(ids, id)
	}
	return
}

// ClubsIDs returns the "clubs" edge IDs in the mutation.
func (m *CountryMutation) ClubsIDs() (ids []int) {
	for id := range m.clubs {
		ids = append(ids, id)
	}
	return
}

// ResetClubs resets all changes to the "clubs" edge.
func (m *CountryMutation) ResetClubs() {
	m.clubs = nil
	m.clearedclubs = false
	m.removedclubs = nil
}

// Where appends a list predicates to the CountryMutation builder.
func (m *CountryMutation) Where(ps ...predicate.Country) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CountryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CountryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Country, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CountryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CountryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Country).
func (m *CountryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CountryMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.code != nil {
		fields = append(fields, country.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, country.FieldName)
	}
	if m.flag != nil {
		fields = append(fields, country.FieldFlag)
	}
	if m.lastUpdated != nil {
		fields = append(fields, country.FieldLastUpdated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CountryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case country.FieldCode:
		return m.Code()
	case country.FieldName:
		return m.Name()
	case country.FieldFlag:
		return m.Flag()
	case country.FieldLastUpdated:
		return m.LastUpdated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CountryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case country.FieldCode:
		return m.OldCode(ctx)
	case country.FieldName:
		return m.OldName(ctx)
	case country.FieldFlag:
		return m.OldFlag(ctx)
	case country.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	}
	return nil, fmt.Errorf("unknown Country field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case country.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case country.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case country.FieldFlag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlag(v)
		return nil
	case country.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	}
	return fmt.Errorf("unknown Country field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CountryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CountryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Country numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CountryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(country.FieldLastUpdated) {
		fields = append(fields, country.FieldLastUpdated)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CountryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CountryMutation) ClearField(name string) error {
	switch name {
	case country.FieldLastUpdated:
		m.ClearLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown Country nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CountryMutation) ResetField(name string) error {
	switch name {
	case country.FieldCode:
		m.ResetCode()
		return nil
	case country.FieldName:
		m.ResetName()
		return nil
	case country.FieldFlag:
		m.ResetFlag()
		return nil
	case country.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown Country field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CountryMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.players != nil {
		edges = append(edges, country.EdgePlayers)
	}
	if m.leagues != nil {
		edges = append(edges, country.EdgeLeagues)
	}
	if m.clubs != nil {
		edges = append(edges, country.EdgeClubs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CountryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case country.EdgePlayers:
		ids := make([]ent.Value, 0, len(m.players))
		for id := range m.players {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeLeagues:
		ids := make([]ent.Value, 0, len(m.leagues))
		for id := range m.leagues {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeClubs:
		ids := make([]ent.Value, 0, len(m.clubs))
		for id := range m.clubs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CountryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedplayers != nil {
		edges = append(edges, country.EdgePlayers)
	}
	if m.removedleagues != nil {
		edges = append(edges, country.EdgeLeagues)
	}
	if m.removedclubs != nil {
		edges = append(edges, country.EdgeClubs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CountryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case country.EdgePlayers:
		ids := make([]ent.Value, 0, len(m.removedplayers))
		for id := range m.removedplayers {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeLeagues:
		ids := make([]ent.Value, 0, len(m.removedleagues))
		for id := range m.removedleagues {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeClubs:
		ids := make([]ent.Value, 0, len(m.removedclubs))
		for id := range m.removedclubs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CountryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedplayers {
		edges = append(edges, country.EdgePlayers)
	}
	if m.clearedleagues {
		edges = append(edges, country.EdgeLeagues)
	}
	if m.clearedclubs {
		edges = append(edges, country.EdgeClubs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CountryMutation) EdgeCleared(name string) bool {
	switch name {
	case country.EdgePlayers:
		return m.clearedplayers
	case country.EdgeLeagues:
		return m.clearedleagues
	case country.EdgeClubs:
		return m.clearedclubs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CountryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Country unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CountryMutation) ResetEdge(name string) error {
	switch name {
	case country.EdgePlayers:
		m.ResetPlayers()
		return nil
	case country.EdgeLeagues:
		m.ResetLeagues()
		return nil
	case country.EdgeClubs:
		m.ResetClubs()
		return nil
	}
	return fmt.Errorf("unknown Country edge %s", name)
}

// FixtureMutation represents an operation that mutates the Fixture nodes in the graph.
type FixtureMutation struct {
	config
	op               Op
	typ              string
	id               *int
	slug             *string
	apiFootballId    *int
	addapiFootballId *int
	referee          *string
	timezone         *string
	date             *time.Time
	elapsed          *int
	addelapsed       *int
	round            *int
	addround         *int
	status           *string
	homeTeamScore    *int
	addhomeTeamScore *int
	awayTeamScore    *int
	addawayTeamScore *int
	lastUpdated      *time.Time
	clearedFields    map[string]struct{}
	homeTeam         *int
	clearedhomeTeam  bool
	awayTeam         *int
	clearedawayTeam  bool
	season           *int
	clearedseason    bool
	done             bool
	oldValue         func(context.Context) (*Fixture, error)
	predicates       []predicate.Fixture
}

var _ ent.Mutation = (*FixtureMutation)(nil)

// fixtureOption allows management of the mutation configuration using functional options.
type fixtureOption func(*FixtureMutation)

// newFixtureMutation creates new mutation for the Fixture entity.
func newFixtureMutation(c config, op Op, opts ...fixtureOption) *FixtureMutation {
	m := &FixtureMutation{
		config:        c,
		op:            op,
		typ:           TypeFixture,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFixtureID sets the ID field of the mutation.
func withFixtureID(id int) fixtureOption {
	return func(m *FixtureMutation) {
		var (
			err   error
			once  sync.Once
			value *Fixture
		)
		m.oldValue = func(ctx context.Context) (*Fixture, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Fixture.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFixture sets the old Fixture of the mutation.
func withFixture(node *Fixture) fixtureOption {
	return func(m *FixtureMutation) {
		m.oldValue = func(context.Context) (*Fixture, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FixtureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FixtureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FixtureMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FixtureMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Fixture.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSlug sets the "slug" field.
func (m *FixtureMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *FixtureMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Fixture entity.
// If the Fixture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixtureMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *FixtureMutation) ResetSlug() {
	m.slug = nil
}

// SetApiFootballId sets the "apiFootballId" field.
func (m *FixtureMutation) SetApiFootballId(i int) {
	m.apiFootballId = &i
	m.addapiFootballId = nil
}

// ApiFootballId returns the value of the "apiFootballId" field in the mutation.
func (m *FixtureMutation) ApiFootballId() (r int, exists bool) {
	v := m.apiFootballId
	if v == nil {
		return
	}
	return *v, true
}

// OldApiFootballId returns the old "apiFootballId" field's value of the Fixture entity.
// If the Fixture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixtureMutation) OldApiFootballId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApiFootballId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApiFootballId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApiFootballId: %w", err)
	}
	return oldValue.ApiFootballId, nil
}

// AddApiFootballId adds i to the "apiFootballId" field.
func (m *FixtureMutation) AddApiFootballId(i int) {
	if m.addapiFootballId != nil {
		*m.addapiFootballId += i
	} else {
		m.addapiFootballId = &i
	}
}

// AddedApiFootballId returns the value that was added to the "apiFootballId" field in this mutation.
func (m *FixtureMutation) AddedApiFootballId() (r int, exists bool) {
	v := m.addapiFootballId
	if v == nil {
		return
	}
	return *v, true
}

// ResetApiFootballId resets all changes to the "apiFootballId" field.
func (m *FixtureMutation) ResetApiFootballId() {
	m.apiFootballId = nil
	m.addapiFootballId = nil
}

// SetReferee sets the "referee" field.
func (m *FixtureMutation) SetReferee(s string) {
	m.referee = &s
}

// Referee returns the value of the "referee" field in the mutation.
func (m *FixtureMutation) Referee() (r string, exists bool) {
	v := m.referee
	if v == nil {
		return
	}
	return *v, true
}

// OldReferee returns the old "referee" field's value of the Fixture entity.
// If the Fixture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixtureMutation) OldReferee(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferee: %w", err)
	}
	return oldValue.Referee, nil
}

// ClearReferee clears the value of the "referee" field.
func (m *FixtureMutation) ClearReferee() {
	m.referee = nil
	m.clearedFields[fixture.FieldReferee] = struct{}{}
}

// RefereeCleared returns if the "referee" field was cleared in this mutation.
func (m *FixtureMutation) RefereeCleared() bool {
	_, ok := m.clearedFields[fixture.FieldReferee]
	return ok
}

// ResetReferee resets all changes to the "referee" field.
func (m *FixtureMutation) ResetReferee() {
	m.referee = nil
	delete(m.clearedFields, fixture.FieldReferee)
}

// SetTimezone sets the "timezone" field.
func (m *FixtureMutation) SetTimezone(s string) {
	m.timezone = &s
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *FixtureMutation) Timezone() (r string, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the Fixture entity.
// If the Fixture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixtureMutation) OldTimezone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// ClearTimezone clears the value of the "timezone" field.
func (m *FixtureMutation) ClearTimezone() {
	m.timezone = nil
	m.clearedFields[fixture.FieldTimezone] = struct{}{}
}

// TimezoneCleared returns if the "timezone" field was cleared in this mutation.
func (m *FixtureMutation) TimezoneCleared() bool {
	_, ok := m.clearedFields[fixture.FieldTimezone]
	return ok
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *FixtureMutation) ResetTimezone() {
	m.timezone = nil
	delete(m.clearedFields, fixture.FieldTimezone)
}

// SetDate sets the "date" field.
func (m *FixtureMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *FixtureMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Fixture entity.
// If the Fixture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixtureMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *FixtureMutation) ResetDate() {
	m.date = nil
}

// SetElapsed sets the "elapsed" field.
func (m *FixtureMutation) SetElapsed(i int) {
	m.elapsed = &i
	m.addelapsed = nil
}

// Elapsed returns the value of the "elapsed" field in the mutation.
func (m *FixtureMutation) Elapsed() (r int, exists bool) {
	v := m.elapsed
	if v == nil {
		return
	}
	return *v, true
}

// OldElapsed returns the old "elapsed" field's value of the Fixture entity.
// If the Fixture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixtureMutation) OldElapsed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElapsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElapsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElapsed: %w", err)
	}
	return oldValue.Elapsed, nil
}

// AddElapsed adds i to the "elapsed" field.
func (m *FixtureMutation) AddElapsed(i int) {
	if m.addelapsed != nil {
		*m.addelapsed += i
	} else {
		m.addelapsed = &i
	}
}

// AddedElapsed returns the value that was added to the "elapsed" field in this mutation.
func (m *FixtureMutation) AddedElapsed() (r int, exists bool) {
	v := m.addelapsed
	if v == nil {
		return
	}
	return *v, true
}

// ClearElapsed clears the value of the "elapsed" field.
func (m *FixtureMutation) ClearElapsed() {
	m.elapsed = nil
	m.addelapsed = nil
	m.clearedFields[fixture.FieldElapsed] = struct{}{}
}

// ElapsedCleared returns if the "elapsed" field was cleared in this mutation.
func (m *FixtureMutation) ElapsedCleared() bool {
	_, ok := m.clearedFields[fixture.FieldElapsed]
	return ok
}

// ResetElapsed resets all changes to the "elapsed" field.
func (m *FixtureMutation) ResetElapsed() {
	m.elapsed = nil
	m.addelapsed = nil
	delete(m.clearedFields, fixture.FieldElapsed)
}

// SetRound sets the "round" field.
func (m *FixtureMutation) SetRound(i int) {
	m.round = &i
	m.addround = nil
}

// Round returns the value of the "round" field in the mutation.
func (m *FixtureMutation) Round() (r int, exists bool) {
	v := m.round
	if v == nil {
		return
	}
	return *v, true
}

// OldRound returns the old "round" field's value of the Fixture entity.
// If the Fixture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixtureMutation) OldRound(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRound is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRound requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRound: %w", err)
	}
	return oldValue.Round, nil
}

// AddRound adds i to the "round" field.
func (m *FixtureMutation) AddRound(i int) {
	if m.addround != nil {
		*m.addround += i
	} else {
		m.addround = &i
	}
}

// AddedRound returns the value that was added to the "round" field in this mutation.
func (m *FixtureMutation) AddedRound() (r int, exists bool) {
	v := m.addround
	if v == nil {
		return
	}
	return *v, true
}

// ClearRound clears the value of the "round" field.
func (m *FixtureMutation) ClearRound() {
	m.round = nil
	m.addround = nil
	m.clearedFields[fixture.FieldRound] = struct{}{}
}

// RoundCleared returns if the "round" field was cleared in this mutation.
func (m *FixtureMutation) RoundCleared() bool {
	_, ok := m.clearedFields[fixture.FieldRound]
	return ok
}

// ResetRound resets all changes to the "round" field.
func (m *FixtureMutation) ResetRound() {
	m.round = nil
	m.addround = nil
	delete(m.clearedFields, fixture.FieldRound)
}

// SetStatus sets the "status" field.
func (m *FixtureMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *FixtureMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Fixture entity.
// If the Fixture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixtureMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *FixtureMutation) ResetStatus() {
	m.status = nil
}

// SetHomeTeamScore sets the "homeTeamScore" field.
func (m *FixtureMutation) SetHomeTeamScore(i int) {
	m.homeTeamScore = &i
	m.addhomeTeamScore = nil
}

// HomeTeamScore returns the value of the "homeTeamScore" field in the mutation.
func (m *FixtureMutation) HomeTeamScore() (r int, exists bool) {
	v := m.homeTeamScore
	if v == nil {
		return
	}
	return *v, true
}

// OldHomeTeamScore returns the old "homeTeamScore" field's value of the Fixture entity.
// If the Fixture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixtureMutation) OldHomeTeamScore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomeTeamScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomeTeamScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomeTeamScore: %w", err)
	}
	return oldValue.HomeTeamScore, nil
}

// AddHomeTeamScore adds i to the "homeTeamScore" field.
func (m *FixtureMutation) AddHomeTeamScore(i int) {
	if m.addhomeTeamScore != nil {
		*m.addhomeTeamScore += i
	} else {
		m.addhomeTeamScore = &i
	}
}

// AddedHomeTeamScore returns the value that was added to the "homeTeamScore" field in this mutation.
func (m *FixtureMutation) AddedHomeTeamScore() (r int, exists bool) {
	v := m.addhomeTeamScore
	if v == nil {
		return
	}
	return *v, true
}

// ClearHomeTeamScore clears the value of the "homeTeamScore" field.
func (m *FixtureMutation) ClearHomeTeamScore() {
	m.homeTeamScore = nil
	m.addhomeTeamScore = nil
	m.clearedFields[fixture.FieldHomeTeamScore] = struct{}{}
}

// HomeTeamScoreCleared returns if the "homeTeamScore" field was cleared in this mutation.
func (m *FixtureMutation) HomeTeamScoreCleared() bool {
	_, ok := m.clearedFields[fixture.FieldHomeTeamScore]
	return ok
}

// ResetHomeTeamScore resets all changes to the "homeTeamScore" field.
func (m *FixtureMutation) ResetHomeTeamScore() {
	m.homeTeamScore = nil
	m.addhomeTeamScore = nil
	delete(m.clearedFields, fixture.FieldHomeTeamScore)
}

// SetAwayTeamScore sets the "awayTeamScore" field.
func (m *FixtureMutation) SetAwayTeamScore(i int) {
	m.awayTeamScore = &i
	m.addawayTeamScore = nil
}

// AwayTeamScore returns the value of the "awayTeamScore" field in the mutation.
func (m *FixtureMutation) AwayTeamScore() (r int, exists bool) {
	v := m.awayTeamScore
	if v == nil {
		return
	}
	return *v, true
}

// OldAwayTeamScore returns the old "awayTeamScore" field's value of the Fixture entity.
// If the Fixture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixtureMutation) OldAwayTeamScore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAwayTeamScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAwayTeamScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAwayTeamScore: %w", err)
	}
	return oldValue.AwayTeamScore, nil
}

// AddAwayTeamScore adds i to the "awayTeamScore" field.
func (m *FixtureMutation) AddAwayTeamScore(i int) {
	if m.addawayTeamScore != nil {
		*m.addawayTeamScore += i
	} else {
		m.addawayTeamScore = &i
	}
}

// AddedAwayTeamScore returns the value that was added to the "awayTeamScore" field in this mutation.
func (m *FixtureMutation) AddedAwayTeamScore() (r int, exists bool) {
	v := m.addawayTeamScore
	if v == nil {
		return
	}
	return *v, true
}

// ClearAwayTeamScore clears the value of the "awayTeamScore" field.
func (m *FixtureMutation) ClearAwayTeamScore() {
	m.awayTeamScore = nil
	m.addawayTeamScore = nil
	m.clearedFields[fixture.FieldAwayTeamScore] = struct{}{}
}

// AwayTeamScoreCleared returns if the "awayTeamScore" field was cleared in this mutation.
func (m *FixtureMutation) AwayTeamScoreCleared() bool {
	_, ok := m.clearedFields[fixture.FieldAwayTeamScore]
	return ok
}

// ResetAwayTeamScore resets all changes to the "awayTeamScore" field.
func (m *FixtureMutation) ResetAwayTeamScore() {
	m.awayTeamScore = nil
	m.addawayTeamScore = nil
	delete(m.clearedFields, fixture.FieldAwayTeamScore)
}

// SetLastUpdated sets the "lastUpdated" field.
func (m *FixtureMutation) SetLastUpdated(t time.Time) {
	m.lastUpdated = &t
}

// LastUpdated returns the value of the "lastUpdated" field in the mutation.
func (m *FixtureMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.lastUpdated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "lastUpdated" field's value of the Fixture entity.
// If the Fixture object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixtureMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ClearLastUpdated clears the value of the "lastUpdated" field.
func (m *FixtureMutation) ClearLastUpdated() {
	m.lastUpdated = nil
	m.clearedFields[fixture.FieldLastUpdated] = struct{}{}
}

// LastUpdatedCleared returns if the "lastUpdated" field was cleared in this mutation.
func (m *FixtureMutation) LastUpdatedCleared() bool {
	_, ok := m.clearedFields[fixture.FieldLastUpdated]
	return ok
}

// ResetLastUpdated resets all changes to the "lastUpdated" field.
func (m *FixtureMutation) ResetLastUpdated() {
	m.lastUpdated = nil
	delete(m.clearedFields, fixture.FieldLastUpdated)
}

// SetHomeTeamID sets the "homeTeam" edge to the Team entity by id.
func (m *FixtureMutation) SetHomeTeamID(id int) {
	m.homeTeam = &id
}

// ClearHomeTeam clears the "homeTeam" edge to the Team entity.
func (m *FixtureMutation) ClearHomeTeam() {
	m.clearedhomeTeam = true
}

// HomeTeamCleared reports if the "homeTeam" edge to the Team entity was cleared.
func (m *FixtureMutation) HomeTeamCleared() bool {
	return m.clearedhomeTeam
}

// HomeTeamID returns the "homeTeam" edge ID in the mutation.
func (m *FixtureMutation) HomeTeamID() (id int, exists bool) {
	if m.homeTeam != nil {
		return *m.homeTeam, true
	}
	return
}

// HomeTeamIDs returns the "homeTeam" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HomeTeamID instead. It exists only for internal usage by the builders.
func (m *FixtureMutation) HomeTeamIDs() (ids []int) {
	if id := m.homeTeam; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHomeTeam resets all changes to the "homeTeam" edge.
func (m *FixtureMutation) ResetHomeTeam() {
	m.homeTeam = nil
	m.clearedhomeTeam = false
}

// SetAwayTeamID sets the "awayTeam" edge to the Team entity by id.
func (m *FixtureMutation) SetAwayTeamID(id int) {
	m.awayTeam = &id
}

// ClearAwayTeam clears the "awayTeam" edge to the Team entity.
func (m *FixtureMutation) ClearAwayTeam() {
	m.clearedawayTeam = true
}

// AwayTeamCleared reports if the "awayTeam" edge to the Team entity was cleared.
func (m *FixtureMutation) AwayTeamCleared() bool {
	return m.clearedawayTeam
}

// AwayTeamID returns the "awayTeam" edge ID in the mutation.
func (m *FixtureMutation) AwayTeamID() (id int, exists bool) {
	if m.awayTeam != nil {
		return *m.awayTeam, true
	}
	return
}

// AwayTeamIDs returns the "awayTeam" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AwayTeamID instead. It exists only for internal usage by the builders.
func (m *FixtureMutation) AwayTeamIDs() (ids []int) {
	if id := m.awayTeam; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAwayTeam resets all changes to the "awayTeam" edge.
func (m *FixtureMutation) ResetAwayTeam() {
	m.awayTeam = nil
	m.clearedawayTeam = false
}

// SetSeasonID sets the "season" edge to the Season entity by id.
func (m *FixtureMutation) SetSeasonID(id int) {
	m.season = &id
}

// ClearSeason clears the "season" edge to the Season entity.
func (m *FixtureMutation) ClearSeason() {
	m.clearedseason = true
}

// SeasonCleared reports if the "season" edge to the Season entity was cleared.
func (m *FixtureMutation) SeasonCleared() bool {
	return m.clearedseason
}

// SeasonID returns the "season" edge ID in the mutation.
func (m *FixtureMutation) SeasonID() (id int, exists bool) {
	if m.season != nil {
		return *m.season, true
	}
	return
}

// SeasonIDs returns the "season" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SeasonID instead. It exists only for internal usage by the builders.
func (m *FixtureMutation) SeasonIDs() (ids []int) {
	if id := m.season; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSeason resets all changes to the "season" edge.
func (m *FixtureMutation) ResetSeason() {
	m.season = nil
	m.clearedseason = false
}

// Where appends a list predicates to the FixtureMutation builder.
func (m *FixtureMutation) Where(ps ...predicate.Fixture) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FixtureMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FixtureMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Fixture, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FixtureMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FixtureMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Fixture).
func (m *FixtureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FixtureMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.slug != nil {
		fields = append(fields, fixture.FieldSlug)
	}
	if m.apiFootballId != nil {
		fields = append(fields, fixture.FieldApiFootballId)
	}
	if m.referee != nil {
		fields = append(fields, fixture.FieldReferee)
	}
	if m.timezone != nil {
		fields = append(fields, fixture.FieldTimezone)
	}
	if m.date != nil {
		fields = append(fields, fixture.FieldDate)
	}
	if m.elapsed != nil {
		fields = append(fields, fixture.FieldElapsed)
	}
	if m.round != nil {
		fields = append(fields, fixture.FieldRound)
	}
	if m.status != nil {
		fields = append(fields, fixture.FieldStatus)
	}
	if m.homeTeamScore != nil {
		fields = append(fields, fixture.FieldHomeTeamScore)
	}
	if m.awayTeamScore != nil {
		fields = append(fields, fixture.FieldAwayTeamScore)
	}
	if m.lastUpdated != nil {
		fields = append(fields, fixture.FieldLastUpdated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FixtureMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fixture.FieldSlug:
		return m.Slug()
	case fixture.FieldApiFootballId:
		return m.ApiFootballId()
	case fixture.FieldReferee:
		return m.Referee()
	case fixture.FieldTimezone:
		return m.Timezone()
	case fixture.FieldDate:
		return m.Date()
	case fixture.FieldElapsed:
		return m.Elapsed()
	case fixture.FieldRound:
		return m.Round()
	case fixture.FieldStatus:
		return m.Status()
	case fixture.FieldHomeTeamScore:
		return m.HomeTeamScore()
	case fixture.FieldAwayTeamScore:
		return m.AwayTeamScore()
	case fixture.FieldLastUpdated:
		return m.LastUpdated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FixtureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fixture.FieldSlug:
		return m.OldSlug(ctx)
	case fixture.FieldApiFootballId:
		return m.OldApiFootballId(ctx)
	case fixture.FieldReferee:
		return m.OldReferee(ctx)
	case fixture.FieldTimezone:
		return m.OldTimezone(ctx)
	case fixture.FieldDate:
		return m.OldDate(ctx)
	case fixture.FieldElapsed:
		return m.OldElapsed(ctx)
	case fixture.FieldRound:
		return m.OldRound(ctx)
	case fixture.FieldStatus:
		return m.OldStatus(ctx)
	case fixture.FieldHomeTeamScore:
		return m.OldHomeTeamScore(ctx)
	case fixture.FieldAwayTeamScore:
		return m.OldAwayTeamScore(ctx)
	case fixture.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	}
	return nil, fmt.Errorf("unknown Fixture field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FixtureMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fixture.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case fixture.FieldApiFootballId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApiFootballId(v)
		return nil
	case fixture.FieldReferee:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferee(v)
		return nil
	case fixture.FieldTimezone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	case fixture.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case fixture.FieldElapsed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElapsed(v)
		return nil
	case fixture.FieldRound:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRound(v)
		return nil
	case fixture.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case fixture.FieldHomeTeamScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomeTeamScore(v)
		return nil
	case fixture.FieldAwayTeamScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAwayTeamScore(v)
		return nil
	case fixture.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	}
	return fmt.Errorf("unknown Fixture field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FixtureMutation) AddedFields() []string {
	var fields []string
	if m.addapiFootballId != nil {
		fields = append(fields, fixture.FieldApiFootballId)
	}
	if m.addelapsed != nil {
		fields = append(fields, fixture.FieldElapsed)
	}
	if m.addround != nil {
		fields = append(fields, fixture.FieldRound)
	}
	if m.addhomeTeamScore != nil {
		fields = append(fields, fixture.FieldHomeTeamScore)
	}
	if m.addawayTeamScore != nil {
		fields = append(fields, fixture.FieldAwayTeamScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FixtureMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case fixture.FieldApiFootballId:
		return m.AddedApiFootballId()
	case fixture.FieldElapsed:
		return m.AddedElapsed()
	case fixture.FieldRound:
		return m.AddedRound()
	case fixture.FieldHomeTeamScore:
		return m.AddedHomeTeamScore()
	case fixture.FieldAwayTeamScore:
		return m.AddedAwayTeamScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FixtureMutation) AddField(name string, value ent.Value) error {
	switch name {
	case fixture.FieldApiFootballId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddApiFootballId(v)
		return nil
	case fixture.FieldElapsed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddElapsed(v)
		return nil
	case fixture.FieldRound:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRound(v)
		return nil
	case fixture.FieldHomeTeamScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHomeTeamScore(v)
		return nil
	case fixture.FieldAwayTeamScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAwayTeamScore(v)
		return nil
	}
	return fmt.Errorf("unknown Fixture numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FixtureMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(fixture.FieldReferee) {
		fields = append(fields, fixture.FieldReferee)
	}
	if m.FieldCleared(fixture.FieldTimezone) {
		fields = append(fields, fixture.FieldTimezone)
	}
	if m.FieldCleared(fixture.FieldElapsed) {
		fields = append(fields, fixture.FieldElapsed)
	}
	if m.FieldCleared(fixture.FieldRound) {
		fields = append(fields, fixture.FieldRound)
	}
	if m.FieldCleared(fixture.FieldHomeTeamScore) {
		fields = append(fields, fixture.FieldHomeTeamScore)
	}
	if m.FieldCleared(fixture.FieldAwayTeamScore) {
		fields = append(fields, fixture.FieldAwayTeamScore)
	}
	if m.FieldCleared(fixture.FieldLastUpdated) {
		fields = append(fields, fixture.FieldLastUpdated)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FixtureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FixtureMutation) ClearField(name string) error {
	switch name {
	case fixture.FieldReferee:
		m.ClearReferee()
		return nil
	case fixture.FieldTimezone:
		m.ClearTimezone()
		return nil
	case fixture.FieldElapsed:
		m.ClearElapsed()
		return nil
	case fixture.FieldRound:
		m.ClearRound()
		return nil
	case fixture.FieldHomeTeamScore:
		m.ClearHomeTeamScore()
		return nil
	case fixture.FieldAwayTeamScore:
		m.ClearAwayTeamScore()
		return nil
	case fixture.FieldLastUpdated:
		m.ClearLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown Fixture nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FixtureMutation) ResetField(name string) error {
	switch name {
	case fixture.FieldSlug:
		m.ResetSlug()
		return nil
	case fixture.FieldApiFootballId:
		m.ResetApiFootballId()
		return nil
	case fixture.FieldReferee:
		m.ResetReferee()
		return nil
	case fixture.FieldTimezone:
		m.ResetTimezone()
		return nil
	case fixture.FieldDate:
		m.ResetDate()
		return nil
	case fixture.FieldElapsed:
		m.ResetElapsed()
		return nil
	case fixture.FieldRound:
		m.ResetRound()
		return nil
	case fixture.FieldStatus:
		m.ResetStatus()
		return nil
	case fixture.FieldHomeTeamScore:
		m.ResetHomeTeamScore()
		return nil
	case fixture.FieldAwayTeamScore:
		m.ResetAwayTeamScore()
		return nil
	case fixture.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown Fixture field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FixtureMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.homeTeam != nil {
		edges = append(edges, fixture.EdgeHomeTeam)
	}
	if m.awayTeam != nil {
		edges = append(edges, fixture.EdgeAwayTeam)
	}
	if m.season != nil {
		edges = append(edges, fixture.EdgeSeason)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FixtureMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case fixture.EdgeHomeTeam:
		if id := m.homeTeam; id != nil {
			return []ent.Value{*id}
		}
	case fixture.EdgeAwayTeam:
		if id := m.awayTeam; id != nil {
			return []ent.Value{*id}
		}
	case fixture.EdgeSeason:
		if id := m.season; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FixtureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FixtureMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FixtureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedhomeTeam {
		edges = append(edges, fixture.EdgeHomeTeam)
	}
	if m.clearedawayTeam {
		edges = append(edges, fixture.EdgeAwayTeam)
	}
	if m.clearedseason {
		edges = append(edges, fixture.EdgeSeason)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FixtureMutation) EdgeCleared(name string) bool {
	switch name {
	case fixture.EdgeHomeTeam:
		return m.clearedhomeTeam
	case fixture.EdgeAwayTeam:
		return m.clearedawayTeam
	case fixture.EdgeSeason:
		return m.clearedseason
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FixtureMutation) ClearEdge(name string) error {
	switch name {
	case fixture.EdgeHomeTeam:
		m.ClearHomeTeam()
		return nil
	case fixture.EdgeAwayTeam:
		m.ClearAwayTeam()
		return nil
	case fixture.EdgeSeason:
		m.ClearSeason()
		return nil
	}
	return fmt.Errorf("unknown Fixture unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FixtureMutation) ResetEdge(name string) error {
	switch name {
	case fixture.EdgeHomeTeam:
		m.ResetHomeTeam()
		return nil
	case fixture.EdgeAwayTeam:
		m.ResetAwayTeam()
		return nil
	case fixture.EdgeSeason:
		m.ResetSeason()
		return nil
	}
	return fmt.Errorf("unknown Fixture edge %s", name)
}

// FixtureEventsMutation represents an operation that mutates the FixtureEvents nodes in the graph.
type FixtureEventsMutation struct {
	config
	op            Op
	typ           string
	id            *int
	elapsedTime   *string
	extraTime     *string
	_type         *string
	detail        *string
	comments      *string
	lastUpdated   *time.Time
	clearedFields map[string]struct{}
	player        *int
	clearedplayer bool
	assist        *int
	clearedassist bool
	team          *int
	clearedteam   bool
	done          bool
	oldValue      func(context.Context) (*FixtureEvents, error)
	predicates    []predicate.FixtureEvents
}

var _ ent.Mutation = (*FixtureEventsMutation)(nil)

// fixtureeventsOption allows management of the mutation configuration using functional options.
type fixtureeventsOption func(*FixtureEventsMutation)

// newFixtureEventsMutation creates new mutation for the FixtureEvents entity.
func newFixtureEventsMutation(c config, op Op, opts ...fixtureeventsOption) *FixtureEventsMutation {
	m := &FixtureEventsMutation{
		config:        c,
		op:            op,
		typ:           TypeFixtureEvents,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFixtureEventsID sets the ID field of the mutation.
func withFixtureEventsID(id int) fixtureeventsOption {
	return func(m *FixtureEventsMutation) {
		var (
			err   error
			once  sync.Once
			value *FixtureEvents
		)
		m.oldValue = func(ctx context.Context) (*FixtureEvents, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FixtureEvents.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFixtureEvents sets the old FixtureEvents of the mutation.
func withFixtureEvents(node *FixtureEvents) fixtureeventsOption {
	return func(m *FixtureEventsMutation) {
		m.oldValue = func(context.Context) (*FixtureEvents, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FixtureEventsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FixtureEventsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FixtureEventsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FixtureEventsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FixtureEvents.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetElapsedTime sets the "elapsedTime" field.
func (m *FixtureEventsMutation) SetElapsedTime(s string) {
	m.elapsedTime = &s
}

// ElapsedTime returns the value of the "elapsedTime" field in the mutation.
func (m *FixtureEventsMutation) ElapsedTime() (r string, exists bool) {
	v := m.elapsedTime
	if v == nil {
		return
	}
	return *v, true
}

// OldElapsedTime returns the old "elapsedTime" field's value of the FixtureEvents entity.
// If the FixtureEvents object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixtureEventsMutation) OldElapsedTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElapsedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElapsedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElapsedTime: %w", err)
	}
	return oldValue.ElapsedTime, nil
}

// ResetElapsedTime resets all changes to the "elapsedTime" field.
func (m *FixtureEventsMutation) ResetElapsedTime() {
	m.elapsedTime = nil
}

// SetExtraTime sets the "extraTime" field.
func (m *FixtureEventsMutation) SetExtraTime(s string) {
	m.extraTime = &s
}

// ExtraTime returns the value of the "extraTime" field in the mutation.
func (m *FixtureEventsMutation) ExtraTime() (r string, exists bool) {
	v := m.extraTime
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraTime returns the old "extraTime" field's value of the FixtureEvents entity.
// If the FixtureEvents object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixtureEventsMutation) OldExtraTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraTime: %w", err)
	}
	return oldValue.ExtraTime, nil
}

// ResetExtraTime resets all changes to the "extraTime" field.
func (m *FixtureEventsMutation) ResetExtraTime() {
	m.extraTime = nil
}

// SetType sets the "type" field.
func (m *FixtureEventsMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *FixtureEventsMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the FixtureEvents entity.
// If the FixtureEvents object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixtureEventsMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *FixtureEventsMutation) ResetType() {
	m._type = nil
}

// SetDetail sets the "detail" field.
func (m *FixtureEventsMutation) SetDetail(s string) {
	m.detail = &s
}

// Detail returns the value of the "detail" field in the mutation.
func (m *FixtureEventsMutation) Detail() (r string, exists bool) {
	v := m.detail
	if v == nil {
		return
	}
	return *v, true
}

// OldDetail returns the old "detail" field's value of the FixtureEvents entity.
// If the FixtureEvents object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixtureEventsMutation) OldDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetail: %w", err)
	}
	return oldValue.Detail, nil
}

// ResetDetail resets all changes to the "detail" field.
func (m *FixtureEventsMutation) ResetDetail() {
	m.detail = nil
}

// SetComments sets the "comments" field.
func (m *FixtureEventsMutation) SetComments(s string) {
	m.comments = &s
}

// Comments returns the value of the "comments" field in the mutation.
func (m *FixtureEventsMutation) Comments() (r string, exists bool) {
	v := m.comments
	if v == nil {
		return
	}
	return *v, true
}

// OldComments returns the old "comments" field's value of the FixtureEvents entity.
// If the FixtureEvents object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixtureEventsMutation) OldComments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComments: %w", err)
	}
	return oldValue.Comments, nil
}

// ClearComments clears the value of the "comments" field.
func (m *FixtureEventsMutation) ClearComments() {
	m.comments = nil
	m.clearedFields[fixtureevents.FieldComments] = struct{}{}
}

// CommentsCleared returns if the "comments" field was cleared in this mutation.
func (m *FixtureEventsMutation) CommentsCleared() bool {
	_, ok := m.clearedFields[fixtureevents.FieldComments]
	return ok
}

// ResetComments resets all changes to the "comments" field.
func (m *FixtureEventsMutation) ResetComments() {
	m.comments = nil
	delete(m.clearedFields, fixtureevents.FieldComments)
}

// SetLastUpdated sets the "lastUpdated" field.
func (m *FixtureEventsMutation) SetLastUpdated(t time.Time) {
	m.lastUpdated = &t
}

// LastUpdated returns the value of the "lastUpdated" field in the mutation.
func (m *FixtureEventsMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.lastUpdated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "lastUpdated" field's value of the FixtureEvents entity.
// If the FixtureEvents object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixtureEventsMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ClearLastUpdated clears the value of the "lastUpdated" field.
func (m *FixtureEventsMutation) ClearLastUpdated() {
	m.lastUpdated = nil
	m.clearedFields[fixtureevents.FieldLastUpdated] = struct{}{}
}

// LastUpdatedCleared returns if the "lastUpdated" field was cleared in this mutation.
func (m *FixtureEventsMutation) LastUpdatedCleared() bool {
	_, ok := m.clearedFields[fixtureevents.FieldLastUpdated]
	return ok
}

// ResetLastUpdated resets all changes to the "lastUpdated" field.
func (m *FixtureEventsMutation) ResetLastUpdated() {
	m.lastUpdated = nil
	delete(m.clearedFields, fixtureevents.FieldLastUpdated)
}

// SetPlayerID sets the "player" edge to the Player entity by id.
func (m *FixtureEventsMutation) SetPlayerID(id int) {
	m.player = &id
}

// ClearPlayer clears the "player" edge to the Player entity.
func (m *FixtureEventsMutation) ClearPlayer() {
	m.clearedplayer = true
}

// PlayerCleared reports if the "player" edge to the Player entity was cleared.
func (m *FixtureEventsMutation) PlayerCleared() bool {
	return m.clearedplayer
}

// PlayerID returns the "player" edge ID in the mutation.
func (m *FixtureEventsMutation) PlayerID() (id int, exists bool) {
	if m.player != nil {
		return *m.player, true
	}
	return
}

// PlayerIDs returns the "player" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlayerID instead. It exists only for internal usage by the builders.
func (m *FixtureEventsMutation) PlayerIDs() (ids []int) {
	if id := m.player; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlayer resets all changes to the "player" edge.
func (m *FixtureEventsMutation) ResetPlayer() {
	m.player = nil
	m.clearedplayer = false
}

// SetAssistID sets the "assist" edge to the Player entity by id.
func (m *FixtureEventsMutation) SetAssistID(id int) {
	m.assist = &id
}

// ClearAssist clears the "assist" edge to the Player entity.
func (m *FixtureEventsMutation) ClearAssist() {
	m.clearedassist = true
}

// AssistCleared reports if the "assist" edge to the Player entity was cleared.
func (m *FixtureEventsMutation) AssistCleared() bool {
	return m.clearedassist
}

// AssistID returns the "assist" edge ID in the mutation.
func (m *FixtureEventsMutation) AssistID() (id int, exists bool) {
	if m.assist != nil {
		return *m.assist, true
	}
	return
}

// AssistIDs returns the "assist" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssistID instead. It exists only for internal usage by the builders.
func (m *FixtureEventsMutation) AssistIDs() (ids []int) {
	if id := m.assist; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAssist resets all changes to the "assist" edge.
func (m *FixtureEventsMutation) ResetAssist() {
	m.assist = nil
	m.clearedassist = false
}

// SetTeamID sets the "team" edge to the Team entity by id.
func (m *FixtureEventsMutation) SetTeamID(id int) {
	m.team = &id
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *FixtureEventsMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *FixtureEventsMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamID returns the "team" edge ID in the mutation.
func (m *FixtureEventsMutation) TeamID() (id int, exists bool) {
	if m.team != nil {
		return *m.team, true
	}
	return
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *FixtureEventsMutation) TeamIDs() (ids []int) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *FixtureEventsMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// Where appends a list predicates to the FixtureEventsMutation builder.
func (m *FixtureEventsMutation) Where(ps ...predicate.FixtureEvents) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FixtureEventsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FixtureEventsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FixtureEvents, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FixtureEventsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FixtureEventsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FixtureEvents).
func (m *FixtureEventsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FixtureEventsMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.elapsedTime != nil {
		fields = append(fields, fixtureevents.FieldElapsedTime)
	}
	if m.extraTime != nil {
		fields = append(fields, fixtureevents.FieldExtraTime)
	}
	if m._type != nil {
		fields = append(fields, fixtureevents.FieldType)
	}
	if m.detail != nil {
		fields = append(fields, fixtureevents.FieldDetail)
	}
	if m.comments != nil {
		fields = append(fields, fixtureevents.FieldComments)
	}
	if m.lastUpdated != nil {
		fields = append(fields, fixtureevents.FieldLastUpdated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FixtureEventsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fixtureevents.FieldElapsedTime:
		return m.ElapsedTime()
	case fixtureevents.FieldExtraTime:
		return m.ExtraTime()
	case fixtureevents.FieldType:
		return m.GetType()
	case fixtureevents.FieldDetail:
		return m.Detail()
	case fixtureevents.FieldComments:
		return m.Comments()
	case fixtureevents.FieldLastUpdated:
		return m.LastUpdated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FixtureEventsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fixtureevents.FieldElapsedTime:
		return m.OldElapsedTime(ctx)
	case fixtureevents.FieldExtraTime:
		return m.OldExtraTime(ctx)
	case fixtureevents.FieldType:
		return m.OldType(ctx)
	case fixtureevents.FieldDetail:
		return m.OldDetail(ctx)
	case fixtureevents.FieldComments:
		return m.OldComments(ctx)
	case fixtureevents.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	}
	return nil, fmt.Errorf("unknown FixtureEvents field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FixtureEventsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fixtureevents.FieldElapsedTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElapsedTime(v)
		return nil
	case fixtureevents.FieldExtraTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraTime(v)
		return nil
	case fixtureevents.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case fixtureevents.FieldDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetail(v)
		return nil
	case fixtureevents.FieldComments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComments(v)
		return nil
	case fixtureevents.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	}
	return fmt.Errorf("unknown FixtureEvents field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FixtureEventsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FixtureEventsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FixtureEventsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FixtureEvents numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FixtureEventsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(fixtureevents.FieldComments) {
		fields = append(fields, fixtureevents.FieldComments)
	}
	if m.FieldCleared(fixtureevents.FieldLastUpdated) {
		fields = append(fields, fixtureevents.FieldLastUpdated)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FixtureEventsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FixtureEventsMutation) ClearField(name string) error {
	switch name {
	case fixtureevents.FieldComments:
		m.ClearComments()
		return nil
	case fixtureevents.FieldLastUpdated:
		m.ClearLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown FixtureEvents nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FixtureEventsMutation) ResetField(name string) error {
	switch name {
	case fixtureevents.FieldElapsedTime:
		m.ResetElapsedTime()
		return nil
	case fixtureevents.FieldExtraTime:
		m.ResetExtraTime()
		return nil
	case fixtureevents.FieldType:
		m.ResetType()
		return nil
	case fixtureevents.FieldDetail:
		m.ResetDetail()
		return nil
	case fixtureevents.FieldComments:
		m.ResetComments()
		return nil
	case fixtureevents.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown FixtureEvents field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FixtureEventsMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.player != nil {
		edges = append(edges, fixtureevents.EdgePlayer)
	}
	if m.assist != nil {
		edges = append(edges, fixtureevents.EdgeAssist)
	}
	if m.team != nil {
		edges = append(edges, fixtureevents.EdgeTeam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FixtureEventsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case fixtureevents.EdgePlayer:
		if id := m.player; id != nil {
			return []ent.Value{*id}
		}
	case fixtureevents.EdgeAssist:
		if id := m.assist; id != nil {
			return []ent.Value{*id}
		}
	case fixtureevents.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FixtureEventsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FixtureEventsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FixtureEventsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedplayer {
		edges = append(edges, fixtureevents.EdgePlayer)
	}
	if m.clearedassist {
		edges = append(edges, fixtureevents.EdgeAssist)
	}
	if m.clearedteam {
		edges = append(edges, fixtureevents.EdgeTeam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FixtureEventsMutation) EdgeCleared(name string) bool {
	switch name {
	case fixtureevents.EdgePlayer:
		return m.clearedplayer
	case fixtureevents.EdgeAssist:
		return m.clearedassist
	case fixtureevents.EdgeTeam:
		return m.clearedteam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FixtureEventsMutation) ClearEdge(name string) error {
	switch name {
	case fixtureevents.EdgePlayer:
		m.ClearPlayer()
		return nil
	case fixtureevents.EdgeAssist:
		m.ClearAssist()
		return nil
	case fixtureevents.EdgeTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown FixtureEvents unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FixtureEventsMutation) ResetEdge(name string) error {
	switch name {
	case fixtureevents.EdgePlayer:
		m.ResetPlayer()
		return nil
	case fixtureevents.EdgeAssist:
		m.ResetAssist()
		return nil
	case fixtureevents.EdgeTeam:
		m.ResetTeam()
		return nil
	}
	return fmt.Errorf("unknown FixtureEvents edge %s", name)
}

// FixtureLineupsMutation represents an operation that mutates the FixtureLineups nodes in the graph.
type FixtureLineupsMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	formation           *string
	lastUpdated         *time.Time
	clearedFields       map[string]struct{}
	team                *int
	clearedteam         bool
	lineupPlayer        map[int]struct{}
	removedlineupPlayer map[int]struct{}
	clearedlineupPlayer bool
	done                bool
	oldValue            func(context.Context) (*FixtureLineups, error)
	predicates          []predicate.FixtureLineups
}

var _ ent.Mutation = (*FixtureLineupsMutation)(nil)

// fixturelineupsOption allows management of the mutation configuration using functional options.
type fixturelineupsOption func(*FixtureLineupsMutation)

// newFixtureLineupsMutation creates new mutation for the FixtureLineups entity.
func newFixtureLineupsMutation(c config, op Op, opts ...fixturelineupsOption) *FixtureLineupsMutation {
	m := &FixtureLineupsMutation{
		config:        c,
		op:            op,
		typ:           TypeFixtureLineups,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFixtureLineupsID sets the ID field of the mutation.
func withFixtureLineupsID(id int) fixturelineupsOption {
	return func(m *FixtureLineupsMutation) {
		var (
			err   error
			once  sync.Once
			value *FixtureLineups
		)
		m.oldValue = func(ctx context.Context) (*FixtureLineups, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FixtureLineups.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFixtureLineups sets the old FixtureLineups of the mutation.
func withFixtureLineups(node *FixtureLineups) fixturelineupsOption {
	return func(m *FixtureLineupsMutation) {
		m.oldValue = func(context.Context) (*FixtureLineups, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FixtureLineupsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FixtureLineupsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FixtureLineupsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FixtureLineupsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FixtureLineups.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFormation sets the "formation" field.
func (m *FixtureLineupsMutation) SetFormation(s string) {
	m.formation = &s
}

// Formation returns the value of the "formation" field in the mutation.
func (m *FixtureLineupsMutation) Formation() (r string, exists bool) {
	v := m.formation
	if v == nil {
		return
	}
	return *v, true
}

// OldFormation returns the old "formation" field's value of the FixtureLineups entity.
// If the FixtureLineups object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixtureLineupsMutation) OldFormation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormation: %w", err)
	}
	return oldValue.Formation, nil
}

// ResetFormation resets all changes to the "formation" field.
func (m *FixtureLineupsMutation) ResetFormation() {
	m.formation = nil
}

// SetLastUpdated sets the "lastUpdated" field.
func (m *FixtureLineupsMutation) SetLastUpdated(t time.Time) {
	m.lastUpdated = &t
}

// LastUpdated returns the value of the "lastUpdated" field in the mutation.
func (m *FixtureLineupsMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.lastUpdated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "lastUpdated" field's value of the FixtureLineups entity.
// If the FixtureLineups object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FixtureLineupsMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ClearLastUpdated clears the value of the "lastUpdated" field.
func (m *FixtureLineupsMutation) ClearLastUpdated() {
	m.lastUpdated = nil
	m.clearedFields[fixturelineups.FieldLastUpdated] = struct{}{}
}

// LastUpdatedCleared returns if the "lastUpdated" field was cleared in this mutation.
func (m *FixtureLineupsMutation) LastUpdatedCleared() bool {
	_, ok := m.clearedFields[fixturelineups.FieldLastUpdated]
	return ok
}

// ResetLastUpdated resets all changes to the "lastUpdated" field.
func (m *FixtureLineupsMutation) ResetLastUpdated() {
	m.lastUpdated = nil
	delete(m.clearedFields, fixturelineups.FieldLastUpdated)
}

// SetTeamID sets the "team" edge to the Team entity by id.
func (m *FixtureLineupsMutation) SetTeamID(id int) {
	m.team = &id
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *FixtureLineupsMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *FixtureLineupsMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamID returns the "team" edge ID in the mutation.
func (m *FixtureLineupsMutation) TeamID() (id int, exists bool) {
	if m.team != nil {
		return *m.team, true
	}
	return
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *FixtureLineupsMutation) TeamIDs() (ids []int) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *FixtureLineupsMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// AddLineupPlayerIDs adds the "lineupPlayer" edge to the MatchPlayer entity by ids.
func (m *FixtureLineupsMutation) AddLineupPlayerIDs(ids ...int) {
	if m.lineupPlayer == nil {
		m.lineupPlayer = make(map[int]struct{})
	}
	for i := range ids {
		m.lineupPlayer[ids[i]] = struct{}{}
	}
}

// ClearLineupPlayer clears the "lineupPlayer" edge to the MatchPlayer entity.
func (m *FixtureLineupsMutation) ClearLineupPlayer() {
	m.clearedlineupPlayer = true
}

// LineupPlayerCleared reports if the "lineupPlayer" edge to the MatchPlayer entity was cleared.
func (m *FixtureLineupsMutation) LineupPlayerCleared() bool {
	return m.clearedlineupPlayer
}

// RemoveLineupPlayerIDs removes the "lineupPlayer" edge to the MatchPlayer entity by IDs.
func (m *FixtureLineupsMutation) RemoveLineupPlayerIDs(ids ...int) {
	if m.removedlineupPlayer == nil {
		m.removedlineupPlayer = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.lineupPlayer, ids[i])
		m.removedlineupPlayer[ids[i]] = struct{}{}
	}
}

// RemovedLineupPlayer returns the removed IDs of the "lineupPlayer" edge to the MatchPlayer entity.
func (m *FixtureLineupsMutation) RemovedLineupPlayerIDs() (ids []int) {
	for id := range m.removedlineupPlayer {
		ids = append(ids, id)
	}
	return
}

// LineupPlayerIDs returns the "lineupPlayer" edge IDs in the mutation.
func (m *FixtureLineupsMutation) LineupPlayerIDs() (ids []int) {
	for id := range m.lineupPlayer {
		ids = append(ids, id)
	}
	return
}

// ResetLineupPlayer resets all changes to the "lineupPlayer" edge.
func (m *FixtureLineupsMutation) ResetLineupPlayer() {
	m.lineupPlayer = nil
	m.clearedlineupPlayer = false
	m.removedlineupPlayer = nil
}

// Where appends a list predicates to the FixtureLineupsMutation builder.
func (m *FixtureLineupsMutation) Where(ps ...predicate.FixtureLineups) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FixtureLineupsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FixtureLineupsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FixtureLineups, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FixtureLineupsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FixtureLineupsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FixtureLineups).
func (m *FixtureLineupsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FixtureLineupsMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.formation != nil {
		fields = append(fields, fixturelineups.FieldFormation)
	}
	if m.lastUpdated != nil {
		fields = append(fields, fixturelineups.FieldLastUpdated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FixtureLineupsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fixturelineups.FieldFormation:
		return m.Formation()
	case fixturelineups.FieldLastUpdated:
		return m.LastUpdated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FixtureLineupsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fixturelineups.FieldFormation:
		return m.OldFormation(ctx)
	case fixturelineups.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	}
	return nil, fmt.Errorf("unknown FixtureLineups field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FixtureLineupsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fixturelineups.FieldFormation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormation(v)
		return nil
	case fixturelineups.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	}
	return fmt.Errorf("unknown FixtureLineups field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FixtureLineupsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FixtureLineupsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FixtureLineupsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FixtureLineups numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FixtureLineupsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(fixturelineups.FieldLastUpdated) {
		fields = append(fields, fixturelineups.FieldLastUpdated)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FixtureLineupsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FixtureLineupsMutation) ClearField(name string) error {
	switch name {
	case fixturelineups.FieldLastUpdated:
		m.ClearLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown FixtureLineups nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FixtureLineupsMutation) ResetField(name string) error {
	switch name {
	case fixturelineups.FieldFormation:
		m.ResetFormation()
		return nil
	case fixturelineups.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown FixtureLineups field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FixtureLineupsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.team != nil {
		edges = append(edges, fixturelineups.EdgeTeam)
	}
	if m.lineupPlayer != nil {
		edges = append(edges, fixturelineups.EdgeLineupPlayer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FixtureLineupsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case fixturelineups.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	case fixturelineups.EdgeLineupPlayer:
		ids := make([]ent.Value, 0, len(m.lineupPlayer))
		for id := range m.lineupPlayer {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FixtureLineupsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedlineupPlayer != nil {
		edges = append(edges, fixturelineups.EdgeLineupPlayer)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FixtureLineupsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case fixturelineups.EdgeLineupPlayer:
		ids := make([]ent.Value, 0, len(m.removedlineupPlayer))
		for id := range m.removedlineupPlayer {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FixtureLineupsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedteam {
		edges = append(edges, fixturelineups.EdgeTeam)
	}
	if m.clearedlineupPlayer {
		edges = append(edges, fixturelineups.EdgeLineupPlayer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FixtureLineupsMutation) EdgeCleared(name string) bool {
	switch name {
	case fixturelineups.EdgeTeam:
		return m.clearedteam
	case fixturelineups.EdgeLineupPlayer:
		return m.clearedlineupPlayer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FixtureLineupsMutation) ClearEdge(name string) error {
	switch name {
	case fixturelineups.EdgeTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown FixtureLineups unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FixtureLineupsMutation) ResetEdge(name string) error {
	switch name {
	case fixturelineups.EdgeTeam:
		m.ResetTeam()
		return nil
	case fixturelineups.EdgeLineupPlayer:
		m.ResetLineupPlayer()
		return nil
	}
	return fmt.Errorf("unknown FixtureLineups edge %s", name)
}

// LeagueMutation represents an operation that mutates the League nodes in the graph.
type LeagueMutation struct {
	config
	op               Op
	typ              string
	id               *int
	footballApiId    *int
	addfootballApiId *int
	slug             *string
	name             *string
	_type            *league.Type
	logo             *string
	lastUpdated      *time.Time
	clearedFields    map[string]struct{}
	country          *int
	clearedcountry   bool
	season           map[int]struct{}
	removedseason    map[int]struct{}
	clearedseason    bool
	done             bool
	oldValue         func(context.Context) (*League, error)
	predicates       []predicate.League
}

var _ ent.Mutation = (*LeagueMutation)(nil)

// leagueOption allows management of the mutation configuration using functional options.
type leagueOption func(*LeagueMutation)

// newLeagueMutation creates new mutation for the League entity.
func newLeagueMutation(c config, op Op, opts ...leagueOption) *LeagueMutation {
	m := &LeagueMutation{
		config:        c,
		op:            op,
		typ:           TypeLeague,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLeagueID sets the ID field of the mutation.
func withLeagueID(id int) leagueOption {
	return func(m *LeagueMutation) {
		var (
			err   error
			once  sync.Once
			value *League
		)
		m.oldValue = func(ctx context.Context) (*League, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().League.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLeague sets the old League of the mutation.
func withLeague(node *League) leagueOption {
	return func(m *LeagueMutation) {
		m.oldValue = func(context.Context) (*League, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LeagueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LeagueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LeagueMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LeagueMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().League.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFootballApiId sets the "footballApiId" field.
func (m *LeagueMutation) SetFootballApiId(i int) {
	m.footballApiId = &i
	m.addfootballApiId = nil
}

// FootballApiId returns the value of the "footballApiId" field in the mutation.
func (m *LeagueMutation) FootballApiId() (r int, exists bool) {
	v := m.footballApiId
	if v == nil {
		return
	}
	return *v, true
}

// OldFootballApiId returns the old "footballApiId" field's value of the League entity.
// If the League object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeagueMutation) OldFootballApiId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFootballApiId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFootballApiId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFootballApiId: %w", err)
	}
	return oldValue.FootballApiId, nil
}

// AddFootballApiId adds i to the "footballApiId" field.
func (m *LeagueMutation) AddFootballApiId(i int) {
	if m.addfootballApiId != nil {
		*m.addfootballApiId += i
	} else {
		m.addfootballApiId = &i
	}
}

// AddedFootballApiId returns the value that was added to the "footballApiId" field in this mutation.
func (m *LeagueMutation) AddedFootballApiId() (r int, exists bool) {
	v := m.addfootballApiId
	if v == nil {
		return
	}
	return *v, true
}

// ResetFootballApiId resets all changes to the "footballApiId" field.
func (m *LeagueMutation) ResetFootballApiId() {
	m.footballApiId = nil
	m.addfootballApiId = nil
}

// SetSlug sets the "slug" field.
func (m *LeagueMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *LeagueMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the League entity.
// If the League object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeagueMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *LeagueMutation) ResetSlug() {
	m.slug = nil
}

// SetName sets the "name" field.
func (m *LeagueMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LeagueMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the League entity.
// If the League object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeagueMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LeagueMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *LeagueMutation) SetType(l league.Type) {
	m._type = &l
}

// GetType returns the value of the "type" field in the mutation.
func (m *LeagueMutation) GetType() (r league.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the League entity.
// If the League object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeagueMutation) OldType(ctx context.Context) (v league.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *LeagueMutation) ResetType() {
	m._type = nil
}

// SetLogo sets the "logo" field.
func (m *LeagueMutation) SetLogo(s string) {
	m.logo = &s
}

// Logo returns the value of the "logo" field in the mutation.
func (m *LeagueMutation) Logo() (r string, exists bool) {
	v := m.logo
	if v == nil {
		return
	}
	return *v, true
}

// OldLogo returns the old "logo" field's value of the League entity.
// If the League object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeagueMutation) OldLogo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogo: %w", err)
	}
	return oldValue.Logo, nil
}

// ResetLogo resets all changes to the "logo" field.
func (m *LeagueMutation) ResetLogo() {
	m.logo = nil
}

// SetLastUpdated sets the "lastUpdated" field.
func (m *LeagueMutation) SetLastUpdated(t time.Time) {
	m.lastUpdated = &t
}

// LastUpdated returns the value of the "lastUpdated" field in the mutation.
func (m *LeagueMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.lastUpdated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "lastUpdated" field's value of the League entity.
// If the League object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeagueMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ClearLastUpdated clears the value of the "lastUpdated" field.
func (m *LeagueMutation) ClearLastUpdated() {
	m.lastUpdated = nil
	m.clearedFields[league.FieldLastUpdated] = struct{}{}
}

// LastUpdatedCleared returns if the "lastUpdated" field was cleared in this mutation.
func (m *LeagueMutation) LastUpdatedCleared() bool {
	_, ok := m.clearedFields[league.FieldLastUpdated]
	return ok
}

// ResetLastUpdated resets all changes to the "lastUpdated" field.
func (m *LeagueMutation) ResetLastUpdated() {
	m.lastUpdated = nil
	delete(m.clearedFields, league.FieldLastUpdated)
}

// SetCountryID sets the "country" edge to the Country entity by id.
func (m *LeagueMutation) SetCountryID(id int) {
	m.country = &id
}

// ClearCountry clears the "country" edge to the Country entity.
func (m *LeagueMutation) ClearCountry() {
	m.clearedcountry = true
}

// CountryCleared reports if the "country" edge to the Country entity was cleared.
func (m *LeagueMutation) CountryCleared() bool {
	return m.clearedcountry
}

// CountryID returns the "country" edge ID in the mutation.
func (m *LeagueMutation) CountryID() (id int, exists bool) {
	if m.country != nil {
		return *m.country, true
	}
	return
}

// CountryIDs returns the "country" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CountryID instead. It exists only for internal usage by the builders.
func (m *LeagueMutation) CountryIDs() (ids []int) {
	if id := m.country; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCountry resets all changes to the "country" edge.
func (m *LeagueMutation) ResetCountry() {
	m.country = nil
	m.clearedcountry = false
}

// AddSeasonIDs adds the "season" edge to the Season entity by ids.
func (m *LeagueMutation) AddSeasonIDs(ids ...int) {
	if m.season == nil {
		m.season = make(map[int]struct{})
	}
	for i := range ids {
		m.season[ids[i]] = struct{}{}
	}
}

// ClearSeason clears the "season" edge to the Season entity.
func (m *LeagueMutation) ClearSeason() {
	m.clearedseason = true
}

// SeasonCleared reports if the "season" edge to the Season entity was cleared.
func (m *LeagueMutation) SeasonCleared() bool {
	return m.clearedseason
}

// RemoveSeasonIDs removes the "season" edge to the Season entity by IDs.
func (m *LeagueMutation) RemoveSeasonIDs(ids ...int) {
	if m.removedseason == nil {
		m.removedseason = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.season, ids[i])
		m.removedseason[ids[i]] = struct{}{}
	}
}

// RemovedSeason returns the removed IDs of the "season" edge to the Season entity.
func (m *LeagueMutation) RemovedSeasonIDs() (ids []int) {
	for id := range m.removedseason {
		ids = append(ids, id)
	}
	return
}

// SeasonIDs returns the "season" edge IDs in the mutation.
func (m *LeagueMutation) SeasonIDs() (ids []int) {
	for id := range m.season {
		ids = append(ids, id)
	}
	return
}

// ResetSeason resets all changes to the "season" edge.
func (m *LeagueMutation) ResetSeason() {
	m.season = nil
	m.clearedseason = false
	m.removedseason = nil
}

// Where appends a list predicates to the LeagueMutation builder.
func (m *LeagueMutation) Where(ps ...predicate.League) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LeagueMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LeagueMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.League, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LeagueMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LeagueMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (League).
func (m *LeagueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LeagueMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.footballApiId != nil {
		fields = append(fields, league.FieldFootballApiId)
	}
	if m.slug != nil {
		fields = append(fields, league.FieldSlug)
	}
	if m.name != nil {
		fields = append(fields, league.FieldName)
	}
	if m._type != nil {
		fields = append(fields, league.FieldType)
	}
	if m.logo != nil {
		fields = append(fields, league.FieldLogo)
	}
	if m.lastUpdated != nil {
		fields = append(fields, league.FieldLastUpdated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LeagueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case league.FieldFootballApiId:
		return m.FootballApiId()
	case league.FieldSlug:
		return m.Slug()
	case league.FieldName:
		return m.Name()
	case league.FieldType:
		return m.GetType()
	case league.FieldLogo:
		return m.Logo()
	case league.FieldLastUpdated:
		return m.LastUpdated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LeagueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case league.FieldFootballApiId:
		return m.OldFootballApiId(ctx)
	case league.FieldSlug:
		return m.OldSlug(ctx)
	case league.FieldName:
		return m.OldName(ctx)
	case league.FieldType:
		return m.OldType(ctx)
	case league.FieldLogo:
		return m.OldLogo(ctx)
	case league.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	}
	return nil, fmt.Errorf("unknown League field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LeagueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case league.FieldFootballApiId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFootballApiId(v)
		return nil
	case league.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case league.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case league.FieldType:
		v, ok := value.(league.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case league.FieldLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogo(v)
		return nil
	case league.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	}
	return fmt.Errorf("unknown League field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LeagueMutation) AddedFields() []string {
	var fields []string
	if m.addfootballApiId != nil {
		fields = append(fields, league.FieldFootballApiId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LeagueMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case league.FieldFootballApiId:
		return m.AddedFootballApiId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LeagueMutation) AddField(name string, value ent.Value) error {
	switch name {
	case league.FieldFootballApiId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFootballApiId(v)
		return nil
	}
	return fmt.Errorf("unknown League numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LeagueMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(league.FieldLastUpdated) {
		fields = append(fields, league.FieldLastUpdated)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LeagueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LeagueMutation) ClearField(name string) error {
	switch name {
	case league.FieldLastUpdated:
		m.ClearLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown League nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LeagueMutation) ResetField(name string) error {
	switch name {
	case league.FieldFootballApiId:
		m.ResetFootballApiId()
		return nil
	case league.FieldSlug:
		m.ResetSlug()
		return nil
	case league.FieldName:
		m.ResetName()
		return nil
	case league.FieldType:
		m.ResetType()
		return nil
	case league.FieldLogo:
		m.ResetLogo()
		return nil
	case league.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown League field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LeagueMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.country != nil {
		edges = append(edges, league.EdgeCountry)
	}
	if m.season != nil {
		edges = append(edges, league.EdgeSeason)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LeagueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case league.EdgeCountry:
		if id := m.country; id != nil {
			return []ent.Value{*id}
		}
	case league.EdgeSeason:
		ids := make([]ent.Value, 0, len(m.season))
		for id := range m.season {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LeagueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedseason != nil {
		edges = append(edges, league.EdgeSeason)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LeagueMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case league.EdgeSeason:
		ids := make([]ent.Value, 0, len(m.removedseason))
		for id := range m.removedseason {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LeagueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcountry {
		edges = append(edges, league.EdgeCountry)
	}
	if m.clearedseason {
		edges = append(edges, league.EdgeSeason)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LeagueMutation) EdgeCleared(name string) bool {
	switch name {
	case league.EdgeCountry:
		return m.clearedcountry
	case league.EdgeSeason:
		return m.clearedseason
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LeagueMutation) ClearEdge(name string) error {
	switch name {
	case league.EdgeCountry:
		m.ClearCountry()
		return nil
	}
	return fmt.Errorf("unknown League unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LeagueMutation) ResetEdge(name string) error {
	switch name {
	case league.EdgeCountry:
		m.ResetCountry()
		return nil
	case league.EdgeSeason:
		m.ResetSeason()
		return nil
	}
	return fmt.Errorf("unknown League edge %s", name)
}

// MatchPlayerMutation represents an operation that mutates the MatchPlayer nodes in the graph.
type MatchPlayerMutation struct {
	config
	op            Op
	typ           string
	id            *int
	number        *int
	addnumber     *int
	position      *string
	x             *string
	y             *string
	lastUpdated   *time.Time
	clearedFields map[string]struct{}
	player        *int
	clearedplayer bool
	lineup        *int
	clearedlineup bool
	done          bool
	oldValue      func(context.Context) (*MatchPlayer, error)
	predicates    []predicate.MatchPlayer
}

var _ ent.Mutation = (*MatchPlayerMutation)(nil)

// matchplayerOption allows management of the mutation configuration using functional options.
type matchplayerOption func(*MatchPlayerMutation)

// newMatchPlayerMutation creates new mutation for the MatchPlayer entity.
func newMatchPlayerMutation(c config, op Op, opts ...matchplayerOption) *MatchPlayerMutation {
	m := &MatchPlayerMutation{
		config:        c,
		op:            op,
		typ:           TypeMatchPlayer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMatchPlayerID sets the ID field of the mutation.
func withMatchPlayerID(id int) matchplayerOption {
	return func(m *MatchPlayerMutation) {
		var (
			err   error
			once  sync.Once
			value *MatchPlayer
		)
		m.oldValue = func(ctx context.Context) (*MatchPlayer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MatchPlayer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMatchPlayer sets the old MatchPlayer of the mutation.
func withMatchPlayer(node *MatchPlayer) matchplayerOption {
	return func(m *MatchPlayerMutation) {
		m.oldValue = func(context.Context) (*MatchPlayer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MatchPlayerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MatchPlayerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MatchPlayerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MatchPlayerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MatchPlayer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNumber sets the "number" field.
func (m *MatchPlayerMutation) SetNumber(i int) {
	m.number = &i
	m.addnumber = nil
}

// Number returns the value of the "number" field in the mutation.
func (m *MatchPlayerMutation) Number() (r int, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the MatchPlayer entity.
// If the MatchPlayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchPlayerMutation) OldNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// AddNumber adds i to the "number" field.
func (m *MatchPlayerMutation) AddNumber(i int) {
	if m.addnumber != nil {
		*m.addnumber += i
	} else {
		m.addnumber = &i
	}
}

// AddedNumber returns the value that was added to the "number" field in this mutation.
func (m *MatchPlayerMutation) AddedNumber() (r int, exists bool) {
	v := m.addnumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber resets all changes to the "number" field.
func (m *MatchPlayerMutation) ResetNumber() {
	m.number = nil
	m.addnumber = nil
}

// SetPosition sets the "position" field.
func (m *MatchPlayerMutation) SetPosition(s string) {
	m.position = &s
}

// Position returns the value of the "position" field in the mutation.
func (m *MatchPlayerMutation) Position() (r string, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old "position" field's value of the MatchPlayer entity.
// If the MatchPlayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchPlayerMutation) OldPosition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// ResetPosition resets all changes to the "position" field.
func (m *MatchPlayerMutation) ResetPosition() {
	m.position = nil
}

// SetX sets the "x" field.
func (m *MatchPlayerMutation) SetX(s string) {
	m.x = &s
}

// X returns the value of the "x" field in the mutation.
func (m *MatchPlayerMutation) X() (r string, exists bool) {
	v := m.x
	if v == nil {
		return
	}
	return *v, true
}

// OldX returns the old "x" field's value of the MatchPlayer entity.
// If the MatchPlayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchPlayerMutation) OldX(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldX is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldX requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldX: %w", err)
	}
	return oldValue.X, nil
}

// ResetX resets all changes to the "x" field.
func (m *MatchPlayerMutation) ResetX() {
	m.x = nil
}

// SetY sets the "y" field.
func (m *MatchPlayerMutation) SetY(s string) {
	m.y = &s
}

// Y returns the value of the "y" field in the mutation.
func (m *MatchPlayerMutation) Y() (r string, exists bool) {
	v := m.y
	if v == nil {
		return
	}
	return *v, true
}

// OldY returns the old "y" field's value of the MatchPlayer entity.
// If the MatchPlayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchPlayerMutation) OldY(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldY is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldY requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldY: %w", err)
	}
	return oldValue.Y, nil
}

// ResetY resets all changes to the "y" field.
func (m *MatchPlayerMutation) ResetY() {
	m.y = nil
}

// SetLastUpdated sets the "lastUpdated" field.
func (m *MatchPlayerMutation) SetLastUpdated(t time.Time) {
	m.lastUpdated = &t
}

// LastUpdated returns the value of the "lastUpdated" field in the mutation.
func (m *MatchPlayerMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.lastUpdated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "lastUpdated" field's value of the MatchPlayer entity.
// If the MatchPlayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchPlayerMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ClearLastUpdated clears the value of the "lastUpdated" field.
func (m *MatchPlayerMutation) ClearLastUpdated() {
	m.lastUpdated = nil
	m.clearedFields[matchplayer.FieldLastUpdated] = struct{}{}
}

// LastUpdatedCleared returns if the "lastUpdated" field was cleared in this mutation.
func (m *MatchPlayerMutation) LastUpdatedCleared() bool {
	_, ok := m.clearedFields[matchplayer.FieldLastUpdated]
	return ok
}

// ResetLastUpdated resets all changes to the "lastUpdated" field.
func (m *MatchPlayerMutation) ResetLastUpdated() {
	m.lastUpdated = nil
	delete(m.clearedFields, matchplayer.FieldLastUpdated)
}

// SetPlayerID sets the "player" edge to the Player entity by id.
func (m *MatchPlayerMutation) SetPlayerID(id int) {
	m.player = &id
}

// ClearPlayer clears the "player" edge to the Player entity.
func (m *MatchPlayerMutation) ClearPlayer() {
	m.clearedplayer = true
}

// PlayerCleared reports if the "player" edge to the Player entity was cleared.
func (m *MatchPlayerMutation) PlayerCleared() bool {
	return m.clearedplayer
}

// PlayerID returns the "player" edge ID in the mutation.
func (m *MatchPlayerMutation) PlayerID() (id int, exists bool) {
	if m.player != nil {
		return *m.player, true
	}
	return
}

// PlayerIDs returns the "player" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlayerID instead. It exists only for internal usage by the builders.
func (m *MatchPlayerMutation) PlayerIDs() (ids []int) {
	if id := m.player; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlayer resets all changes to the "player" edge.
func (m *MatchPlayerMutation) ResetPlayer() {
	m.player = nil
	m.clearedplayer = false
}

// SetLineupID sets the "lineup" edge to the FixtureLineups entity by id.
func (m *MatchPlayerMutation) SetLineupID(id int) {
	m.lineup = &id
}

// ClearLineup clears the "lineup" edge to the FixtureLineups entity.
func (m *MatchPlayerMutation) ClearLineup() {
	m.clearedlineup = true
}

// LineupCleared reports if the "lineup" edge to the FixtureLineups entity was cleared.
func (m *MatchPlayerMutation) LineupCleared() bool {
	return m.clearedlineup
}

// LineupID returns the "lineup" edge ID in the mutation.
func (m *MatchPlayerMutation) LineupID() (id int, exists bool) {
	if m.lineup != nil {
		return *m.lineup, true
	}
	return
}

// LineupIDs returns the "lineup" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LineupID instead. It exists only for internal usage by the builders.
func (m *MatchPlayerMutation) LineupIDs() (ids []int) {
	if id := m.lineup; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLineup resets all changes to the "lineup" edge.
func (m *MatchPlayerMutation) ResetLineup() {
	m.lineup = nil
	m.clearedlineup = false
}

// Where appends a list predicates to the MatchPlayerMutation builder.
func (m *MatchPlayerMutation) Where(ps ...predicate.MatchPlayer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MatchPlayerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MatchPlayerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MatchPlayer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MatchPlayerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MatchPlayerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MatchPlayer).
func (m *MatchPlayerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MatchPlayerMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.number != nil {
		fields = append(fields, matchplayer.FieldNumber)
	}
	if m.position != nil {
		fields = append(fields, matchplayer.FieldPosition)
	}
	if m.x != nil {
		fields = append(fields, matchplayer.FieldX)
	}
	if m.y != nil {
		fields = append(fields, matchplayer.FieldY)
	}
	if m.lastUpdated != nil {
		fields = append(fields, matchplayer.FieldLastUpdated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MatchPlayerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case matchplayer.FieldNumber:
		return m.Number()
	case matchplayer.FieldPosition:
		return m.Position()
	case matchplayer.FieldX:
		return m.X()
	case matchplayer.FieldY:
		return m.Y()
	case matchplayer.FieldLastUpdated:
		return m.LastUpdated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MatchPlayerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case matchplayer.FieldNumber:
		return m.OldNumber(ctx)
	case matchplayer.FieldPosition:
		return m.OldPosition(ctx)
	case matchplayer.FieldX:
		return m.OldX(ctx)
	case matchplayer.FieldY:
		return m.OldY(ctx)
	case matchplayer.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	}
	return nil, fmt.Errorf("unknown MatchPlayer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MatchPlayerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case matchplayer.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case matchplayer.FieldPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	case matchplayer.FieldX:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetX(v)
		return nil
	case matchplayer.FieldY:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetY(v)
		return nil
	case matchplayer.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	}
	return fmt.Errorf("unknown MatchPlayer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MatchPlayerMutation) AddedFields() []string {
	var fields []string
	if m.addnumber != nil {
		fields = append(fields, matchplayer.FieldNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MatchPlayerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case matchplayer.FieldNumber:
		return m.AddedNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MatchPlayerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case matchplayer.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber(v)
		return nil
	}
	return fmt.Errorf("unknown MatchPlayer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MatchPlayerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(matchplayer.FieldLastUpdated) {
		fields = append(fields, matchplayer.FieldLastUpdated)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MatchPlayerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MatchPlayerMutation) ClearField(name string) error {
	switch name {
	case matchplayer.FieldLastUpdated:
		m.ClearLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown MatchPlayer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MatchPlayerMutation) ResetField(name string) error {
	switch name {
	case matchplayer.FieldNumber:
		m.ResetNumber()
		return nil
	case matchplayer.FieldPosition:
		m.ResetPosition()
		return nil
	case matchplayer.FieldX:
		m.ResetX()
		return nil
	case matchplayer.FieldY:
		m.ResetY()
		return nil
	case matchplayer.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown MatchPlayer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MatchPlayerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.player != nil {
		edges = append(edges, matchplayer.EdgePlayer)
	}
	if m.lineup != nil {
		edges = append(edges, matchplayer.EdgeLineup)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MatchPlayerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case matchplayer.EdgePlayer:
		if id := m.player; id != nil {
			return []ent.Value{*id}
		}
	case matchplayer.EdgeLineup:
		if id := m.lineup; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MatchPlayerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MatchPlayerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MatchPlayerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedplayer {
		edges = append(edges, matchplayer.EdgePlayer)
	}
	if m.clearedlineup {
		edges = append(edges, matchplayer.EdgeLineup)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MatchPlayerMutation) EdgeCleared(name string) bool {
	switch name {
	case matchplayer.EdgePlayer:
		return m.clearedplayer
	case matchplayer.EdgeLineup:
		return m.clearedlineup
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MatchPlayerMutation) ClearEdge(name string) error {
	switch name {
	case matchplayer.EdgePlayer:
		m.ClearPlayer()
		return nil
	case matchplayer.EdgeLineup:
		m.ClearLineup()
		return nil
	}
	return fmt.Errorf("unknown MatchPlayer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MatchPlayerMutation) ResetEdge(name string) error {
	switch name {
	case matchplayer.EdgePlayer:
		m.ResetPlayer()
		return nil
	case matchplayer.EdgeLineup:
		m.ResetLineup()
		return nil
	}
	return fmt.Errorf("unknown MatchPlayer edge %s", name)
}

// PlayerMutation represents an operation that mutates the Player nodes in the graph.
type PlayerMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	slug                *string
	_ApiFootballId      *int
	add_ApiFootballId   *int
	name                *string
	firstname           *string
	lastname            *string
	age                 *int
	addage              *int
	height              *string
	weight              *string
	injured             *bool
	photo               *string
	lastUpdated         *time.Time
	clearedFields       map[string]struct{}
	birth               *int
	clearedbirth        bool
	nationality         *int
	clearednationality  bool
	squad               map[int]struct{}
	removedsquad        map[int]struct{}
	clearedsquad        bool
	playerEvents        map[int]struct{}
	removedplayerEvents map[int]struct{}
	clearedplayerEvents bool
	matchPlayer         map[int]struct{}
	removedmatchPlayer  map[int]struct{}
	clearedmatchPlayer  bool
	assistEvents        map[int]struct{}
	removedassistEvents map[int]struct{}
	clearedassistEvents bool
	done                bool
	oldValue            func(context.Context) (*Player, error)
	predicates          []predicate.Player
}

var _ ent.Mutation = (*PlayerMutation)(nil)

// playerOption allows management of the mutation configuration using functional options.
type playerOption func(*PlayerMutation)

// newPlayerMutation creates new mutation for the Player entity.
func newPlayerMutation(c config, op Op, opts ...playerOption) *PlayerMutation {
	m := &PlayerMutation{
		config:        c,
		op:            op,
		typ:           TypePlayer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlayerID sets the ID field of the mutation.
func withPlayerID(id int) playerOption {
	return func(m *PlayerMutation) {
		var (
			err   error
			once  sync.Once
			value *Player
		)
		m.oldValue = func(ctx context.Context) (*Player, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Player.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlayer sets the old Player of the mutation.
func withPlayer(node *Player) playerOption {
	return func(m *PlayerMutation) {
		m.oldValue = func(context.Context) (*Player, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlayerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlayerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlayerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlayerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Player.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSlug sets the "slug" field.
func (m *PlayerMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *PlayerMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *PlayerMutation) ResetSlug() {
	m.slug = nil
}

// SetApiFootballId sets the "ApiFootballId" field.
func (m *PlayerMutation) SetApiFootballId(i int) {
	m._ApiFootballId = &i
	m.add_ApiFootballId = nil
}

// ApiFootballId returns the value of the "ApiFootballId" field in the mutation.
func (m *PlayerMutation) ApiFootballId() (r int, exists bool) {
	v := m._ApiFootballId
	if v == nil {
		return
	}
	return *v, true
}

// OldApiFootballId returns the old "ApiFootballId" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldApiFootballId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApiFootballId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApiFootballId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApiFootballId: %w", err)
	}
	return oldValue.ApiFootballId, nil
}

// AddApiFootballId adds i to the "ApiFootballId" field.
func (m *PlayerMutation) AddApiFootballId(i int) {
	if m.add_ApiFootballId != nil {
		*m.add_ApiFootballId += i
	} else {
		m.add_ApiFootballId = &i
	}
}

// AddedApiFootballId returns the value that was added to the "ApiFootballId" field in this mutation.
func (m *PlayerMutation) AddedApiFootballId() (r int, exists bool) {
	v := m.add_ApiFootballId
	if v == nil {
		return
	}
	return *v, true
}

// ResetApiFootballId resets all changes to the "ApiFootballId" field.
func (m *PlayerMutation) ResetApiFootballId() {
	m._ApiFootballId = nil
	m.add_ApiFootballId = nil
}

// SetName sets the "name" field.
func (m *PlayerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PlayerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PlayerMutation) ResetName() {
	m.name = nil
}

// SetFirstname sets the "firstname" field.
func (m *PlayerMutation) SetFirstname(s string) {
	m.firstname = &s
}

// Firstname returns the value of the "firstname" field in the mutation.
func (m *PlayerMutation) Firstname() (r string, exists bool) {
	v := m.firstname
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstname returns the old "firstname" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldFirstname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstname: %w", err)
	}
	return oldValue.Firstname, nil
}

// ResetFirstname resets all changes to the "firstname" field.
func (m *PlayerMutation) ResetFirstname() {
	m.firstname = nil
}

// SetLastname sets the "lastname" field.
func (m *PlayerMutation) SetLastname(s string) {
	m.lastname = &s
}

// Lastname returns the value of the "lastname" field in the mutation.
func (m *PlayerMutation) Lastname() (r string, exists bool) {
	v := m.lastname
	if v == nil {
		return
	}
	return *v, true
}

// OldLastname returns the old "lastname" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldLastname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastname: %w", err)
	}
	return oldValue.Lastname, nil
}

// ResetLastname resets all changes to the "lastname" field.
func (m *PlayerMutation) ResetLastname() {
	m.lastname = nil
}

// SetAge sets the "age" field.
func (m *PlayerMutation) SetAge(i int) {
	m.age = &i
	m.addage = nil
}

// Age returns the value of the "age" field in the mutation.
func (m *PlayerMutation) Age() (r int, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old "age" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldAge(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds i to the "age" field.
func (m *PlayerMutation) AddAge(i int) {
	if m.addage != nil {
		*m.addage += i
	} else {
		m.addage = &i
	}
}

// AddedAge returns the value that was added to the "age" field in this mutation.
func (m *PlayerMutation) AddedAge() (r int, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ResetAge resets all changes to the "age" field.
func (m *PlayerMutation) ResetAge() {
	m.age = nil
	m.addage = nil
}

// SetHeight sets the "height" field.
func (m *PlayerMutation) SetHeight(s string) {
	m.height = &s
}

// Height returns the value of the "height" field in the mutation.
func (m *PlayerMutation) Height() (r string, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldHeight(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// ResetHeight resets all changes to the "height" field.
func (m *PlayerMutation) ResetHeight() {
	m.height = nil
}

// SetWeight sets the "weight" field.
func (m *PlayerMutation) SetWeight(s string) {
	m.weight = &s
}

// Weight returns the value of the "weight" field in the mutation.
func (m *PlayerMutation) Weight() (r string, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldWeight(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// ResetWeight resets all changes to the "weight" field.
func (m *PlayerMutation) ResetWeight() {
	m.weight = nil
}

// SetInjured sets the "injured" field.
func (m *PlayerMutation) SetInjured(b bool) {
	m.injured = &b
}

// Injured returns the value of the "injured" field in the mutation.
func (m *PlayerMutation) Injured() (r bool, exists bool) {
	v := m.injured
	if v == nil {
		return
	}
	return *v, true
}

// OldInjured returns the old "injured" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldInjured(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInjured is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInjured requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInjured: %w", err)
	}
	return oldValue.Injured, nil
}

// ResetInjured resets all changes to the "injured" field.
func (m *PlayerMutation) ResetInjured() {
	m.injured = nil
}

// SetPhoto sets the "photo" field.
func (m *PlayerMutation) SetPhoto(s string) {
	m.photo = &s
}

// Photo returns the value of the "photo" field in the mutation.
func (m *PlayerMutation) Photo() (r string, exists bool) {
	v := m.photo
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoto returns the old "photo" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldPhoto(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoto is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoto requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoto: %w", err)
	}
	return oldValue.Photo, nil
}

// ResetPhoto resets all changes to the "photo" field.
func (m *PlayerMutation) ResetPhoto() {
	m.photo = nil
}

// SetLastUpdated sets the "lastUpdated" field.
func (m *PlayerMutation) SetLastUpdated(t time.Time) {
	m.lastUpdated = &t
}

// LastUpdated returns the value of the "lastUpdated" field in the mutation.
func (m *PlayerMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.lastUpdated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "lastUpdated" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ClearLastUpdated clears the value of the "lastUpdated" field.
func (m *PlayerMutation) ClearLastUpdated() {
	m.lastUpdated = nil
	m.clearedFields[player.FieldLastUpdated] = struct{}{}
}

// LastUpdatedCleared returns if the "lastUpdated" field was cleared in this mutation.
func (m *PlayerMutation) LastUpdatedCleared() bool {
	_, ok := m.clearedFields[player.FieldLastUpdated]
	return ok
}

// ResetLastUpdated resets all changes to the "lastUpdated" field.
func (m *PlayerMutation) ResetLastUpdated() {
	m.lastUpdated = nil
	delete(m.clearedFields, player.FieldLastUpdated)
}

// SetBirthID sets the "birth" edge to the Birth entity by id.
func (m *PlayerMutation) SetBirthID(id int) {
	m.birth = &id
}

// ClearBirth clears the "birth" edge to the Birth entity.
func (m *PlayerMutation) ClearBirth() {
	m.clearedbirth = true
}

// BirthCleared reports if the "birth" edge to the Birth entity was cleared.
func (m *PlayerMutation) BirthCleared() bool {
	return m.clearedbirth
}

// BirthID returns the "birth" edge ID in the mutation.
func (m *PlayerMutation) BirthID() (id int, exists bool) {
	if m.birth != nil {
		return *m.birth, true
	}
	return
}

// BirthIDs returns the "birth" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BirthID instead. It exists only for internal usage by the builders.
func (m *PlayerMutation) BirthIDs() (ids []int) {
	if id := m.birth; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBirth resets all changes to the "birth" edge.
func (m *PlayerMutation) ResetBirth() {
	m.birth = nil
	m.clearedbirth = false
}

// SetNationalityID sets the "nationality" edge to the Country entity by id.
func (m *PlayerMutation) SetNationalityID(id int) {
	m.nationality = &id
}

// ClearNationality clears the "nationality" edge to the Country entity.
func (m *PlayerMutation) ClearNationality() {
	m.clearednationality = true
}

// NationalityCleared reports if the "nationality" edge to the Country entity was cleared.
func (m *PlayerMutation) NationalityCleared() bool {
	return m.clearednationality
}

// NationalityID returns the "nationality" edge ID in the mutation.
func (m *PlayerMutation) NationalityID() (id int, exists bool) {
	if m.nationality != nil {
		return *m.nationality, true
	}
	return
}

// NationalityIDs returns the "nationality" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NationalityID instead. It exists only for internal usage by the builders.
func (m *PlayerMutation) NationalityIDs() (ids []int) {
	if id := m.nationality; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNationality resets all changes to the "nationality" edge.
func (m *PlayerMutation) ResetNationality() {
	m.nationality = nil
	m.clearednationality = false
}

// AddSquadIDs adds the "squad" edge to the Squad entity by ids.
func (m *PlayerMutation) AddSquadIDs(ids ...int) {
	if m.squad == nil {
		m.squad = make(map[int]struct{})
	}
	for i := range ids {
		m.squad[ids[i]] = struct{}{}
	}
}

// ClearSquad clears the "squad" edge to the Squad entity.
func (m *PlayerMutation) ClearSquad() {
	m.clearedsquad = true
}

// SquadCleared reports if the "squad" edge to the Squad entity was cleared.
func (m *PlayerMutation) SquadCleared() bool {
	return m.clearedsquad
}

// RemoveSquadIDs removes the "squad" edge to the Squad entity by IDs.
func (m *PlayerMutation) RemoveSquadIDs(ids ...int) {
	if m.removedsquad == nil {
		m.removedsquad = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.squad, ids[i])
		m.removedsquad[ids[i]] = struct{}{}
	}
}

// RemovedSquad returns the removed IDs of the "squad" edge to the Squad entity.
func (m *PlayerMutation) RemovedSquadIDs() (ids []int) {
	for id := range m.removedsquad {
		ids = append(ids, id)
	}
	return
}

// SquadIDs returns the "squad" edge IDs in the mutation.
func (m *PlayerMutation) SquadIDs() (ids []int) {
	for id := range m.squad {
		ids = append(ids, id)
	}
	return
}

// ResetSquad resets all changes to the "squad" edge.
func (m *PlayerMutation) ResetSquad() {
	m.squad = nil
	m.clearedsquad = false
	m.removedsquad = nil
}

// AddPlayerEventIDs adds the "playerEvents" edge to the FixtureEvents entity by ids.
func (m *PlayerMutation) AddPlayerEventIDs(ids ...int) {
	if m.playerEvents == nil {
		m.playerEvents = make(map[int]struct{})
	}
	for i := range ids {
		m.playerEvents[ids[i]] = struct{}{}
	}
}

// ClearPlayerEvents clears the "playerEvents" edge to the FixtureEvents entity.
func (m *PlayerMutation) ClearPlayerEvents() {
	m.clearedplayerEvents = true
}

// PlayerEventsCleared reports if the "playerEvents" edge to the FixtureEvents entity was cleared.
func (m *PlayerMutation) PlayerEventsCleared() bool {
	return m.clearedplayerEvents
}

// RemovePlayerEventIDs removes the "playerEvents" edge to the FixtureEvents entity by IDs.
func (m *PlayerMutation) RemovePlayerEventIDs(ids ...int) {
	if m.removedplayerEvents == nil {
		m.removedplayerEvents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.playerEvents, ids[i])
		m.removedplayerEvents[ids[i]] = struct{}{}
	}
}

// RemovedPlayerEvents returns the removed IDs of the "playerEvents" edge to the FixtureEvents entity.
func (m *PlayerMutation) RemovedPlayerEventsIDs() (ids []int) {
	for id := range m.removedplayerEvents {
		ids = append(ids, id)
	}
	return
}

// PlayerEventsIDs returns the "playerEvents" edge IDs in the mutation.
func (m *PlayerMutation) PlayerEventsIDs() (ids []int) {
	for id := range m.playerEvents {
		ids = append(ids, id)
	}
	return
}

// ResetPlayerEvents resets all changes to the "playerEvents" edge.
func (m *PlayerMutation) ResetPlayerEvents() {
	m.playerEvents = nil
	m.clearedplayerEvents = false
	m.removedplayerEvents = nil
}

// AddMatchPlayerIDs adds the "matchPlayer" edge to the MatchPlayer entity by ids.
func (m *PlayerMutation) AddMatchPlayerIDs(ids ...int) {
	if m.matchPlayer == nil {
		m.matchPlayer = make(map[int]struct{})
	}
	for i := range ids {
		m.matchPlayer[ids[i]] = struct{}{}
	}
}

// ClearMatchPlayer clears the "matchPlayer" edge to the MatchPlayer entity.
func (m *PlayerMutation) ClearMatchPlayer() {
	m.clearedmatchPlayer = true
}

// MatchPlayerCleared reports if the "matchPlayer" edge to the MatchPlayer entity was cleared.
func (m *PlayerMutation) MatchPlayerCleared() bool {
	return m.clearedmatchPlayer
}

// RemoveMatchPlayerIDs removes the "matchPlayer" edge to the MatchPlayer entity by IDs.
func (m *PlayerMutation) RemoveMatchPlayerIDs(ids ...int) {
	if m.removedmatchPlayer == nil {
		m.removedmatchPlayer = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.matchPlayer, ids[i])
		m.removedmatchPlayer[ids[i]] = struct{}{}
	}
}

// RemovedMatchPlayer returns the removed IDs of the "matchPlayer" edge to the MatchPlayer entity.
func (m *PlayerMutation) RemovedMatchPlayerIDs() (ids []int) {
	for id := range m.removedmatchPlayer {
		ids = append(ids, id)
	}
	return
}

// MatchPlayerIDs returns the "matchPlayer" edge IDs in the mutation.
func (m *PlayerMutation) MatchPlayerIDs() (ids []int) {
	for id := range m.matchPlayer {
		ids = append(ids, id)
	}
	return
}

// ResetMatchPlayer resets all changes to the "matchPlayer" edge.
func (m *PlayerMutation) ResetMatchPlayer() {
	m.matchPlayer = nil
	m.clearedmatchPlayer = false
	m.removedmatchPlayer = nil
}

// AddAssistEventIDs adds the "assistEvents" edge to the FixtureEvents entity by ids.
func (m *PlayerMutation) AddAssistEventIDs(ids ...int) {
	if m.assistEvents == nil {
		m.assistEvents = make(map[int]struct{})
	}
	for i := range ids {
		m.assistEvents[ids[i]] = struct{}{}
	}
}

// ClearAssistEvents clears the "assistEvents" edge to the FixtureEvents entity.
func (m *PlayerMutation) ClearAssistEvents() {
	m.clearedassistEvents = true
}

// AssistEventsCleared reports if the "assistEvents" edge to the FixtureEvents entity was cleared.
func (m *PlayerMutation) AssistEventsCleared() bool {
	return m.clearedassistEvents
}

// RemoveAssistEventIDs removes the "assistEvents" edge to the FixtureEvents entity by IDs.
func (m *PlayerMutation) RemoveAssistEventIDs(ids ...int) {
	if m.removedassistEvents == nil {
		m.removedassistEvents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.assistEvents, ids[i])
		m.removedassistEvents[ids[i]] = struct{}{}
	}
}

// RemovedAssistEvents returns the removed IDs of the "assistEvents" edge to the FixtureEvents entity.
func (m *PlayerMutation) RemovedAssistEventsIDs() (ids []int) {
	for id := range m.removedassistEvents {
		ids = append(ids, id)
	}
	return
}

// AssistEventsIDs returns the "assistEvents" edge IDs in the mutation.
func (m *PlayerMutation) AssistEventsIDs() (ids []int) {
	for id := range m.assistEvents {
		ids = append(ids, id)
	}
	return
}

// ResetAssistEvents resets all changes to the "assistEvents" edge.
func (m *PlayerMutation) ResetAssistEvents() {
	m.assistEvents = nil
	m.clearedassistEvents = false
	m.removedassistEvents = nil
}

// Where appends a list predicates to the PlayerMutation builder.
func (m *PlayerMutation) Where(ps ...predicate.Player) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlayerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlayerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Player, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlayerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlayerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Player).
func (m *PlayerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlayerMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.slug != nil {
		fields = append(fields, player.FieldSlug)
	}
	if m._ApiFootballId != nil {
		fields = append(fields, player.FieldApiFootballId)
	}
	if m.name != nil {
		fields = append(fields, player.FieldName)
	}
	if m.firstname != nil {
		fields = append(fields, player.FieldFirstname)
	}
	if m.lastname != nil {
		fields = append(fields, player.FieldLastname)
	}
	if m.age != nil {
		fields = append(fields, player.FieldAge)
	}
	if m.height != nil {
		fields = append(fields, player.FieldHeight)
	}
	if m.weight != nil {
		fields = append(fields, player.FieldWeight)
	}
	if m.injured != nil {
		fields = append(fields, player.FieldInjured)
	}
	if m.photo != nil {
		fields = append(fields, player.FieldPhoto)
	}
	if m.lastUpdated != nil {
		fields = append(fields, player.FieldLastUpdated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlayerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case player.FieldSlug:
		return m.Slug()
	case player.FieldApiFootballId:
		return m.ApiFootballId()
	case player.FieldName:
		return m.Name()
	case player.FieldFirstname:
		return m.Firstname()
	case player.FieldLastname:
		return m.Lastname()
	case player.FieldAge:
		return m.Age()
	case player.FieldHeight:
		return m.Height()
	case player.FieldWeight:
		return m.Weight()
	case player.FieldInjured:
		return m.Injured()
	case player.FieldPhoto:
		return m.Photo()
	case player.FieldLastUpdated:
		return m.LastUpdated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlayerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case player.FieldSlug:
		return m.OldSlug(ctx)
	case player.FieldApiFootballId:
		return m.OldApiFootballId(ctx)
	case player.FieldName:
		return m.OldName(ctx)
	case player.FieldFirstname:
		return m.OldFirstname(ctx)
	case player.FieldLastname:
		return m.OldLastname(ctx)
	case player.FieldAge:
		return m.OldAge(ctx)
	case player.FieldHeight:
		return m.OldHeight(ctx)
	case player.FieldWeight:
		return m.OldWeight(ctx)
	case player.FieldInjured:
		return m.OldInjured(ctx)
	case player.FieldPhoto:
		return m.OldPhoto(ctx)
	case player.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	}
	return nil, fmt.Errorf("unknown Player field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlayerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case player.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case player.FieldApiFootballId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApiFootballId(v)
		return nil
	case player.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case player.FieldFirstname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstname(v)
		return nil
	case player.FieldLastname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastname(v)
		return nil
	case player.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case player.FieldHeight:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case player.FieldWeight:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case player.FieldInjured:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInjured(v)
		return nil
	case player.FieldPhoto:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoto(v)
		return nil
	case player.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	}
	return fmt.Errorf("unknown Player field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlayerMutation) AddedFields() []string {
	var fields []string
	if m.add_ApiFootballId != nil {
		fields = append(fields, player.FieldApiFootballId)
	}
	if m.addage != nil {
		fields = append(fields, player.FieldAge)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlayerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case player.FieldApiFootballId:
		return m.AddedApiFootballId()
	case player.FieldAge:
		return m.AddedAge()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlayerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case player.FieldApiFootballId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddApiFootballId(v)
		return nil
	case player.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	}
	return fmt.Errorf("unknown Player numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlayerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(player.FieldLastUpdated) {
		fields = append(fields, player.FieldLastUpdated)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlayerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlayerMutation) ClearField(name string) error {
	switch name {
	case player.FieldLastUpdated:
		m.ClearLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown Player nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlayerMutation) ResetField(name string) error {
	switch name {
	case player.FieldSlug:
		m.ResetSlug()
		return nil
	case player.FieldApiFootballId:
		m.ResetApiFootballId()
		return nil
	case player.FieldName:
		m.ResetName()
		return nil
	case player.FieldFirstname:
		m.ResetFirstname()
		return nil
	case player.FieldLastname:
		m.ResetLastname()
		return nil
	case player.FieldAge:
		m.ResetAge()
		return nil
	case player.FieldHeight:
		m.ResetHeight()
		return nil
	case player.FieldWeight:
		m.ResetWeight()
		return nil
	case player.FieldInjured:
		m.ResetInjured()
		return nil
	case player.FieldPhoto:
		m.ResetPhoto()
		return nil
	case player.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown Player field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlayerMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.birth != nil {
		edges = append(edges, player.EdgeBirth)
	}
	if m.nationality != nil {
		edges = append(edges, player.EdgeNationality)
	}
	if m.squad != nil {
		edges = append(edges, player.EdgeSquad)
	}
	if m.playerEvents != nil {
		edges = append(edges, player.EdgePlayerEvents)
	}
	if m.matchPlayer != nil {
		edges = append(edges, player.EdgeMatchPlayer)
	}
	if m.assistEvents != nil {
		edges = append(edges, player.EdgeAssistEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlayerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case player.EdgeBirth:
		if id := m.birth; id != nil {
			return []ent.Value{*id}
		}
	case player.EdgeNationality:
		if id := m.nationality; id != nil {
			return []ent.Value{*id}
		}
	case player.EdgeSquad:
		ids := make([]ent.Value, 0, len(m.squad))
		for id := range m.squad {
			ids = append(ids, id)
		}
		return ids
	case player.EdgePlayerEvents:
		ids := make([]ent.Value, 0, len(m.playerEvents))
		for id := range m.playerEvents {
			ids = append(ids, id)
		}
		return ids
	case player.EdgeMatchPlayer:
		ids := make([]ent.Value, 0, len(m.matchPlayer))
		for id := range m.matchPlayer {
			ids = append(ids, id)
		}
		return ids
	case player.EdgeAssistEvents:
		ids := make([]ent.Value, 0, len(m.assistEvents))
		for id := range m.assistEvents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlayerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedsquad != nil {
		edges = append(edges, player.EdgeSquad)
	}
	if m.removedplayerEvents != nil {
		edges = append(edges, player.EdgePlayerEvents)
	}
	if m.removedmatchPlayer != nil {
		edges = append(edges, player.EdgeMatchPlayer)
	}
	if m.removedassistEvents != nil {
		edges = append(edges, player.EdgeAssistEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlayerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case player.EdgeSquad:
		ids := make([]ent.Value, 0, len(m.removedsquad))
		for id := range m.removedsquad {
			ids = append(ids, id)
		}
		return ids
	case player.EdgePlayerEvents:
		ids := make([]ent.Value, 0, len(m.removedplayerEvents))
		for id := range m.removedplayerEvents {
			ids = append(ids, id)
		}
		return ids
	case player.EdgeMatchPlayer:
		ids := make([]ent.Value, 0, len(m.removedmatchPlayer))
		for id := range m.removedmatchPlayer {
			ids = append(ids, id)
		}
		return ids
	case player.EdgeAssistEvents:
		ids := make([]ent.Value, 0, len(m.removedassistEvents))
		for id := range m.removedassistEvents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlayerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedbirth {
		edges = append(edges, player.EdgeBirth)
	}
	if m.clearednationality {
		edges = append(edges, player.EdgeNationality)
	}
	if m.clearedsquad {
		edges = append(edges, player.EdgeSquad)
	}
	if m.clearedplayerEvents {
		edges = append(edges, player.EdgePlayerEvents)
	}
	if m.clearedmatchPlayer {
		edges = append(edges, player.EdgeMatchPlayer)
	}
	if m.clearedassistEvents {
		edges = append(edges, player.EdgeAssistEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlayerMutation) EdgeCleared(name string) bool {
	switch name {
	case player.EdgeBirth:
		return m.clearedbirth
	case player.EdgeNationality:
		return m.clearednationality
	case player.EdgeSquad:
		return m.clearedsquad
	case player.EdgePlayerEvents:
		return m.clearedplayerEvents
	case player.EdgeMatchPlayer:
		return m.clearedmatchPlayer
	case player.EdgeAssistEvents:
		return m.clearedassistEvents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlayerMutation) ClearEdge(name string) error {
	switch name {
	case player.EdgeBirth:
		m.ClearBirth()
		return nil
	case player.EdgeNationality:
		m.ClearNationality()
		return nil
	}
	return fmt.Errorf("unknown Player unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlayerMutation) ResetEdge(name string) error {
	switch name {
	case player.EdgeBirth:
		m.ResetBirth()
		return nil
	case player.EdgeNationality:
		m.ResetNationality()
		return nil
	case player.EdgeSquad:
		m.ResetSquad()
		return nil
	case player.EdgePlayerEvents:
		m.ResetPlayerEvents()
		return nil
	case player.EdgeMatchPlayer:
		m.ResetMatchPlayer()
		return nil
	case player.EdgeAssistEvents:
		m.ResetAssistEvents()
		return nil
	}
	return fmt.Errorf("unknown Player edge %s", name)
}

// SeasonMutation represents an operation that mutates the Season nodes in the graph.
type SeasonMutation struct {
	config
	op               Op
	typ              string
	id               *int
	slug             *string
	year             *int
	addyear          *int
	start_date       *time.Time
	end_date         *time.Time
	current          *bool
	lastUpdated      *time.Time
	clearedFields    map[string]struct{}
	league           *int
	clearedleague    bool
	fixtures         map[int]struct{}
	removedfixtures  map[int]struct{}
	clearedfixtures  bool
	standings        map[int]struct{}
	removedstandings map[int]struct{}
	clearedstandings bool
	teams            map[int]struct{}
	removedteams     map[int]struct{}
	clearedteams     bool
	done             bool
	oldValue         func(context.Context) (*Season, error)
	predicates       []predicate.Season
}

var _ ent.Mutation = (*SeasonMutation)(nil)

// seasonOption allows management of the mutation configuration using functional options.
type seasonOption func(*SeasonMutation)

// newSeasonMutation creates new mutation for the Season entity.
func newSeasonMutation(c config, op Op, opts ...seasonOption) *SeasonMutation {
	m := &SeasonMutation{
		config:        c,
		op:            op,
		typ:           TypeSeason,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSeasonID sets the ID field of the mutation.
func withSeasonID(id int) seasonOption {
	return func(m *SeasonMutation) {
		var (
			err   error
			once  sync.Once
			value *Season
		)
		m.oldValue = func(ctx context.Context) (*Season, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Season.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSeason sets the old Season of the mutation.
func withSeason(node *Season) seasonOption {
	return func(m *SeasonMutation) {
		m.oldValue = func(context.Context) (*Season, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SeasonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SeasonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SeasonMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SeasonMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Season.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSlug sets the "slug" field.
func (m *SeasonMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *SeasonMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Season entity.
// If the Season object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeasonMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *SeasonMutation) ResetSlug() {
	m.slug = nil
}

// SetYear sets the "year" field.
func (m *SeasonMutation) SetYear(i int) {
	m.year = &i
	m.addyear = nil
}

// Year returns the value of the "year" field in the mutation.
func (m *SeasonMutation) Year() (r int, exists bool) {
	v := m.year
	if v == nil {
		return
	}
	return *v, true
}

// OldYear returns the old "year" field's value of the Season entity.
// If the Season object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeasonMutation) OldYear(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYear: %w", err)
	}
	return oldValue.Year, nil
}

// AddYear adds i to the "year" field.
func (m *SeasonMutation) AddYear(i int) {
	if m.addyear != nil {
		*m.addyear += i
	} else {
		m.addyear = &i
	}
}

// AddedYear returns the value that was added to the "year" field in this mutation.
func (m *SeasonMutation) AddedYear() (r int, exists bool) {
	v := m.addyear
	if v == nil {
		return
	}
	return *v, true
}

// ResetYear resets all changes to the "year" field.
func (m *SeasonMutation) ResetYear() {
	m.year = nil
	m.addyear = nil
}

// SetStartDate sets the "start_date" field.
func (m *SeasonMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *SeasonMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Season entity.
// If the Season object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeasonMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *SeasonMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *SeasonMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *SeasonMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Season entity.
// If the Season object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeasonMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *SeasonMutation) ResetEndDate() {
	m.end_date = nil
}

// SetCurrent sets the "current" field.
func (m *SeasonMutation) SetCurrent(b bool) {
	m.current = &b
}

// Current returns the value of the "current" field in the mutation.
func (m *SeasonMutation) Current() (r bool, exists bool) {
	v := m.current
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrent returns the old "current" field's value of the Season entity.
// If the Season object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeasonMutation) OldCurrent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrent: %w", err)
	}
	return oldValue.Current, nil
}

// ResetCurrent resets all changes to the "current" field.
func (m *SeasonMutation) ResetCurrent() {
	m.current = nil
}

// SetLastUpdated sets the "lastUpdated" field.
func (m *SeasonMutation) SetLastUpdated(t time.Time) {
	m.lastUpdated = &t
}

// LastUpdated returns the value of the "lastUpdated" field in the mutation.
func (m *SeasonMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.lastUpdated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "lastUpdated" field's value of the Season entity.
// If the Season object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeasonMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ClearLastUpdated clears the value of the "lastUpdated" field.
func (m *SeasonMutation) ClearLastUpdated() {
	m.lastUpdated = nil
	m.clearedFields[season.FieldLastUpdated] = struct{}{}
}

// LastUpdatedCleared returns if the "lastUpdated" field was cleared in this mutation.
func (m *SeasonMutation) LastUpdatedCleared() bool {
	_, ok := m.clearedFields[season.FieldLastUpdated]
	return ok
}

// ResetLastUpdated resets all changes to the "lastUpdated" field.
func (m *SeasonMutation) ResetLastUpdated() {
	m.lastUpdated = nil
	delete(m.clearedFields, season.FieldLastUpdated)
}

// SetLeagueID sets the "league" edge to the League entity by id.
func (m *SeasonMutation) SetLeagueID(id int) {
	m.league = &id
}

// ClearLeague clears the "league" edge to the League entity.
func (m *SeasonMutation) ClearLeague() {
	m.clearedleague = true
}

// LeagueCleared reports if the "league" edge to the League entity was cleared.
func (m *SeasonMutation) LeagueCleared() bool {
	return m.clearedleague
}

// LeagueID returns the "league" edge ID in the mutation.
func (m *SeasonMutation) LeagueID() (id int, exists bool) {
	if m.league != nil {
		return *m.league, true
	}
	return
}

// LeagueIDs returns the "league" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LeagueID instead. It exists only for internal usage by the builders.
func (m *SeasonMutation) LeagueIDs() (ids []int) {
	if id := m.league; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLeague resets all changes to the "league" edge.
func (m *SeasonMutation) ResetLeague() {
	m.league = nil
	m.clearedleague = false
}

// AddFixtureIDs adds the "fixtures" edge to the Fixture entity by ids.
func (m *SeasonMutation) AddFixtureIDs(ids ...int) {
	if m.fixtures == nil {
		m.fixtures = make(map[int]struct{})
	}
	for i := range ids {
		m.fixtures[ids[i]] = struct{}{}
	}
}

// ClearFixtures clears the "fixtures" edge to the Fixture entity.
func (m *SeasonMutation) ClearFixtures() {
	m.clearedfixtures = true
}

// FixturesCleared reports if the "fixtures" edge to the Fixture entity was cleared.
func (m *SeasonMutation) FixturesCleared() bool {
	return m.clearedfixtures
}

// RemoveFixtureIDs removes the "fixtures" edge to the Fixture entity by IDs.
func (m *SeasonMutation) RemoveFixtureIDs(ids ...int) {
	if m.removedfixtures == nil {
		m.removedfixtures = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.fixtures, ids[i])
		m.removedfixtures[ids[i]] = struct{}{}
	}
}

// RemovedFixtures returns the removed IDs of the "fixtures" edge to the Fixture entity.
func (m *SeasonMutation) RemovedFixturesIDs() (ids []int) {
	for id := range m.removedfixtures {
		ids = append(ids, id)
	}
	return
}

// FixturesIDs returns the "fixtures" edge IDs in the mutation.
func (m *SeasonMutation) FixturesIDs() (ids []int) {
	for id := range m.fixtures {
		ids = append(ids, id)
	}
	return
}

// ResetFixtures resets all changes to the "fixtures" edge.
func (m *SeasonMutation) ResetFixtures() {
	m.fixtures = nil
	m.clearedfixtures = false
	m.removedfixtures = nil
}

// AddStandingIDs adds the "standings" edge to the Standings entity by ids.
func (m *SeasonMutation) AddStandingIDs(ids ...int) {
	if m.standings == nil {
		m.standings = make(map[int]struct{})
	}
	for i := range ids {
		m.standings[ids[i]] = struct{}{}
	}
}

// ClearStandings clears the "standings" edge to the Standings entity.
func (m *SeasonMutation) ClearStandings() {
	m.clearedstandings = true
}

// StandingsCleared reports if the "standings" edge to the Standings entity was cleared.
func (m *SeasonMutation) StandingsCleared() bool {
	return m.clearedstandings
}

// RemoveStandingIDs removes the "standings" edge to the Standings entity by IDs.
func (m *SeasonMutation) RemoveStandingIDs(ids ...int) {
	if m.removedstandings == nil {
		m.removedstandings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.standings, ids[i])
		m.removedstandings[ids[i]] = struct{}{}
	}
}

// RemovedStandings returns the removed IDs of the "standings" edge to the Standings entity.
func (m *SeasonMutation) RemovedStandingsIDs() (ids []int) {
	for id := range m.removedstandings {
		ids = append(ids, id)
	}
	return
}

// StandingsIDs returns the "standings" edge IDs in the mutation.
func (m *SeasonMutation) StandingsIDs() (ids []int) {
	for id := range m.standings {
		ids = append(ids, id)
	}
	return
}

// ResetStandings resets all changes to the "standings" edge.
func (m *SeasonMutation) ResetStandings() {
	m.standings = nil
	m.clearedstandings = false
	m.removedstandings = nil
}

// AddTeamIDs adds the "teams" edge to the Team entity by ids.
func (m *SeasonMutation) AddTeamIDs(ids ...int) {
	if m.teams == nil {
		m.teams = make(map[int]struct{})
	}
	for i := range ids {
		m.teams[ids[i]] = struct{}{}
	}
}

// ClearTeams clears the "teams" edge to the Team entity.
func (m *SeasonMutation) ClearTeams() {
	m.clearedteams = true
}

// TeamsCleared reports if the "teams" edge to the Team entity was cleared.
func (m *SeasonMutation) TeamsCleared() bool {
	return m.clearedteams
}

// RemoveTeamIDs removes the "teams" edge to the Team entity by IDs.
func (m *SeasonMutation) RemoveTeamIDs(ids ...int) {
	if m.removedteams == nil {
		m.removedteams = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.teams, ids[i])
		m.removedteams[ids[i]] = struct{}{}
	}
}

// RemovedTeams returns the removed IDs of the "teams" edge to the Team entity.
func (m *SeasonMutation) RemovedTeamsIDs() (ids []int) {
	for id := range m.removedteams {
		ids = append(ids, id)
	}
	return
}

// TeamsIDs returns the "teams" edge IDs in the mutation.
func (m *SeasonMutation) TeamsIDs() (ids []int) {
	for id := range m.teams {
		ids = append(ids, id)
	}
	return
}

// ResetTeams resets all changes to the "teams" edge.
func (m *SeasonMutation) ResetTeams() {
	m.teams = nil
	m.clearedteams = false
	m.removedteams = nil
}

// Where appends a list predicates to the SeasonMutation builder.
func (m *SeasonMutation) Where(ps ...predicate.Season) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SeasonMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SeasonMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Season, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SeasonMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SeasonMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Season).
func (m *SeasonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SeasonMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.slug != nil {
		fields = append(fields, season.FieldSlug)
	}
	if m.year != nil {
		fields = append(fields, season.FieldYear)
	}
	if m.start_date != nil {
		fields = append(fields, season.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, season.FieldEndDate)
	}
	if m.current != nil {
		fields = append(fields, season.FieldCurrent)
	}
	if m.lastUpdated != nil {
		fields = append(fields, season.FieldLastUpdated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SeasonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case season.FieldSlug:
		return m.Slug()
	case season.FieldYear:
		return m.Year()
	case season.FieldStartDate:
		return m.StartDate()
	case season.FieldEndDate:
		return m.EndDate()
	case season.FieldCurrent:
		return m.Current()
	case season.FieldLastUpdated:
		return m.LastUpdated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SeasonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case season.FieldSlug:
		return m.OldSlug(ctx)
	case season.FieldYear:
		return m.OldYear(ctx)
	case season.FieldStartDate:
		return m.OldStartDate(ctx)
	case season.FieldEndDate:
		return m.OldEndDate(ctx)
	case season.FieldCurrent:
		return m.OldCurrent(ctx)
	case season.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	}
	return nil, fmt.Errorf("unknown Season field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeasonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case season.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case season.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYear(v)
		return nil
	case season.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case season.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case season.FieldCurrent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrent(v)
		return nil
	case season.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	}
	return fmt.Errorf("unknown Season field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SeasonMutation) AddedFields() []string {
	var fields []string
	if m.addyear != nil {
		fields = append(fields, season.FieldYear)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SeasonMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case season.FieldYear:
		return m.AddedYear()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeasonMutation) AddField(name string, value ent.Value) error {
	switch name {
	case season.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYear(v)
		return nil
	}
	return fmt.Errorf("unknown Season numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SeasonMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(season.FieldLastUpdated) {
		fields = append(fields, season.FieldLastUpdated)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SeasonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SeasonMutation) ClearField(name string) error {
	switch name {
	case season.FieldLastUpdated:
		m.ClearLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown Season nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SeasonMutation) ResetField(name string) error {
	switch name {
	case season.FieldSlug:
		m.ResetSlug()
		return nil
	case season.FieldYear:
		m.ResetYear()
		return nil
	case season.FieldStartDate:
		m.ResetStartDate()
		return nil
	case season.FieldEndDate:
		m.ResetEndDate()
		return nil
	case season.FieldCurrent:
		m.ResetCurrent()
		return nil
	case season.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown Season field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SeasonMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.league != nil {
		edges = append(edges, season.EdgeLeague)
	}
	if m.fixtures != nil {
		edges = append(edges, season.EdgeFixtures)
	}
	if m.standings != nil {
		edges = append(edges, season.EdgeStandings)
	}
	if m.teams != nil {
		edges = append(edges, season.EdgeTeams)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SeasonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case season.EdgeLeague:
		if id := m.league; id != nil {
			return []ent.Value{*id}
		}
	case season.EdgeFixtures:
		ids := make([]ent.Value, 0, len(m.fixtures))
		for id := range m.fixtures {
			ids = append(ids, id)
		}
		return ids
	case season.EdgeStandings:
		ids := make([]ent.Value, 0, len(m.standings))
		for id := range m.standings {
			ids = append(ids, id)
		}
		return ids
	case season.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.teams))
		for id := range m.teams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SeasonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedfixtures != nil {
		edges = append(edges, season.EdgeFixtures)
	}
	if m.removedstandings != nil {
		edges = append(edges, season.EdgeStandings)
	}
	if m.removedteams != nil {
		edges = append(edges, season.EdgeTeams)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SeasonMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case season.EdgeFixtures:
		ids := make([]ent.Value, 0, len(m.removedfixtures))
		for id := range m.removedfixtures {
			ids = append(ids, id)
		}
		return ids
	case season.EdgeStandings:
		ids := make([]ent.Value, 0, len(m.removedstandings))
		for id := range m.removedstandings {
			ids = append(ids, id)
		}
		return ids
	case season.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.removedteams))
		for id := range m.removedteams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SeasonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedleague {
		edges = append(edges, season.EdgeLeague)
	}
	if m.clearedfixtures {
		edges = append(edges, season.EdgeFixtures)
	}
	if m.clearedstandings {
		edges = append(edges, season.EdgeStandings)
	}
	if m.clearedteams {
		edges = append(edges, season.EdgeTeams)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SeasonMutation) EdgeCleared(name string) bool {
	switch name {
	case season.EdgeLeague:
		return m.clearedleague
	case season.EdgeFixtures:
		return m.clearedfixtures
	case season.EdgeStandings:
		return m.clearedstandings
	case season.EdgeTeams:
		return m.clearedteams
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SeasonMutation) ClearEdge(name string) error {
	switch name {
	case season.EdgeLeague:
		m.ClearLeague()
		return nil
	}
	return fmt.Errorf("unknown Season unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SeasonMutation) ResetEdge(name string) error {
	switch name {
	case season.EdgeLeague:
		m.ResetLeague()
		return nil
	case season.EdgeFixtures:
		m.ResetFixtures()
		return nil
	case season.EdgeStandings:
		m.ResetStandings()
		return nil
	case season.EdgeTeams:
		m.ResetTeams()
		return nil
	}
	return fmt.Errorf("unknown Season edge %s", name)
}

// SquadMutation represents an operation that mutates the Squad nodes in the graph.
type SquadMutation struct {
	config
	op            Op
	typ           string
	id            *int
	position      *string
	number        *int
	addnumber     *int
	lastUpdated   *time.Time
	clearedFields map[string]struct{}
	player        *int
	clearedplayer bool
	team          *int
	clearedteam   bool
	done          bool
	oldValue      func(context.Context) (*Squad, error)
	predicates    []predicate.Squad
}

var _ ent.Mutation = (*SquadMutation)(nil)

// squadOption allows management of the mutation configuration using functional options.
type squadOption func(*SquadMutation)

// newSquadMutation creates new mutation for the Squad entity.
func newSquadMutation(c config, op Op, opts ...squadOption) *SquadMutation {
	m := &SquadMutation{
		config:        c,
		op:            op,
		typ:           TypeSquad,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSquadID sets the ID field of the mutation.
func withSquadID(id int) squadOption {
	return func(m *SquadMutation) {
		var (
			err   error
			once  sync.Once
			value *Squad
		)
		m.oldValue = func(ctx context.Context) (*Squad, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Squad.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSquad sets the old Squad of the mutation.
func withSquad(node *Squad) squadOption {
	return func(m *SquadMutation) {
		m.oldValue = func(context.Context) (*Squad, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SquadMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SquadMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SquadMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SquadMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Squad.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPosition sets the "position" field.
func (m *SquadMutation) SetPosition(s string) {
	m.position = &s
}

// Position returns the value of the "position" field in the mutation.
func (m *SquadMutation) Position() (r string, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old "position" field's value of the Squad entity.
// If the Squad object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SquadMutation) OldPosition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// ResetPosition resets all changes to the "position" field.
func (m *SquadMutation) ResetPosition() {
	m.position = nil
}

// SetNumber sets the "number" field.
func (m *SquadMutation) SetNumber(i int) {
	m.number = &i
	m.addnumber = nil
}

// Number returns the value of the "number" field in the mutation.
func (m *SquadMutation) Number() (r int, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the Squad entity.
// If the Squad object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SquadMutation) OldNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// AddNumber adds i to the "number" field.
func (m *SquadMutation) AddNumber(i int) {
	if m.addnumber != nil {
		*m.addnumber += i
	} else {
		m.addnumber = &i
	}
}

// AddedNumber returns the value that was added to the "number" field in this mutation.
func (m *SquadMutation) AddedNumber() (r int, exists bool) {
	v := m.addnumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber resets all changes to the "number" field.
func (m *SquadMutation) ResetNumber() {
	m.number = nil
	m.addnumber = nil
}

// SetLastUpdated sets the "lastUpdated" field.
func (m *SquadMutation) SetLastUpdated(t time.Time) {
	m.lastUpdated = &t
}

// LastUpdated returns the value of the "lastUpdated" field in the mutation.
func (m *SquadMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.lastUpdated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "lastUpdated" field's value of the Squad entity.
// If the Squad object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SquadMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ClearLastUpdated clears the value of the "lastUpdated" field.
func (m *SquadMutation) ClearLastUpdated() {
	m.lastUpdated = nil
	m.clearedFields[squad.FieldLastUpdated] = struct{}{}
}

// LastUpdatedCleared returns if the "lastUpdated" field was cleared in this mutation.
func (m *SquadMutation) LastUpdatedCleared() bool {
	_, ok := m.clearedFields[squad.FieldLastUpdated]
	return ok
}

// ResetLastUpdated resets all changes to the "lastUpdated" field.
func (m *SquadMutation) ResetLastUpdated() {
	m.lastUpdated = nil
	delete(m.clearedFields, squad.FieldLastUpdated)
}

// SetPlayerID sets the "player" edge to the Player entity by id.
func (m *SquadMutation) SetPlayerID(id int) {
	m.player = &id
}

// ClearPlayer clears the "player" edge to the Player entity.
func (m *SquadMutation) ClearPlayer() {
	m.clearedplayer = true
}

// PlayerCleared reports if the "player" edge to the Player entity was cleared.
func (m *SquadMutation) PlayerCleared() bool {
	return m.clearedplayer
}

// PlayerID returns the "player" edge ID in the mutation.
func (m *SquadMutation) PlayerID() (id int, exists bool) {
	if m.player != nil {
		return *m.player, true
	}
	return
}

// PlayerIDs returns the "player" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlayerID instead. It exists only for internal usage by the builders.
func (m *SquadMutation) PlayerIDs() (ids []int) {
	if id := m.player; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlayer resets all changes to the "player" edge.
func (m *SquadMutation) ResetPlayer() {
	m.player = nil
	m.clearedplayer = false
}

// SetTeamID sets the "team" edge to the Team entity by id.
func (m *SquadMutation) SetTeamID(id int) {
	m.team = &id
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *SquadMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *SquadMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamID returns the "team" edge ID in the mutation.
func (m *SquadMutation) TeamID() (id int, exists bool) {
	if m.team != nil {
		return *m.team, true
	}
	return
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *SquadMutation) TeamIDs() (ids []int) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *SquadMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// Where appends a list predicates to the SquadMutation builder.
func (m *SquadMutation) Where(ps ...predicate.Squad) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SquadMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SquadMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Squad, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SquadMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SquadMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Squad).
func (m *SquadMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SquadMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.position != nil {
		fields = append(fields, squad.FieldPosition)
	}
	if m.number != nil {
		fields = append(fields, squad.FieldNumber)
	}
	if m.lastUpdated != nil {
		fields = append(fields, squad.FieldLastUpdated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SquadMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case squad.FieldPosition:
		return m.Position()
	case squad.FieldNumber:
		return m.Number()
	case squad.FieldLastUpdated:
		return m.LastUpdated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SquadMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case squad.FieldPosition:
		return m.OldPosition(ctx)
	case squad.FieldNumber:
		return m.OldNumber(ctx)
	case squad.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	}
	return nil, fmt.Errorf("unknown Squad field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SquadMutation) SetField(name string, value ent.Value) error {
	switch name {
	case squad.FieldPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	case squad.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case squad.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	}
	return fmt.Errorf("unknown Squad field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SquadMutation) AddedFields() []string {
	var fields []string
	if m.addnumber != nil {
		fields = append(fields, squad.FieldNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SquadMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case squad.FieldNumber:
		return m.AddedNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SquadMutation) AddField(name string, value ent.Value) error {
	switch name {
	case squad.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Squad numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SquadMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(squad.FieldLastUpdated) {
		fields = append(fields, squad.FieldLastUpdated)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SquadMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SquadMutation) ClearField(name string) error {
	switch name {
	case squad.FieldLastUpdated:
		m.ClearLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown Squad nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SquadMutation) ResetField(name string) error {
	switch name {
	case squad.FieldPosition:
		m.ResetPosition()
		return nil
	case squad.FieldNumber:
		m.ResetNumber()
		return nil
	case squad.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown Squad field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SquadMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.player != nil {
		edges = append(edges, squad.EdgePlayer)
	}
	if m.team != nil {
		edges = append(edges, squad.EdgeTeam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SquadMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case squad.EdgePlayer:
		if id := m.player; id != nil {
			return []ent.Value{*id}
		}
	case squad.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SquadMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SquadMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SquadMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedplayer {
		edges = append(edges, squad.EdgePlayer)
	}
	if m.clearedteam {
		edges = append(edges, squad.EdgeTeam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SquadMutation) EdgeCleared(name string) bool {
	switch name {
	case squad.EdgePlayer:
		return m.clearedplayer
	case squad.EdgeTeam:
		return m.clearedteam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SquadMutation) ClearEdge(name string) error {
	switch name {
	case squad.EdgePlayer:
		m.ClearPlayer()
		return nil
	case squad.EdgeTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown Squad unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SquadMutation) ResetEdge(name string) error {
	switch name {
	case squad.EdgePlayer:
		m.ResetPlayer()
		return nil
	case squad.EdgeTeam:
		m.ResetTeam()
		return nil
	}
	return fmt.Errorf("unknown Squad edge %s", name)
}

// StandingsMutation represents an operation that mutates the Standings nodes in the graph.
type StandingsMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	rank                *int
	addrank             *int
	points              *int
	addpoints           *int
	goalsDiff           *int
	addgoalsDiff        *int
	group               *string
	form                *string
	status              *string
	description         *string
	allPlayed           *int
	addallPlayed        *int
	allWin              *int
	addallWin           *int
	allDraw             *int
	addallDraw          *int
	allLose             *int
	addallLose          *int
	allGoalsFor         *int
	addallGoalsFor      *int
	allGoalsAgainst     *int
	addallGoalsAgainst  *int
	homePlayed          *int
	addhomePlayed       *int
	homeWin             *int
	addhomeWin          *int
	homeDraw            *int
	addhomeDraw         *int
	homeLose            *int
	addhomeLose         *int
	homeGoalsFor        *int
	addhomeGoalsFor     *int
	homeGoalsAgainst    *int
	addhomeGoalsAgainst *int
	awayPlayed          *int
	addawayPlayed       *int
	awayWin             *int
	addawayWin          *int
	awayDraw            *int
	addawayDraw         *int
	awayLose            *int
	addawayLose         *int
	awayGoalsFor        *int
	addawayGoalsFor     *int
	awayGoalsAgainst    *int
	addawayGoalsAgainst *int
	_LastUpdated        *time.Time
	clearedFields       map[string]struct{}
	team                *int
	clearedteam         bool
	season              *int
	clearedseason       bool
	done                bool
	oldValue            func(context.Context) (*Standings, error)
	predicates          []predicate.Standings
}

var _ ent.Mutation = (*StandingsMutation)(nil)

// standingsOption allows management of the mutation configuration using functional options.
type standingsOption func(*StandingsMutation)

// newStandingsMutation creates new mutation for the Standings entity.
func newStandingsMutation(c config, op Op, opts ...standingsOption) *StandingsMutation {
	m := &StandingsMutation{
		config:        c,
		op:            op,
		typ:           TypeStandings,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStandingsID sets the ID field of the mutation.
func withStandingsID(id int) standingsOption {
	return func(m *StandingsMutation) {
		var (
			err   error
			once  sync.Once
			value *Standings
		)
		m.oldValue = func(ctx context.Context) (*Standings, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Standings.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStandings sets the old Standings of the mutation.
func withStandings(node *Standings) standingsOption {
	return func(m *StandingsMutation) {
		m.oldValue = func(context.Context) (*Standings, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StandingsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StandingsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StandingsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StandingsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Standings.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRank sets the "rank" field.
func (m *StandingsMutation) SetRank(i int) {
	m.rank = &i
	m.addrank = nil
}

// Rank returns the value of the "rank" field in the mutation.
func (m *StandingsMutation) Rank() (r int, exists bool) {
	v := m.rank
	if v == nil {
		return
	}
	return *v, true
}

// OldRank returns the old "rank" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldRank(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRank: %w", err)
	}
	return oldValue.Rank, nil
}

// AddRank adds i to the "rank" field.
func (m *StandingsMutation) AddRank(i int) {
	if m.addrank != nil {
		*m.addrank += i
	} else {
		m.addrank = &i
	}
}

// AddedRank returns the value that was added to the "rank" field in this mutation.
func (m *StandingsMutation) AddedRank() (r int, exists bool) {
	v := m.addrank
	if v == nil {
		return
	}
	return *v, true
}

// ResetRank resets all changes to the "rank" field.
func (m *StandingsMutation) ResetRank() {
	m.rank = nil
	m.addrank = nil
}

// SetPoints sets the "points" field.
func (m *StandingsMutation) SetPoints(i int) {
	m.points = &i
	m.addpoints = nil
}

// Points returns the value of the "points" field in the mutation.
func (m *StandingsMutation) Points() (r int, exists bool) {
	v := m.points
	if v == nil {
		return
	}
	return *v, true
}

// OldPoints returns the old "points" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldPoints(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoints: %w", err)
	}
	return oldValue.Points, nil
}

// AddPoints adds i to the "points" field.
func (m *StandingsMutation) AddPoints(i int) {
	if m.addpoints != nil {
		*m.addpoints += i
	} else {
		m.addpoints = &i
	}
}

// AddedPoints returns the value that was added to the "points" field in this mutation.
func (m *StandingsMutation) AddedPoints() (r int, exists bool) {
	v := m.addpoints
	if v == nil {
		return
	}
	return *v, true
}

// ResetPoints resets all changes to the "points" field.
func (m *StandingsMutation) ResetPoints() {
	m.points = nil
	m.addpoints = nil
}

// SetGoalsDiff sets the "goalsDiff" field.
func (m *StandingsMutation) SetGoalsDiff(i int) {
	m.goalsDiff = &i
	m.addgoalsDiff = nil
}

// GoalsDiff returns the value of the "goalsDiff" field in the mutation.
func (m *StandingsMutation) GoalsDiff() (r int, exists bool) {
	v := m.goalsDiff
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsDiff returns the old "goalsDiff" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldGoalsDiff(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsDiff is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsDiff requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsDiff: %w", err)
	}
	return oldValue.GoalsDiff, nil
}

// AddGoalsDiff adds i to the "goalsDiff" field.
func (m *StandingsMutation) AddGoalsDiff(i int) {
	if m.addgoalsDiff != nil {
		*m.addgoalsDiff += i
	} else {
		m.addgoalsDiff = &i
	}
}

// AddedGoalsDiff returns the value that was added to the "goalsDiff" field in this mutation.
func (m *StandingsMutation) AddedGoalsDiff() (r int, exists bool) {
	v := m.addgoalsDiff
	if v == nil {
		return
	}
	return *v, true
}

// ResetGoalsDiff resets all changes to the "goalsDiff" field.
func (m *StandingsMutation) ResetGoalsDiff() {
	m.goalsDiff = nil
	m.addgoalsDiff = nil
}

// SetGroup sets the "group" field.
func (m *StandingsMutation) SetGroup(s string) {
	m.group = &s
}

// Group returns the value of the "group" field in the mutation.
func (m *StandingsMutation) Group() (r string, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroup returns the old "group" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldGroup(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroup: %w", err)
	}
	return oldValue.Group, nil
}

// ResetGroup resets all changes to the "group" field.
func (m *StandingsMutation) ResetGroup() {
	m.group = nil
}

// SetForm sets the "form" field.
func (m *StandingsMutation) SetForm(s string) {
	m.form = &s
}

// Form returns the value of the "form" field in the mutation.
func (m *StandingsMutation) Form() (r string, exists bool) {
	v := m.form
	if v == nil {
		return
	}
	return *v, true
}

// OldForm returns the old "form" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldForm(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForm: %w", err)
	}
	return oldValue.Form, nil
}

// ResetForm resets all changes to the "form" field.
func (m *StandingsMutation) ResetForm() {
	m.form = nil
}

// SetStatus sets the "status" field.
func (m *StandingsMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *StandingsMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *StandingsMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[standings.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *StandingsMutation) StatusCleared() bool {
	_, ok := m.clearedFields[standings.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *StandingsMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, standings.FieldStatus)
}

// SetDescription sets the "description" field.
func (m *StandingsMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *StandingsMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *StandingsMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[standings.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *StandingsMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[standings.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *StandingsMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, standings.FieldDescription)
}

// SetAllPlayed sets the "allPlayed" field.
func (m *StandingsMutation) SetAllPlayed(i int) {
	m.allPlayed = &i
	m.addallPlayed = nil
}

// AllPlayed returns the value of the "allPlayed" field in the mutation.
func (m *StandingsMutation) AllPlayed() (r int, exists bool) {
	v := m.allPlayed
	if v == nil {
		return
	}
	return *v, true
}

// OldAllPlayed returns the old "allPlayed" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldAllPlayed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllPlayed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllPlayed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllPlayed: %w", err)
	}
	return oldValue.AllPlayed, nil
}

// AddAllPlayed adds i to the "allPlayed" field.
func (m *StandingsMutation) AddAllPlayed(i int) {
	if m.addallPlayed != nil {
		*m.addallPlayed += i
	} else {
		m.addallPlayed = &i
	}
}

// AddedAllPlayed returns the value that was added to the "allPlayed" field in this mutation.
func (m *StandingsMutation) AddedAllPlayed() (r int, exists bool) {
	v := m.addallPlayed
	if v == nil {
		return
	}
	return *v, true
}

// ResetAllPlayed resets all changes to the "allPlayed" field.
func (m *StandingsMutation) ResetAllPlayed() {
	m.allPlayed = nil
	m.addallPlayed = nil
}

// SetAllWin sets the "allWin" field.
func (m *StandingsMutation) SetAllWin(i int) {
	m.allWin = &i
	m.addallWin = nil
}

// AllWin returns the value of the "allWin" field in the mutation.
func (m *StandingsMutation) AllWin() (r int, exists bool) {
	v := m.allWin
	if v == nil {
		return
	}
	return *v, true
}

// OldAllWin returns the old "allWin" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldAllWin(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllWin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllWin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllWin: %w", err)
	}
	return oldValue.AllWin, nil
}

// AddAllWin adds i to the "allWin" field.
func (m *StandingsMutation) AddAllWin(i int) {
	if m.addallWin != nil {
		*m.addallWin += i
	} else {
		m.addallWin = &i
	}
}

// AddedAllWin returns the value that was added to the "allWin" field in this mutation.
func (m *StandingsMutation) AddedAllWin() (r int, exists bool) {
	v := m.addallWin
	if v == nil {
		return
	}
	return *v, true
}

// ResetAllWin resets all changes to the "allWin" field.
func (m *StandingsMutation) ResetAllWin() {
	m.allWin = nil
	m.addallWin = nil
}

// SetAllDraw sets the "allDraw" field.
func (m *StandingsMutation) SetAllDraw(i int) {
	m.allDraw = &i
	m.addallDraw = nil
}

// AllDraw returns the value of the "allDraw" field in the mutation.
func (m *StandingsMutation) AllDraw() (r int, exists bool) {
	v := m.allDraw
	if v == nil {
		return
	}
	return *v, true
}

// OldAllDraw returns the old "allDraw" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldAllDraw(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllDraw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllDraw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllDraw: %w", err)
	}
	return oldValue.AllDraw, nil
}

// AddAllDraw adds i to the "allDraw" field.
func (m *StandingsMutation) AddAllDraw(i int) {
	if m.addallDraw != nil {
		*m.addallDraw += i
	} else {
		m.addallDraw = &i
	}
}

// AddedAllDraw returns the value that was added to the "allDraw" field in this mutation.
func (m *StandingsMutation) AddedAllDraw() (r int, exists bool) {
	v := m.addallDraw
	if v == nil {
		return
	}
	return *v, true
}

// ResetAllDraw resets all changes to the "allDraw" field.
func (m *StandingsMutation) ResetAllDraw() {
	m.allDraw = nil
	m.addallDraw = nil
}

// SetAllLose sets the "allLose" field.
func (m *StandingsMutation) SetAllLose(i int) {
	m.allLose = &i
	m.addallLose = nil
}

// AllLose returns the value of the "allLose" field in the mutation.
func (m *StandingsMutation) AllLose() (r int, exists bool) {
	v := m.allLose
	if v == nil {
		return
	}
	return *v, true
}

// OldAllLose returns the old "allLose" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldAllLose(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllLose is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllLose requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllLose: %w", err)
	}
	return oldValue.AllLose, nil
}

// AddAllLose adds i to the "allLose" field.
func (m *StandingsMutation) AddAllLose(i int) {
	if m.addallLose != nil {
		*m.addallLose += i
	} else {
		m.addallLose = &i
	}
}

// AddedAllLose returns the value that was added to the "allLose" field in this mutation.
func (m *StandingsMutation) AddedAllLose() (r int, exists bool) {
	v := m.addallLose
	if v == nil {
		return
	}
	return *v, true
}

// ResetAllLose resets all changes to the "allLose" field.
func (m *StandingsMutation) ResetAllLose() {
	m.allLose = nil
	m.addallLose = nil
}

// SetAllGoalsFor sets the "allGoalsFor" field.
func (m *StandingsMutation) SetAllGoalsFor(i int) {
	m.allGoalsFor = &i
	m.addallGoalsFor = nil
}

// AllGoalsFor returns the value of the "allGoalsFor" field in the mutation.
func (m *StandingsMutation) AllGoalsFor() (r int, exists bool) {
	v := m.allGoalsFor
	if v == nil {
		return
	}
	return *v, true
}

// OldAllGoalsFor returns the old "allGoalsFor" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldAllGoalsFor(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllGoalsFor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllGoalsFor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllGoalsFor: %w", err)
	}
	return oldValue.AllGoalsFor, nil
}

// AddAllGoalsFor adds i to the "allGoalsFor" field.
func (m *StandingsMutation) AddAllGoalsFor(i int) {
	if m.addallGoalsFor != nil {
		*m.addallGoalsFor += i
	} else {
		m.addallGoalsFor = &i
	}
}

// AddedAllGoalsFor returns the value that was added to the "allGoalsFor" field in this mutation.
func (m *StandingsMutation) AddedAllGoalsFor() (r int, exists bool) {
	v := m.addallGoalsFor
	if v == nil {
		return
	}
	return *v, true
}

// ResetAllGoalsFor resets all changes to the "allGoalsFor" field.
func (m *StandingsMutation) ResetAllGoalsFor() {
	m.allGoalsFor = nil
	m.addallGoalsFor = nil
}

// SetAllGoalsAgainst sets the "allGoalsAgainst" field.
func (m *StandingsMutation) SetAllGoalsAgainst(i int) {
	m.allGoalsAgainst = &i
	m.addallGoalsAgainst = nil
}

// AllGoalsAgainst returns the value of the "allGoalsAgainst" field in the mutation.
func (m *StandingsMutation) AllGoalsAgainst() (r int, exists bool) {
	v := m.allGoalsAgainst
	if v == nil {
		return
	}
	return *v, true
}

// OldAllGoalsAgainst returns the old "allGoalsAgainst" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldAllGoalsAgainst(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllGoalsAgainst is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllGoalsAgainst requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllGoalsAgainst: %w", err)
	}
	return oldValue.AllGoalsAgainst, nil
}

// AddAllGoalsAgainst adds i to the "allGoalsAgainst" field.
func (m *StandingsMutation) AddAllGoalsAgainst(i int) {
	if m.addallGoalsAgainst != nil {
		*m.addallGoalsAgainst += i
	} else {
		m.addallGoalsAgainst = &i
	}
}

// AddedAllGoalsAgainst returns the value that was added to the "allGoalsAgainst" field in this mutation.
func (m *StandingsMutation) AddedAllGoalsAgainst() (r int, exists bool) {
	v := m.addallGoalsAgainst
	if v == nil {
		return
	}
	return *v, true
}

// ResetAllGoalsAgainst resets all changes to the "allGoalsAgainst" field.
func (m *StandingsMutation) ResetAllGoalsAgainst() {
	m.allGoalsAgainst = nil
	m.addallGoalsAgainst = nil
}

// SetHomePlayed sets the "homePlayed" field.
func (m *StandingsMutation) SetHomePlayed(i int) {
	m.homePlayed = &i
	m.addhomePlayed = nil
}

// HomePlayed returns the value of the "homePlayed" field in the mutation.
func (m *StandingsMutation) HomePlayed() (r int, exists bool) {
	v := m.homePlayed
	if v == nil {
		return
	}
	return *v, true
}

// OldHomePlayed returns the old "homePlayed" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldHomePlayed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomePlayed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomePlayed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomePlayed: %w", err)
	}
	return oldValue.HomePlayed, nil
}

// AddHomePlayed adds i to the "homePlayed" field.
func (m *StandingsMutation) AddHomePlayed(i int) {
	if m.addhomePlayed != nil {
		*m.addhomePlayed += i
	} else {
		m.addhomePlayed = &i
	}
}

// AddedHomePlayed returns the value that was added to the "homePlayed" field in this mutation.
func (m *StandingsMutation) AddedHomePlayed() (r int, exists bool) {
	v := m.addhomePlayed
	if v == nil {
		return
	}
	return *v, true
}

// ResetHomePlayed resets all changes to the "homePlayed" field.
func (m *StandingsMutation) ResetHomePlayed() {
	m.homePlayed = nil
	m.addhomePlayed = nil
}

// SetHomeWin sets the "homeWin" field.
func (m *StandingsMutation) SetHomeWin(i int) {
	m.homeWin = &i
	m.addhomeWin = nil
}

// HomeWin returns the value of the "homeWin" field in the mutation.
func (m *StandingsMutation) HomeWin() (r int, exists bool) {
	v := m.homeWin
	if v == nil {
		return
	}
	return *v, true
}

// OldHomeWin returns the old "homeWin" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldHomeWin(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomeWin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomeWin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomeWin: %w", err)
	}
	return oldValue.HomeWin, nil
}

// AddHomeWin adds i to the "homeWin" field.
func (m *StandingsMutation) AddHomeWin(i int) {
	if m.addhomeWin != nil {
		*m.addhomeWin += i
	} else {
		m.addhomeWin = &i
	}
}

// AddedHomeWin returns the value that was added to the "homeWin" field in this mutation.
func (m *StandingsMutation) AddedHomeWin() (r int, exists bool) {
	v := m.addhomeWin
	if v == nil {
		return
	}
	return *v, true
}

// ResetHomeWin resets all changes to the "homeWin" field.
func (m *StandingsMutation) ResetHomeWin() {
	m.homeWin = nil
	m.addhomeWin = nil
}

// SetHomeDraw sets the "homeDraw" field.
func (m *StandingsMutation) SetHomeDraw(i int) {
	m.homeDraw = &i
	m.addhomeDraw = nil
}

// HomeDraw returns the value of the "homeDraw" field in the mutation.
func (m *StandingsMutation) HomeDraw() (r int, exists bool) {
	v := m.homeDraw
	if v == nil {
		return
	}
	return *v, true
}

// OldHomeDraw returns the old "homeDraw" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldHomeDraw(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomeDraw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomeDraw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomeDraw: %w", err)
	}
	return oldValue.HomeDraw, nil
}

// AddHomeDraw adds i to the "homeDraw" field.
func (m *StandingsMutation) AddHomeDraw(i int) {
	if m.addhomeDraw != nil {
		*m.addhomeDraw += i
	} else {
		m.addhomeDraw = &i
	}
}

// AddedHomeDraw returns the value that was added to the "homeDraw" field in this mutation.
func (m *StandingsMutation) AddedHomeDraw() (r int, exists bool) {
	v := m.addhomeDraw
	if v == nil {
		return
	}
	return *v, true
}

// ResetHomeDraw resets all changes to the "homeDraw" field.
func (m *StandingsMutation) ResetHomeDraw() {
	m.homeDraw = nil
	m.addhomeDraw = nil
}

// SetHomeLose sets the "homeLose" field.
func (m *StandingsMutation) SetHomeLose(i int) {
	m.homeLose = &i
	m.addhomeLose = nil
}

// HomeLose returns the value of the "homeLose" field in the mutation.
func (m *StandingsMutation) HomeLose() (r int, exists bool) {
	v := m.homeLose
	if v == nil {
		return
	}
	return *v, true
}

// OldHomeLose returns the old "homeLose" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldHomeLose(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomeLose is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomeLose requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomeLose: %w", err)
	}
	return oldValue.HomeLose, nil
}

// AddHomeLose adds i to the "homeLose" field.
func (m *StandingsMutation) AddHomeLose(i int) {
	if m.addhomeLose != nil {
		*m.addhomeLose += i
	} else {
		m.addhomeLose = &i
	}
}

// AddedHomeLose returns the value that was added to the "homeLose" field in this mutation.
func (m *StandingsMutation) AddedHomeLose() (r int, exists bool) {
	v := m.addhomeLose
	if v == nil {
		return
	}
	return *v, true
}

// ResetHomeLose resets all changes to the "homeLose" field.
func (m *StandingsMutation) ResetHomeLose() {
	m.homeLose = nil
	m.addhomeLose = nil
}

// SetHomeGoalsFor sets the "homeGoalsFor" field.
func (m *StandingsMutation) SetHomeGoalsFor(i int) {
	m.homeGoalsFor = &i
	m.addhomeGoalsFor = nil
}

// HomeGoalsFor returns the value of the "homeGoalsFor" field in the mutation.
func (m *StandingsMutation) HomeGoalsFor() (r int, exists bool) {
	v := m.homeGoalsFor
	if v == nil {
		return
	}
	return *v, true
}

// OldHomeGoalsFor returns the old "homeGoalsFor" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldHomeGoalsFor(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomeGoalsFor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomeGoalsFor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomeGoalsFor: %w", err)
	}
	return oldValue.HomeGoalsFor, nil
}

// AddHomeGoalsFor adds i to the "homeGoalsFor" field.
func (m *StandingsMutation) AddHomeGoalsFor(i int) {
	if m.addhomeGoalsFor != nil {
		*m.addhomeGoalsFor += i
	} else {
		m.addhomeGoalsFor = &i
	}
}

// AddedHomeGoalsFor returns the value that was added to the "homeGoalsFor" field in this mutation.
func (m *StandingsMutation) AddedHomeGoalsFor() (r int, exists bool) {
	v := m.addhomeGoalsFor
	if v == nil {
		return
	}
	return *v, true
}

// ResetHomeGoalsFor resets all changes to the "homeGoalsFor" field.
func (m *StandingsMutation) ResetHomeGoalsFor() {
	m.homeGoalsFor = nil
	m.addhomeGoalsFor = nil
}

// SetHomeGoalsAgainst sets the "homeGoalsAgainst" field.
func (m *StandingsMutation) SetHomeGoalsAgainst(i int) {
	m.homeGoalsAgainst = &i
	m.addhomeGoalsAgainst = nil
}

// HomeGoalsAgainst returns the value of the "homeGoalsAgainst" field in the mutation.
func (m *StandingsMutation) HomeGoalsAgainst() (r int, exists bool) {
	v := m.homeGoalsAgainst
	if v == nil {
		return
	}
	return *v, true
}

// OldHomeGoalsAgainst returns the old "homeGoalsAgainst" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldHomeGoalsAgainst(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomeGoalsAgainst is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomeGoalsAgainst requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomeGoalsAgainst: %w", err)
	}
	return oldValue.HomeGoalsAgainst, nil
}

// AddHomeGoalsAgainst adds i to the "homeGoalsAgainst" field.
func (m *StandingsMutation) AddHomeGoalsAgainst(i int) {
	if m.addhomeGoalsAgainst != nil {
		*m.addhomeGoalsAgainst += i
	} else {
		m.addhomeGoalsAgainst = &i
	}
}

// AddedHomeGoalsAgainst returns the value that was added to the "homeGoalsAgainst" field in this mutation.
func (m *StandingsMutation) AddedHomeGoalsAgainst() (r int, exists bool) {
	v := m.addhomeGoalsAgainst
	if v == nil {
		return
	}
	return *v, true
}

// ResetHomeGoalsAgainst resets all changes to the "homeGoalsAgainst" field.
func (m *StandingsMutation) ResetHomeGoalsAgainst() {
	m.homeGoalsAgainst = nil
	m.addhomeGoalsAgainst = nil
}

// SetAwayPlayed sets the "awayPlayed" field.
func (m *StandingsMutation) SetAwayPlayed(i int) {
	m.awayPlayed = &i
	m.addawayPlayed = nil
}

// AwayPlayed returns the value of the "awayPlayed" field in the mutation.
func (m *StandingsMutation) AwayPlayed() (r int, exists bool) {
	v := m.awayPlayed
	if v == nil {
		return
	}
	return *v, true
}

// OldAwayPlayed returns the old "awayPlayed" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldAwayPlayed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAwayPlayed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAwayPlayed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAwayPlayed: %w", err)
	}
	return oldValue.AwayPlayed, nil
}

// AddAwayPlayed adds i to the "awayPlayed" field.
func (m *StandingsMutation) AddAwayPlayed(i int) {
	if m.addawayPlayed != nil {
		*m.addawayPlayed += i
	} else {
		m.addawayPlayed = &i
	}
}

// AddedAwayPlayed returns the value that was added to the "awayPlayed" field in this mutation.
func (m *StandingsMutation) AddedAwayPlayed() (r int, exists bool) {
	v := m.addawayPlayed
	if v == nil {
		return
	}
	return *v, true
}

// ResetAwayPlayed resets all changes to the "awayPlayed" field.
func (m *StandingsMutation) ResetAwayPlayed() {
	m.awayPlayed = nil
	m.addawayPlayed = nil
}

// SetAwayWin sets the "awayWin" field.
func (m *StandingsMutation) SetAwayWin(i int) {
	m.awayWin = &i
	m.addawayWin = nil
}

// AwayWin returns the value of the "awayWin" field in the mutation.
func (m *StandingsMutation) AwayWin() (r int, exists bool) {
	v := m.awayWin
	if v == nil {
		return
	}
	return *v, true
}

// OldAwayWin returns the old "awayWin" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldAwayWin(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAwayWin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAwayWin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAwayWin: %w", err)
	}
	return oldValue.AwayWin, nil
}

// AddAwayWin adds i to the "awayWin" field.
func (m *StandingsMutation) AddAwayWin(i int) {
	if m.addawayWin != nil {
		*m.addawayWin += i
	} else {
		m.addawayWin = &i
	}
}

// AddedAwayWin returns the value that was added to the "awayWin" field in this mutation.
func (m *StandingsMutation) AddedAwayWin() (r int, exists bool) {
	v := m.addawayWin
	if v == nil {
		return
	}
	return *v, true
}

// ResetAwayWin resets all changes to the "awayWin" field.
func (m *StandingsMutation) ResetAwayWin() {
	m.awayWin = nil
	m.addawayWin = nil
}

// SetAwayDraw sets the "awayDraw" field.
func (m *StandingsMutation) SetAwayDraw(i int) {
	m.awayDraw = &i
	m.addawayDraw = nil
}

// AwayDraw returns the value of the "awayDraw" field in the mutation.
func (m *StandingsMutation) AwayDraw() (r int, exists bool) {
	v := m.awayDraw
	if v == nil {
		return
	}
	return *v, true
}

// OldAwayDraw returns the old "awayDraw" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldAwayDraw(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAwayDraw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAwayDraw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAwayDraw: %w", err)
	}
	return oldValue.AwayDraw, nil
}

// AddAwayDraw adds i to the "awayDraw" field.
func (m *StandingsMutation) AddAwayDraw(i int) {
	if m.addawayDraw != nil {
		*m.addawayDraw += i
	} else {
		m.addawayDraw = &i
	}
}

// AddedAwayDraw returns the value that was added to the "awayDraw" field in this mutation.
func (m *StandingsMutation) AddedAwayDraw() (r int, exists bool) {
	v := m.addawayDraw
	if v == nil {
		return
	}
	return *v, true
}

// ResetAwayDraw resets all changes to the "awayDraw" field.
func (m *StandingsMutation) ResetAwayDraw() {
	m.awayDraw = nil
	m.addawayDraw = nil
}

// SetAwayLose sets the "awayLose" field.
func (m *StandingsMutation) SetAwayLose(i int) {
	m.awayLose = &i
	m.addawayLose = nil
}

// AwayLose returns the value of the "awayLose" field in the mutation.
func (m *StandingsMutation) AwayLose() (r int, exists bool) {
	v := m.awayLose
	if v == nil {
		return
	}
	return *v, true
}

// OldAwayLose returns the old "awayLose" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldAwayLose(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAwayLose is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAwayLose requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAwayLose: %w", err)
	}
	return oldValue.AwayLose, nil
}

// AddAwayLose adds i to the "awayLose" field.
func (m *StandingsMutation) AddAwayLose(i int) {
	if m.addawayLose != nil {
		*m.addawayLose += i
	} else {
		m.addawayLose = &i
	}
}

// AddedAwayLose returns the value that was added to the "awayLose" field in this mutation.
func (m *StandingsMutation) AddedAwayLose() (r int, exists bool) {
	v := m.addawayLose
	if v == nil {
		return
	}
	return *v, true
}

// ResetAwayLose resets all changes to the "awayLose" field.
func (m *StandingsMutation) ResetAwayLose() {
	m.awayLose = nil
	m.addawayLose = nil
}

// SetAwayGoalsFor sets the "awayGoalsFor" field.
func (m *StandingsMutation) SetAwayGoalsFor(i int) {
	m.awayGoalsFor = &i
	m.addawayGoalsFor = nil
}

// AwayGoalsFor returns the value of the "awayGoalsFor" field in the mutation.
func (m *StandingsMutation) AwayGoalsFor() (r int, exists bool) {
	v := m.awayGoalsFor
	if v == nil {
		return
	}
	return *v, true
}

// OldAwayGoalsFor returns the old "awayGoalsFor" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldAwayGoalsFor(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAwayGoalsFor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAwayGoalsFor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAwayGoalsFor: %w", err)
	}
	return oldValue.AwayGoalsFor, nil
}

// AddAwayGoalsFor adds i to the "awayGoalsFor" field.
func (m *StandingsMutation) AddAwayGoalsFor(i int) {
	if m.addawayGoalsFor != nil {
		*m.addawayGoalsFor += i
	} else {
		m.addawayGoalsFor = &i
	}
}

// AddedAwayGoalsFor returns the value that was added to the "awayGoalsFor" field in this mutation.
func (m *StandingsMutation) AddedAwayGoalsFor() (r int, exists bool) {
	v := m.addawayGoalsFor
	if v == nil {
		return
	}
	return *v, true
}

// ResetAwayGoalsFor resets all changes to the "awayGoalsFor" field.
func (m *StandingsMutation) ResetAwayGoalsFor() {
	m.awayGoalsFor = nil
	m.addawayGoalsFor = nil
}

// SetAwayGoalsAgainst sets the "awayGoalsAgainst" field.
func (m *StandingsMutation) SetAwayGoalsAgainst(i int) {
	m.awayGoalsAgainst = &i
	m.addawayGoalsAgainst = nil
}

// AwayGoalsAgainst returns the value of the "awayGoalsAgainst" field in the mutation.
func (m *StandingsMutation) AwayGoalsAgainst() (r int, exists bool) {
	v := m.awayGoalsAgainst
	if v == nil {
		return
	}
	return *v, true
}

// OldAwayGoalsAgainst returns the old "awayGoalsAgainst" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldAwayGoalsAgainst(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAwayGoalsAgainst is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAwayGoalsAgainst requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAwayGoalsAgainst: %w", err)
	}
	return oldValue.AwayGoalsAgainst, nil
}

// AddAwayGoalsAgainst adds i to the "awayGoalsAgainst" field.
func (m *StandingsMutation) AddAwayGoalsAgainst(i int) {
	if m.addawayGoalsAgainst != nil {
		*m.addawayGoalsAgainst += i
	} else {
		m.addawayGoalsAgainst = &i
	}
}

// AddedAwayGoalsAgainst returns the value that was added to the "awayGoalsAgainst" field in this mutation.
func (m *StandingsMutation) AddedAwayGoalsAgainst() (r int, exists bool) {
	v := m.addawayGoalsAgainst
	if v == nil {
		return
	}
	return *v, true
}

// ResetAwayGoalsAgainst resets all changes to the "awayGoalsAgainst" field.
func (m *StandingsMutation) ResetAwayGoalsAgainst() {
	m.awayGoalsAgainst = nil
	m.addawayGoalsAgainst = nil
}

// SetLastUpdated sets the "LastUpdated" field.
func (m *StandingsMutation) SetLastUpdated(t time.Time) {
	m._LastUpdated = &t
}

// LastUpdated returns the value of the "LastUpdated" field in the mutation.
func (m *StandingsMutation) LastUpdated() (r time.Time, exists bool) {
	v := m._LastUpdated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "LastUpdated" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ResetLastUpdated resets all changes to the "LastUpdated" field.
func (m *StandingsMutation) ResetLastUpdated() {
	m._LastUpdated = nil
}

// SetTeamID sets the "team" edge to the Team entity by id.
func (m *StandingsMutation) SetTeamID(id int) {
	m.team = &id
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *StandingsMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *StandingsMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamID returns the "team" edge ID in the mutation.
func (m *StandingsMutation) TeamID() (id int, exists bool) {
	if m.team != nil {
		return *m.team, true
	}
	return
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *StandingsMutation) TeamIDs() (ids []int) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *StandingsMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// SetSeasonID sets the "season" edge to the Season entity by id.
func (m *StandingsMutation) SetSeasonID(id int) {
	m.season = &id
}

// ClearSeason clears the "season" edge to the Season entity.
func (m *StandingsMutation) ClearSeason() {
	m.clearedseason = true
}

// SeasonCleared reports if the "season" edge to the Season entity was cleared.
func (m *StandingsMutation) SeasonCleared() bool {
	return m.clearedseason
}

// SeasonID returns the "season" edge ID in the mutation.
func (m *StandingsMutation) SeasonID() (id int, exists bool) {
	if m.season != nil {
		return *m.season, true
	}
	return
}

// SeasonIDs returns the "season" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SeasonID instead. It exists only for internal usage by the builders.
func (m *StandingsMutation) SeasonIDs() (ids []int) {
	if id := m.season; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSeason resets all changes to the "season" edge.
func (m *StandingsMutation) ResetSeason() {
	m.season = nil
	m.clearedseason = false
}

// Where appends a list predicates to the StandingsMutation builder.
func (m *StandingsMutation) Where(ps ...predicate.Standings) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StandingsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StandingsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Standings, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StandingsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StandingsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Standings).
func (m *StandingsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StandingsMutation) Fields() []string {
	fields := make([]string, 0, 26)
	if m.rank != nil {
		fields = append(fields, standings.FieldRank)
	}
	if m.points != nil {
		fields = append(fields, standings.FieldPoints)
	}
	if m.goalsDiff != nil {
		fields = append(fields, standings.FieldGoalsDiff)
	}
	if m.group != nil {
		fields = append(fields, standings.FieldGroup)
	}
	if m.form != nil {
		fields = append(fields, standings.FieldForm)
	}
	if m.status != nil {
		fields = append(fields, standings.FieldStatus)
	}
	if m.description != nil {
		fields = append(fields, standings.FieldDescription)
	}
	if m.allPlayed != nil {
		fields = append(fields, standings.FieldAllPlayed)
	}
	if m.allWin != nil {
		fields = append(fields, standings.FieldAllWin)
	}
	if m.allDraw != nil {
		fields = append(fields, standings.FieldAllDraw)
	}
	if m.allLose != nil {
		fields = append(fields, standings.FieldAllLose)
	}
	if m.allGoalsFor != nil {
		fields = append(fields, standings.FieldAllGoalsFor)
	}
	if m.allGoalsAgainst != nil {
		fields = append(fields, standings.FieldAllGoalsAgainst)
	}
	if m.homePlayed != nil {
		fields = append(fields, standings.FieldHomePlayed)
	}
	if m.homeWin != nil {
		fields = append(fields, standings.FieldHomeWin)
	}
	if m.homeDraw != nil {
		fields = append(fields, standings.FieldHomeDraw)
	}
	if m.homeLose != nil {
		fields = append(fields, standings.FieldHomeLose)
	}
	if m.homeGoalsFor != nil {
		fields = append(fields, standings.FieldHomeGoalsFor)
	}
	if m.homeGoalsAgainst != nil {
		fields = append(fields, standings.FieldHomeGoalsAgainst)
	}
	if m.awayPlayed != nil {
		fields = append(fields, standings.FieldAwayPlayed)
	}
	if m.awayWin != nil {
		fields = append(fields, standings.FieldAwayWin)
	}
	if m.awayDraw != nil {
		fields = append(fields, standings.FieldAwayDraw)
	}
	if m.awayLose != nil {
		fields = append(fields, standings.FieldAwayLose)
	}
	if m.awayGoalsFor != nil {
		fields = append(fields, standings.FieldAwayGoalsFor)
	}
	if m.awayGoalsAgainst != nil {
		fields = append(fields, standings.FieldAwayGoalsAgainst)
	}
	if m._LastUpdated != nil {
		fields = append(fields, standings.FieldLastUpdated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StandingsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case standings.FieldRank:
		return m.Rank()
	case standings.FieldPoints:
		return m.Points()
	case standings.FieldGoalsDiff:
		return m.GoalsDiff()
	case standings.FieldGroup:
		return m.Group()
	case standings.FieldForm:
		return m.Form()
	case standings.FieldStatus:
		return m.Status()
	case standings.FieldDescription:
		return m.Description()
	case standings.FieldAllPlayed:
		return m.AllPlayed()
	case standings.FieldAllWin:
		return m.AllWin()
	case standings.FieldAllDraw:
		return m.AllDraw()
	case standings.FieldAllLose:
		return m.AllLose()
	case standings.FieldAllGoalsFor:
		return m.AllGoalsFor()
	case standings.FieldAllGoalsAgainst:
		return m.AllGoalsAgainst()
	case standings.FieldHomePlayed:
		return m.HomePlayed()
	case standings.FieldHomeWin:
		return m.HomeWin()
	case standings.FieldHomeDraw:
		return m.HomeDraw()
	case standings.FieldHomeLose:
		return m.HomeLose()
	case standings.FieldHomeGoalsFor:
		return m.HomeGoalsFor()
	case standings.FieldHomeGoalsAgainst:
		return m.HomeGoalsAgainst()
	case standings.FieldAwayPlayed:
		return m.AwayPlayed()
	case standings.FieldAwayWin:
		return m.AwayWin()
	case standings.FieldAwayDraw:
		return m.AwayDraw()
	case standings.FieldAwayLose:
		return m.AwayLose()
	case standings.FieldAwayGoalsFor:
		return m.AwayGoalsFor()
	case standings.FieldAwayGoalsAgainst:
		return m.AwayGoalsAgainst()
	case standings.FieldLastUpdated:
		return m.LastUpdated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StandingsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case standings.FieldRank:
		return m.OldRank(ctx)
	case standings.FieldPoints:
		return m.OldPoints(ctx)
	case standings.FieldGoalsDiff:
		return m.OldGoalsDiff(ctx)
	case standings.FieldGroup:
		return m.OldGroup(ctx)
	case standings.FieldForm:
		return m.OldForm(ctx)
	case standings.FieldStatus:
		return m.OldStatus(ctx)
	case standings.FieldDescription:
		return m.OldDescription(ctx)
	case standings.FieldAllPlayed:
		return m.OldAllPlayed(ctx)
	case standings.FieldAllWin:
		return m.OldAllWin(ctx)
	case standings.FieldAllDraw:
		return m.OldAllDraw(ctx)
	case standings.FieldAllLose:
		return m.OldAllLose(ctx)
	case standings.FieldAllGoalsFor:
		return m.OldAllGoalsFor(ctx)
	case standings.FieldAllGoalsAgainst:
		return m.OldAllGoalsAgainst(ctx)
	case standings.FieldHomePlayed:
		return m.OldHomePlayed(ctx)
	case standings.FieldHomeWin:
		return m.OldHomeWin(ctx)
	case standings.FieldHomeDraw:
		return m.OldHomeDraw(ctx)
	case standings.FieldHomeLose:
		return m.OldHomeLose(ctx)
	case standings.FieldHomeGoalsFor:
		return m.OldHomeGoalsFor(ctx)
	case standings.FieldHomeGoalsAgainst:
		return m.OldHomeGoalsAgainst(ctx)
	case standings.FieldAwayPlayed:
		return m.OldAwayPlayed(ctx)
	case standings.FieldAwayWin:
		return m.OldAwayWin(ctx)
	case standings.FieldAwayDraw:
		return m.OldAwayDraw(ctx)
	case standings.FieldAwayLose:
		return m.OldAwayLose(ctx)
	case standings.FieldAwayGoalsFor:
		return m.OldAwayGoalsFor(ctx)
	case standings.FieldAwayGoalsAgainst:
		return m.OldAwayGoalsAgainst(ctx)
	case standings.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	}
	return nil, fmt.Errorf("unknown Standings field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StandingsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case standings.FieldRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRank(v)
		return nil
	case standings.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoints(v)
		return nil
	case standings.FieldGoalsDiff:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsDiff(v)
		return nil
	case standings.FieldGroup:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroup(v)
		return nil
	case standings.FieldForm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForm(v)
		return nil
	case standings.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case standings.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case standings.FieldAllPlayed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllPlayed(v)
		return nil
	case standings.FieldAllWin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllWin(v)
		return nil
	case standings.FieldAllDraw:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllDraw(v)
		return nil
	case standings.FieldAllLose:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllLose(v)
		return nil
	case standings.FieldAllGoalsFor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllGoalsFor(v)
		return nil
	case standings.FieldAllGoalsAgainst:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllGoalsAgainst(v)
		return nil
	case standings.FieldHomePlayed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomePlayed(v)
		return nil
	case standings.FieldHomeWin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomeWin(v)
		return nil
	case standings.FieldHomeDraw:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomeDraw(v)
		return nil
	case standings.FieldHomeLose:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomeLose(v)
		return nil
	case standings.FieldHomeGoalsFor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomeGoalsFor(v)
		return nil
	case standings.FieldHomeGoalsAgainst:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomeGoalsAgainst(v)
		return nil
	case standings.FieldAwayPlayed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAwayPlayed(v)
		return nil
	case standings.FieldAwayWin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAwayWin(v)
		return nil
	case standings.FieldAwayDraw:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAwayDraw(v)
		return nil
	case standings.FieldAwayLose:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAwayLose(v)
		return nil
	case standings.FieldAwayGoalsFor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAwayGoalsFor(v)
		return nil
	case standings.FieldAwayGoalsAgainst:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAwayGoalsAgainst(v)
		return nil
	case standings.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	}
	return fmt.Errorf("unknown Standings field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StandingsMutation) AddedFields() []string {
	var fields []string
	if m.addrank != nil {
		fields = append(fields, standings.FieldRank)
	}
	if m.addpoints != nil {
		fields = append(fields, standings.FieldPoints)
	}
	if m.addgoalsDiff != nil {
		fields = append(fields, standings.FieldGoalsDiff)
	}
	if m.addallPlayed != nil {
		fields = append(fields, standings.FieldAllPlayed)
	}
	if m.addallWin != nil {
		fields = append(fields, standings.FieldAllWin)
	}
	if m.addallDraw != nil {
		fields = append(fields, standings.FieldAllDraw)
	}
	if m.addallLose != nil {
		fields = append(fields, standings.FieldAllLose)
	}
	if m.addallGoalsFor != nil {
		fields = append(fields, standings.FieldAllGoalsFor)
	}
	if m.addallGoalsAgainst != nil {
		fields = append(fields, standings.FieldAllGoalsAgainst)
	}
	if m.addhomePlayed != nil {
		fields = append(fields, standings.FieldHomePlayed)
	}
	if m.addhomeWin != nil {
		fields = append(fields, standings.FieldHomeWin)
	}
	if m.addhomeDraw != nil {
		fields = append(fields, standings.FieldHomeDraw)
	}
	if m.addhomeLose != nil {
		fields = append(fields, standings.FieldHomeLose)
	}
	if m.addhomeGoalsFor != nil {
		fields = append(fields, standings.FieldHomeGoalsFor)
	}
	if m.addhomeGoalsAgainst != nil {
		fields = append(fields, standings.FieldHomeGoalsAgainst)
	}
	if m.addawayPlayed != nil {
		fields = append(fields, standings.FieldAwayPlayed)
	}
	if m.addawayWin != nil {
		fields = append(fields, standings.FieldAwayWin)
	}
	if m.addawayDraw != nil {
		fields = append(fields, standings.FieldAwayDraw)
	}
	if m.addawayLose != nil {
		fields = append(fields, standings.FieldAwayLose)
	}
	if m.addawayGoalsFor != nil {
		fields = append(fields, standings.FieldAwayGoalsFor)
	}
	if m.addawayGoalsAgainst != nil {
		fields = append(fields, standings.FieldAwayGoalsAgainst)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StandingsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case standings.FieldRank:
		return m.AddedRank()
	case standings.FieldPoints:
		return m.AddedPoints()
	case standings.FieldGoalsDiff:
		return m.AddedGoalsDiff()
	case standings.FieldAllPlayed:
		return m.AddedAllPlayed()
	case standings.FieldAllWin:
		return m.AddedAllWin()
	case standings.FieldAllDraw:
		return m.AddedAllDraw()
	case standings.FieldAllLose:
		return m.AddedAllLose()
	case standings.FieldAllGoalsFor:
		return m.AddedAllGoalsFor()
	case standings.FieldAllGoalsAgainst:
		return m.AddedAllGoalsAgainst()
	case standings.FieldHomePlayed:
		return m.AddedHomePlayed()
	case standings.FieldHomeWin:
		return m.AddedHomeWin()
	case standings.FieldHomeDraw:
		return m.AddedHomeDraw()
	case standings.FieldHomeLose:
		return m.AddedHomeLose()
	case standings.FieldHomeGoalsFor:
		return m.AddedHomeGoalsFor()
	case standings.FieldHomeGoalsAgainst:
		return m.AddedHomeGoalsAgainst()
	case standings.FieldAwayPlayed:
		return m.AddedAwayPlayed()
	case standings.FieldAwayWin:
		return m.AddedAwayWin()
	case standings.FieldAwayDraw:
		return m.AddedAwayDraw()
	case standings.FieldAwayLose:
		return m.AddedAwayLose()
	case standings.FieldAwayGoalsFor:
		return m.AddedAwayGoalsFor()
	case standings.FieldAwayGoalsAgainst:
		return m.AddedAwayGoalsAgainst()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StandingsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case standings.FieldRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRank(v)
		return nil
	case standings.FieldPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoints(v)
		return nil
	case standings.FieldGoalsDiff:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGoalsDiff(v)
		return nil
	case standings.FieldAllPlayed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAllPlayed(v)
		return nil
	case standings.FieldAllWin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAllWin(v)
		return nil
	case standings.FieldAllDraw:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAllDraw(v)
		return nil
	case standings.FieldAllLose:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAllLose(v)
		return nil
	case standings.FieldAllGoalsFor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAllGoalsFor(v)
		return nil
	case standings.FieldAllGoalsAgainst:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAllGoalsAgainst(v)
		return nil
	case standings.FieldHomePlayed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHomePlayed(v)
		return nil
	case standings.FieldHomeWin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHomeWin(v)
		return nil
	case standings.FieldHomeDraw:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHomeDraw(v)
		return nil
	case standings.FieldHomeLose:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHomeLose(v)
		return nil
	case standings.FieldHomeGoalsFor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHomeGoalsFor(v)
		return nil
	case standings.FieldHomeGoalsAgainst:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHomeGoalsAgainst(v)
		return nil
	case standings.FieldAwayPlayed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAwayPlayed(v)
		return nil
	case standings.FieldAwayWin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAwayWin(v)
		return nil
	case standings.FieldAwayDraw:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAwayDraw(v)
		return nil
	case standings.FieldAwayLose:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAwayLose(v)
		return nil
	case standings.FieldAwayGoalsFor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAwayGoalsFor(v)
		return nil
	case standings.FieldAwayGoalsAgainst:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAwayGoalsAgainst(v)
		return nil
	}
	return fmt.Errorf("unknown Standings numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StandingsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(standings.FieldStatus) {
		fields = append(fields, standings.FieldStatus)
	}
	if m.FieldCleared(standings.FieldDescription) {
		fields = append(fields, standings.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StandingsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StandingsMutation) ClearField(name string) error {
	switch name {
	case standings.FieldStatus:
		m.ClearStatus()
		return nil
	case standings.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Standings nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StandingsMutation) ResetField(name string) error {
	switch name {
	case standings.FieldRank:
		m.ResetRank()
		return nil
	case standings.FieldPoints:
		m.ResetPoints()
		return nil
	case standings.FieldGoalsDiff:
		m.ResetGoalsDiff()
		return nil
	case standings.FieldGroup:
		m.ResetGroup()
		return nil
	case standings.FieldForm:
		m.ResetForm()
		return nil
	case standings.FieldStatus:
		m.ResetStatus()
		return nil
	case standings.FieldDescription:
		m.ResetDescription()
		return nil
	case standings.FieldAllPlayed:
		m.ResetAllPlayed()
		return nil
	case standings.FieldAllWin:
		m.ResetAllWin()
		return nil
	case standings.FieldAllDraw:
		m.ResetAllDraw()
		return nil
	case standings.FieldAllLose:
		m.ResetAllLose()
		return nil
	case standings.FieldAllGoalsFor:
		m.ResetAllGoalsFor()
		return nil
	case standings.FieldAllGoalsAgainst:
		m.ResetAllGoalsAgainst()
		return nil
	case standings.FieldHomePlayed:
		m.ResetHomePlayed()
		return nil
	case standings.FieldHomeWin:
		m.ResetHomeWin()
		return nil
	case standings.FieldHomeDraw:
		m.ResetHomeDraw()
		return nil
	case standings.FieldHomeLose:
		m.ResetHomeLose()
		return nil
	case standings.FieldHomeGoalsFor:
		m.ResetHomeGoalsFor()
		return nil
	case standings.FieldHomeGoalsAgainst:
		m.ResetHomeGoalsAgainst()
		return nil
	case standings.FieldAwayPlayed:
		m.ResetAwayPlayed()
		return nil
	case standings.FieldAwayWin:
		m.ResetAwayWin()
		return nil
	case standings.FieldAwayDraw:
		m.ResetAwayDraw()
		return nil
	case standings.FieldAwayLose:
		m.ResetAwayLose()
		return nil
	case standings.FieldAwayGoalsFor:
		m.ResetAwayGoalsFor()
		return nil
	case standings.FieldAwayGoalsAgainst:
		m.ResetAwayGoalsAgainst()
		return nil
	case standings.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown Standings field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StandingsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.team != nil {
		edges = append(edges, standings.EdgeTeam)
	}
	if m.season != nil {
		edges = append(edges, standings.EdgeSeason)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StandingsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case standings.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	case standings.EdgeSeason:
		if id := m.season; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StandingsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StandingsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StandingsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedteam {
		edges = append(edges, standings.EdgeTeam)
	}
	if m.clearedseason {
		edges = append(edges, standings.EdgeSeason)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StandingsMutation) EdgeCleared(name string) bool {
	switch name {
	case standings.EdgeTeam:
		return m.clearedteam
	case standings.EdgeSeason:
		return m.clearedseason
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StandingsMutation) ClearEdge(name string) error {
	switch name {
	case standings.EdgeTeam:
		m.ClearTeam()
		return nil
	case standings.EdgeSeason:
		m.ClearSeason()
		return nil
	}
	return fmt.Errorf("unknown Standings unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StandingsMutation) ResetEdge(name string) error {
	switch name {
	case standings.EdgeTeam:
		m.ResetTeam()
		return nil
	case standings.EdgeSeason:
		m.ResetSeason()
		return nil
	}
	return fmt.Errorf("unknown Standings edge %s", name)
}

// TSBiggestMutation represents an operation that mutates the TSBiggest nodes in the graph.
type TSBiggestMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	streakWins          *int
	addstreakWins       *int
	streakLosses        *int
	addstreakLosses     *int
	streakDraws         *int
	addstreakDraws      *int
	winsHome            *string
	winsAway            *string
	lossesHome          *string
	lossesAway          *string
	goalsForHome        *int
	addgoalsForHome     *int
	goalsForAway        *int
	addgoalsForAway     *int
	goalsAgainstHome    *int
	addgoalsAgainstHome *int
	goalsAgainstAway    *int
	addgoalsAgainstAway *int
	lastUpdated         *time.Time
	clearedFields       map[string]struct{}
	team                *int
	clearedteam         bool
	done                bool
	oldValue            func(context.Context) (*TSBiggest, error)
	predicates          []predicate.TSBiggest
}

var _ ent.Mutation = (*TSBiggestMutation)(nil)

// tsbiggestOption allows management of the mutation configuration using functional options.
type tsbiggestOption func(*TSBiggestMutation)

// newTSBiggestMutation creates new mutation for the TSBiggest entity.
func newTSBiggestMutation(c config, op Op, opts ...tsbiggestOption) *TSBiggestMutation {
	m := &TSBiggestMutation{
		config:        c,
		op:            op,
		typ:           TypeTSBiggest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTSBiggestID sets the ID field of the mutation.
func withTSBiggestID(id int) tsbiggestOption {
	return func(m *TSBiggestMutation) {
		var (
			err   error
			once  sync.Once
			value *TSBiggest
		)
		m.oldValue = func(ctx context.Context) (*TSBiggest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TSBiggest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTSBiggest sets the old TSBiggest of the mutation.
func withTSBiggest(node *TSBiggest) tsbiggestOption {
	return func(m *TSBiggestMutation) {
		m.oldValue = func(context.Context) (*TSBiggest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TSBiggestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TSBiggestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TSBiggestMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TSBiggestMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TSBiggest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStreakWins sets the "streakWins" field.
func (m *TSBiggestMutation) SetStreakWins(i int) {
	m.streakWins = &i
	m.addstreakWins = nil
}

// StreakWins returns the value of the "streakWins" field in the mutation.
func (m *TSBiggestMutation) StreakWins() (r int, exists bool) {
	v := m.streakWins
	if v == nil {
		return
	}
	return *v, true
}

// OldStreakWins returns the old "streakWins" field's value of the TSBiggest entity.
// If the TSBiggest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSBiggestMutation) OldStreakWins(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreakWins is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreakWins requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreakWins: %w", err)
	}
	return oldValue.StreakWins, nil
}

// AddStreakWins adds i to the "streakWins" field.
func (m *TSBiggestMutation) AddStreakWins(i int) {
	if m.addstreakWins != nil {
		*m.addstreakWins += i
	} else {
		m.addstreakWins = &i
	}
}

// AddedStreakWins returns the value that was added to the "streakWins" field in this mutation.
func (m *TSBiggestMutation) AddedStreakWins() (r int, exists bool) {
	v := m.addstreakWins
	if v == nil {
		return
	}
	return *v, true
}

// ClearStreakWins clears the value of the "streakWins" field.
func (m *TSBiggestMutation) ClearStreakWins() {
	m.streakWins = nil
	m.addstreakWins = nil
	m.clearedFields[tsbiggest.FieldStreakWins] = struct{}{}
}

// StreakWinsCleared returns if the "streakWins" field was cleared in this mutation.
func (m *TSBiggestMutation) StreakWinsCleared() bool {
	_, ok := m.clearedFields[tsbiggest.FieldStreakWins]
	return ok
}

// ResetStreakWins resets all changes to the "streakWins" field.
func (m *TSBiggestMutation) ResetStreakWins() {
	m.streakWins = nil
	m.addstreakWins = nil
	delete(m.clearedFields, tsbiggest.FieldStreakWins)
}

// SetStreakLosses sets the "streakLosses" field.
func (m *TSBiggestMutation) SetStreakLosses(i int) {
	m.streakLosses = &i
	m.addstreakLosses = nil
}

// StreakLosses returns the value of the "streakLosses" field in the mutation.
func (m *TSBiggestMutation) StreakLosses() (r int, exists bool) {
	v := m.streakLosses
	if v == nil {
		return
	}
	return *v, true
}

// OldStreakLosses returns the old "streakLosses" field's value of the TSBiggest entity.
// If the TSBiggest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSBiggestMutation) OldStreakLosses(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreakLosses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreakLosses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreakLosses: %w", err)
	}
	return oldValue.StreakLosses, nil
}

// AddStreakLosses adds i to the "streakLosses" field.
func (m *TSBiggestMutation) AddStreakLosses(i int) {
	if m.addstreakLosses != nil {
		*m.addstreakLosses += i
	} else {
		m.addstreakLosses = &i
	}
}

// AddedStreakLosses returns the value that was added to the "streakLosses" field in this mutation.
func (m *TSBiggestMutation) AddedStreakLosses() (r int, exists bool) {
	v := m.addstreakLosses
	if v == nil {
		return
	}
	return *v, true
}

// ClearStreakLosses clears the value of the "streakLosses" field.
func (m *TSBiggestMutation) ClearStreakLosses() {
	m.streakLosses = nil
	m.addstreakLosses = nil
	m.clearedFields[tsbiggest.FieldStreakLosses] = struct{}{}
}

// StreakLossesCleared returns if the "streakLosses" field was cleared in this mutation.
func (m *TSBiggestMutation) StreakLossesCleared() bool {
	_, ok := m.clearedFields[tsbiggest.FieldStreakLosses]
	return ok
}

// ResetStreakLosses resets all changes to the "streakLosses" field.
func (m *TSBiggestMutation) ResetStreakLosses() {
	m.streakLosses = nil
	m.addstreakLosses = nil
	delete(m.clearedFields, tsbiggest.FieldStreakLosses)
}

// SetStreakDraws sets the "streakDraws" field.
func (m *TSBiggestMutation) SetStreakDraws(i int) {
	m.streakDraws = &i
	m.addstreakDraws = nil
}

// StreakDraws returns the value of the "streakDraws" field in the mutation.
func (m *TSBiggestMutation) StreakDraws() (r int, exists bool) {
	v := m.streakDraws
	if v == nil {
		return
	}
	return *v, true
}

// OldStreakDraws returns the old "streakDraws" field's value of the TSBiggest entity.
// If the TSBiggest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSBiggestMutation) OldStreakDraws(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreakDraws is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreakDraws requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreakDraws: %w", err)
	}
	return oldValue.StreakDraws, nil
}

// AddStreakDraws adds i to the "streakDraws" field.
func (m *TSBiggestMutation) AddStreakDraws(i int) {
	if m.addstreakDraws != nil {
		*m.addstreakDraws += i
	} else {
		m.addstreakDraws = &i
	}
}

// AddedStreakDraws returns the value that was added to the "streakDraws" field in this mutation.
func (m *TSBiggestMutation) AddedStreakDraws() (r int, exists bool) {
	v := m.addstreakDraws
	if v == nil {
		return
	}
	return *v, true
}

// ClearStreakDraws clears the value of the "streakDraws" field.
func (m *TSBiggestMutation) ClearStreakDraws() {
	m.streakDraws = nil
	m.addstreakDraws = nil
	m.clearedFields[tsbiggest.FieldStreakDraws] = struct{}{}
}

// StreakDrawsCleared returns if the "streakDraws" field was cleared in this mutation.
func (m *TSBiggestMutation) StreakDrawsCleared() bool {
	_, ok := m.clearedFields[tsbiggest.FieldStreakDraws]
	return ok
}

// ResetStreakDraws resets all changes to the "streakDraws" field.
func (m *TSBiggestMutation) ResetStreakDraws() {
	m.streakDraws = nil
	m.addstreakDraws = nil
	delete(m.clearedFields, tsbiggest.FieldStreakDraws)
}

// SetWinsHome sets the "winsHome" field.
func (m *TSBiggestMutation) SetWinsHome(s string) {
	m.winsHome = &s
}

// WinsHome returns the value of the "winsHome" field in the mutation.
func (m *TSBiggestMutation) WinsHome() (r string, exists bool) {
	v := m.winsHome
	if v == nil {
		return
	}
	return *v, true
}

// OldWinsHome returns the old "winsHome" field's value of the TSBiggest entity.
// If the TSBiggest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSBiggestMutation) OldWinsHome(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWinsHome is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWinsHome requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWinsHome: %w", err)
	}
	return oldValue.WinsHome, nil
}

// ClearWinsHome clears the value of the "winsHome" field.
func (m *TSBiggestMutation) ClearWinsHome() {
	m.winsHome = nil
	m.clearedFields[tsbiggest.FieldWinsHome] = struct{}{}
}

// WinsHomeCleared returns if the "winsHome" field was cleared in this mutation.
func (m *TSBiggestMutation) WinsHomeCleared() bool {
	_, ok := m.clearedFields[tsbiggest.FieldWinsHome]
	return ok
}

// ResetWinsHome resets all changes to the "winsHome" field.
func (m *TSBiggestMutation) ResetWinsHome() {
	m.winsHome = nil
	delete(m.clearedFields, tsbiggest.FieldWinsHome)
}

// SetWinsAway sets the "winsAway" field.
func (m *TSBiggestMutation) SetWinsAway(s string) {
	m.winsAway = &s
}

// WinsAway returns the value of the "winsAway" field in the mutation.
func (m *TSBiggestMutation) WinsAway() (r string, exists bool) {
	v := m.winsAway
	if v == nil {
		return
	}
	return *v, true
}

// OldWinsAway returns the old "winsAway" field's value of the TSBiggest entity.
// If the TSBiggest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSBiggestMutation) OldWinsAway(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWinsAway is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWinsAway requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWinsAway: %w", err)
	}
	return oldValue.WinsAway, nil
}

// ClearWinsAway clears the value of the "winsAway" field.
func (m *TSBiggestMutation) ClearWinsAway() {
	m.winsAway = nil
	m.clearedFields[tsbiggest.FieldWinsAway] = struct{}{}
}

// WinsAwayCleared returns if the "winsAway" field was cleared in this mutation.
func (m *TSBiggestMutation) WinsAwayCleared() bool {
	_, ok := m.clearedFields[tsbiggest.FieldWinsAway]
	return ok
}

// ResetWinsAway resets all changes to the "winsAway" field.
func (m *TSBiggestMutation) ResetWinsAway() {
	m.winsAway = nil
	delete(m.clearedFields, tsbiggest.FieldWinsAway)
}

// SetLossesHome sets the "lossesHome" field.
func (m *TSBiggestMutation) SetLossesHome(s string) {
	m.lossesHome = &s
}

// LossesHome returns the value of the "lossesHome" field in the mutation.
func (m *TSBiggestMutation) LossesHome() (r string, exists bool) {
	v := m.lossesHome
	if v == nil {
		return
	}
	return *v, true
}

// OldLossesHome returns the old "lossesHome" field's value of the TSBiggest entity.
// If the TSBiggest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSBiggestMutation) OldLossesHome(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLossesHome is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLossesHome requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLossesHome: %w", err)
	}
	return oldValue.LossesHome, nil
}

// ClearLossesHome clears the value of the "lossesHome" field.
func (m *TSBiggestMutation) ClearLossesHome() {
	m.lossesHome = nil
	m.clearedFields[tsbiggest.FieldLossesHome] = struct{}{}
}

// LossesHomeCleared returns if the "lossesHome" field was cleared in this mutation.
func (m *TSBiggestMutation) LossesHomeCleared() bool {
	_, ok := m.clearedFields[tsbiggest.FieldLossesHome]
	return ok
}

// ResetLossesHome resets all changes to the "lossesHome" field.
func (m *TSBiggestMutation) ResetLossesHome() {
	m.lossesHome = nil
	delete(m.clearedFields, tsbiggest.FieldLossesHome)
}

// SetLossesAway sets the "lossesAway" field.
func (m *TSBiggestMutation) SetLossesAway(s string) {
	m.lossesAway = &s
}

// LossesAway returns the value of the "lossesAway" field in the mutation.
func (m *TSBiggestMutation) LossesAway() (r string, exists bool) {
	v := m.lossesAway
	if v == nil {
		return
	}
	return *v, true
}

// OldLossesAway returns the old "lossesAway" field's value of the TSBiggest entity.
// If the TSBiggest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSBiggestMutation) OldLossesAway(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLossesAway is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLossesAway requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLossesAway: %w", err)
	}
	return oldValue.LossesAway, nil
}

// ClearLossesAway clears the value of the "lossesAway" field.
func (m *TSBiggestMutation) ClearLossesAway() {
	m.lossesAway = nil
	m.clearedFields[tsbiggest.FieldLossesAway] = struct{}{}
}

// LossesAwayCleared returns if the "lossesAway" field was cleared in this mutation.
func (m *TSBiggestMutation) LossesAwayCleared() bool {
	_, ok := m.clearedFields[tsbiggest.FieldLossesAway]
	return ok
}

// ResetLossesAway resets all changes to the "lossesAway" field.
func (m *TSBiggestMutation) ResetLossesAway() {
	m.lossesAway = nil
	delete(m.clearedFields, tsbiggest.FieldLossesAway)
}

// SetGoalsForHome sets the "goalsForHome" field.
func (m *TSBiggestMutation) SetGoalsForHome(i int) {
	m.goalsForHome = &i
	m.addgoalsForHome = nil
}

// GoalsForHome returns the value of the "goalsForHome" field in the mutation.
func (m *TSBiggestMutation) GoalsForHome() (r int, exists bool) {
	v := m.goalsForHome
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsForHome returns the old "goalsForHome" field's value of the TSBiggest entity.
// If the TSBiggest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSBiggestMutation) OldGoalsForHome(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsForHome is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsForHome requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsForHome: %w", err)
	}
	return oldValue.GoalsForHome, nil
}

// AddGoalsForHome adds i to the "goalsForHome" field.
func (m *TSBiggestMutation) AddGoalsForHome(i int) {
	if m.addgoalsForHome != nil {
		*m.addgoalsForHome += i
	} else {
		m.addgoalsForHome = &i
	}
}

// AddedGoalsForHome returns the value that was added to the "goalsForHome" field in this mutation.
func (m *TSBiggestMutation) AddedGoalsForHome() (r int, exists bool) {
	v := m.addgoalsForHome
	if v == nil {
		return
	}
	return *v, true
}

// ClearGoalsForHome clears the value of the "goalsForHome" field.
func (m *TSBiggestMutation) ClearGoalsForHome() {
	m.goalsForHome = nil
	m.addgoalsForHome = nil
	m.clearedFields[tsbiggest.FieldGoalsForHome] = struct{}{}
}

// GoalsForHomeCleared returns if the "goalsForHome" field was cleared in this mutation.
func (m *TSBiggestMutation) GoalsForHomeCleared() bool {
	_, ok := m.clearedFields[tsbiggest.FieldGoalsForHome]
	return ok
}

// ResetGoalsForHome resets all changes to the "goalsForHome" field.
func (m *TSBiggestMutation) ResetGoalsForHome() {
	m.goalsForHome = nil
	m.addgoalsForHome = nil
	delete(m.clearedFields, tsbiggest.FieldGoalsForHome)
}

// SetGoalsForAway sets the "goalsForAway" field.
func (m *TSBiggestMutation) SetGoalsForAway(i int) {
	m.goalsForAway = &i
	m.addgoalsForAway = nil
}

// GoalsForAway returns the value of the "goalsForAway" field in the mutation.
func (m *TSBiggestMutation) GoalsForAway() (r int, exists bool) {
	v := m.goalsForAway
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsForAway returns the old "goalsForAway" field's value of the TSBiggest entity.
// If the TSBiggest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSBiggestMutation) OldGoalsForAway(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsForAway is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsForAway requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsForAway: %w", err)
	}
	return oldValue.GoalsForAway, nil
}

// AddGoalsForAway adds i to the "goalsForAway" field.
func (m *TSBiggestMutation) AddGoalsForAway(i int) {
	if m.addgoalsForAway != nil {
		*m.addgoalsForAway += i
	} else {
		m.addgoalsForAway = &i
	}
}

// AddedGoalsForAway returns the value that was added to the "goalsForAway" field in this mutation.
func (m *TSBiggestMutation) AddedGoalsForAway() (r int, exists bool) {
	v := m.addgoalsForAway
	if v == nil {
		return
	}
	return *v, true
}

// ClearGoalsForAway clears the value of the "goalsForAway" field.
func (m *TSBiggestMutation) ClearGoalsForAway() {
	m.goalsForAway = nil
	m.addgoalsForAway = nil
	m.clearedFields[tsbiggest.FieldGoalsForAway] = struct{}{}
}

// GoalsForAwayCleared returns if the "goalsForAway" field was cleared in this mutation.
func (m *TSBiggestMutation) GoalsForAwayCleared() bool {
	_, ok := m.clearedFields[tsbiggest.FieldGoalsForAway]
	return ok
}

// ResetGoalsForAway resets all changes to the "goalsForAway" field.
func (m *TSBiggestMutation) ResetGoalsForAway() {
	m.goalsForAway = nil
	m.addgoalsForAway = nil
	delete(m.clearedFields, tsbiggest.FieldGoalsForAway)
}

// SetGoalsAgainstHome sets the "goalsAgainstHome" field.
func (m *TSBiggestMutation) SetGoalsAgainstHome(i int) {
	m.goalsAgainstHome = &i
	m.addgoalsAgainstHome = nil
}

// GoalsAgainstHome returns the value of the "goalsAgainstHome" field in the mutation.
func (m *TSBiggestMutation) GoalsAgainstHome() (r int, exists bool) {
	v := m.goalsAgainstHome
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsAgainstHome returns the old "goalsAgainstHome" field's value of the TSBiggest entity.
// If the TSBiggest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSBiggestMutation) OldGoalsAgainstHome(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsAgainstHome is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsAgainstHome requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsAgainstHome: %w", err)
	}
	return oldValue.GoalsAgainstHome, nil
}

// AddGoalsAgainstHome adds i to the "goalsAgainstHome" field.
func (m *TSBiggestMutation) AddGoalsAgainstHome(i int) {
	if m.addgoalsAgainstHome != nil {
		*m.addgoalsAgainstHome += i
	} else {
		m.addgoalsAgainstHome = &i
	}
}

// AddedGoalsAgainstHome returns the value that was added to the "goalsAgainstHome" field in this mutation.
func (m *TSBiggestMutation) AddedGoalsAgainstHome() (r int, exists bool) {
	v := m.addgoalsAgainstHome
	if v == nil {
		return
	}
	return *v, true
}

// ClearGoalsAgainstHome clears the value of the "goalsAgainstHome" field.
func (m *TSBiggestMutation) ClearGoalsAgainstHome() {
	m.goalsAgainstHome = nil
	m.addgoalsAgainstHome = nil
	m.clearedFields[tsbiggest.FieldGoalsAgainstHome] = struct{}{}
}

// GoalsAgainstHomeCleared returns if the "goalsAgainstHome" field was cleared in this mutation.
func (m *TSBiggestMutation) GoalsAgainstHomeCleared() bool {
	_, ok := m.clearedFields[tsbiggest.FieldGoalsAgainstHome]
	return ok
}

// ResetGoalsAgainstHome resets all changes to the "goalsAgainstHome" field.
func (m *TSBiggestMutation) ResetGoalsAgainstHome() {
	m.goalsAgainstHome = nil
	m.addgoalsAgainstHome = nil
	delete(m.clearedFields, tsbiggest.FieldGoalsAgainstHome)
}

// SetGoalsAgainstAway sets the "goalsAgainstAway" field.
func (m *TSBiggestMutation) SetGoalsAgainstAway(i int) {
	m.goalsAgainstAway = &i
	m.addgoalsAgainstAway = nil
}

// GoalsAgainstAway returns the value of the "goalsAgainstAway" field in the mutation.
func (m *TSBiggestMutation) GoalsAgainstAway() (r int, exists bool) {
	v := m.goalsAgainstAway
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsAgainstAway returns the old "goalsAgainstAway" field's value of the TSBiggest entity.
// If the TSBiggest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSBiggestMutation) OldGoalsAgainstAway(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsAgainstAway is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsAgainstAway requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsAgainstAway: %w", err)
	}
	return oldValue.GoalsAgainstAway, nil
}

// AddGoalsAgainstAway adds i to the "goalsAgainstAway" field.
func (m *TSBiggestMutation) AddGoalsAgainstAway(i int) {
	if m.addgoalsAgainstAway != nil {
		*m.addgoalsAgainstAway += i
	} else {
		m.addgoalsAgainstAway = &i
	}
}

// AddedGoalsAgainstAway returns the value that was added to the "goalsAgainstAway" field in this mutation.
func (m *TSBiggestMutation) AddedGoalsAgainstAway() (r int, exists bool) {
	v := m.addgoalsAgainstAway
	if v == nil {
		return
	}
	return *v, true
}

// ClearGoalsAgainstAway clears the value of the "goalsAgainstAway" field.
func (m *TSBiggestMutation) ClearGoalsAgainstAway() {
	m.goalsAgainstAway = nil
	m.addgoalsAgainstAway = nil
	m.clearedFields[tsbiggest.FieldGoalsAgainstAway] = struct{}{}
}

// GoalsAgainstAwayCleared returns if the "goalsAgainstAway" field was cleared in this mutation.
func (m *TSBiggestMutation) GoalsAgainstAwayCleared() bool {
	_, ok := m.clearedFields[tsbiggest.FieldGoalsAgainstAway]
	return ok
}

// ResetGoalsAgainstAway resets all changes to the "goalsAgainstAway" field.
func (m *TSBiggestMutation) ResetGoalsAgainstAway() {
	m.goalsAgainstAway = nil
	m.addgoalsAgainstAway = nil
	delete(m.clearedFields, tsbiggest.FieldGoalsAgainstAway)
}

// SetLastUpdated sets the "lastUpdated" field.
func (m *TSBiggestMutation) SetLastUpdated(t time.Time) {
	m.lastUpdated = &t
}

// LastUpdated returns the value of the "lastUpdated" field in the mutation.
func (m *TSBiggestMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.lastUpdated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "lastUpdated" field's value of the TSBiggest entity.
// If the TSBiggest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSBiggestMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ClearLastUpdated clears the value of the "lastUpdated" field.
func (m *TSBiggestMutation) ClearLastUpdated() {
	m.lastUpdated = nil
	m.clearedFields[tsbiggest.FieldLastUpdated] = struct{}{}
}

// LastUpdatedCleared returns if the "lastUpdated" field was cleared in this mutation.
func (m *TSBiggestMutation) LastUpdatedCleared() bool {
	_, ok := m.clearedFields[tsbiggest.FieldLastUpdated]
	return ok
}

// ResetLastUpdated resets all changes to the "lastUpdated" field.
func (m *TSBiggestMutation) ResetLastUpdated() {
	m.lastUpdated = nil
	delete(m.clearedFields, tsbiggest.FieldLastUpdated)
}

// SetTeamID sets the "team" edge to the Team entity by id.
func (m *TSBiggestMutation) SetTeamID(id int) {
	m.team = &id
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *TSBiggestMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *TSBiggestMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamID returns the "team" edge ID in the mutation.
func (m *TSBiggestMutation) TeamID() (id int, exists bool) {
	if m.team != nil {
		return *m.team, true
	}
	return
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *TSBiggestMutation) TeamIDs() (ids []int) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *TSBiggestMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// Where appends a list predicates to the TSBiggestMutation builder.
func (m *TSBiggestMutation) Where(ps ...predicate.TSBiggest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TSBiggestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TSBiggestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TSBiggest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TSBiggestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TSBiggestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TSBiggest).
func (m *TSBiggestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TSBiggestMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.streakWins != nil {
		fields = append(fields, tsbiggest.FieldStreakWins)
	}
	if m.streakLosses != nil {
		fields = append(fields, tsbiggest.FieldStreakLosses)
	}
	if m.streakDraws != nil {
		fields = append(fields, tsbiggest.FieldStreakDraws)
	}
	if m.winsHome != nil {
		fields = append(fields, tsbiggest.FieldWinsHome)
	}
	if m.winsAway != nil {
		fields = append(fields, tsbiggest.FieldWinsAway)
	}
	if m.lossesHome != nil {
		fields = append(fields, tsbiggest.FieldLossesHome)
	}
	if m.lossesAway != nil {
		fields = append(fields, tsbiggest.FieldLossesAway)
	}
	if m.goalsForHome != nil {
		fields = append(fields, tsbiggest.FieldGoalsForHome)
	}
	if m.goalsForAway != nil {
		fields = append(fields, tsbiggest.FieldGoalsForAway)
	}
	if m.goalsAgainstHome != nil {
		fields = append(fields, tsbiggest.FieldGoalsAgainstHome)
	}
	if m.goalsAgainstAway != nil {
		fields = append(fields, tsbiggest.FieldGoalsAgainstAway)
	}
	if m.lastUpdated != nil {
		fields = append(fields, tsbiggest.FieldLastUpdated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TSBiggestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tsbiggest.FieldStreakWins:
		return m.StreakWins()
	case tsbiggest.FieldStreakLosses:
		return m.StreakLosses()
	case tsbiggest.FieldStreakDraws:
		return m.StreakDraws()
	case tsbiggest.FieldWinsHome:
		return m.WinsHome()
	case tsbiggest.FieldWinsAway:
		return m.WinsAway()
	case tsbiggest.FieldLossesHome:
		return m.LossesHome()
	case tsbiggest.FieldLossesAway:
		return m.LossesAway()
	case tsbiggest.FieldGoalsForHome:
		return m.GoalsForHome()
	case tsbiggest.FieldGoalsForAway:
		return m.GoalsForAway()
	case tsbiggest.FieldGoalsAgainstHome:
		return m.GoalsAgainstHome()
	case tsbiggest.FieldGoalsAgainstAway:
		return m.GoalsAgainstAway()
	case tsbiggest.FieldLastUpdated:
		return m.LastUpdated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TSBiggestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tsbiggest.FieldStreakWins:
		return m.OldStreakWins(ctx)
	case tsbiggest.FieldStreakLosses:
		return m.OldStreakLosses(ctx)
	case tsbiggest.FieldStreakDraws:
		return m.OldStreakDraws(ctx)
	case tsbiggest.FieldWinsHome:
		return m.OldWinsHome(ctx)
	case tsbiggest.FieldWinsAway:
		return m.OldWinsAway(ctx)
	case tsbiggest.FieldLossesHome:
		return m.OldLossesHome(ctx)
	case tsbiggest.FieldLossesAway:
		return m.OldLossesAway(ctx)
	case tsbiggest.FieldGoalsForHome:
		return m.OldGoalsForHome(ctx)
	case tsbiggest.FieldGoalsForAway:
		return m.OldGoalsForAway(ctx)
	case tsbiggest.FieldGoalsAgainstHome:
		return m.OldGoalsAgainstHome(ctx)
	case tsbiggest.FieldGoalsAgainstAway:
		return m.OldGoalsAgainstAway(ctx)
	case tsbiggest.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	}
	return nil, fmt.Errorf("unknown TSBiggest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TSBiggestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tsbiggest.FieldStreakWins:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreakWins(v)
		return nil
	case tsbiggest.FieldStreakLosses:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreakLosses(v)
		return nil
	case tsbiggest.FieldStreakDraws:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreakDraws(v)
		return nil
	case tsbiggest.FieldWinsHome:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWinsHome(v)
		return nil
	case tsbiggest.FieldWinsAway:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWinsAway(v)
		return nil
	case tsbiggest.FieldLossesHome:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLossesHome(v)
		return nil
	case tsbiggest.FieldLossesAway:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLossesAway(v)
		return nil
	case tsbiggest.FieldGoalsForHome:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsForHome(v)
		return nil
	case tsbiggest.FieldGoalsForAway:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsForAway(v)
		return nil
	case tsbiggest.FieldGoalsAgainstHome:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsAgainstHome(v)
		return nil
	case tsbiggest.FieldGoalsAgainstAway:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsAgainstAway(v)
		return nil
	case tsbiggest.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	}
	return fmt.Errorf("unknown TSBiggest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TSBiggestMutation) AddedFields() []string {
	var fields []string
	if m.addstreakWins != nil {
		fields = append(fields, tsbiggest.FieldStreakWins)
	}
	if m.addstreakLosses != nil {
		fields = append(fields, tsbiggest.FieldStreakLosses)
	}
	if m.addstreakDraws != nil {
		fields = append(fields, tsbiggest.FieldStreakDraws)
	}
	if m.addgoalsForHome != nil {
		fields = append(fields, tsbiggest.FieldGoalsForHome)
	}
	if m.addgoalsForAway != nil {
		fields = append(fields, tsbiggest.FieldGoalsForAway)
	}
	if m.addgoalsAgainstHome != nil {
		fields = append(fields, tsbiggest.FieldGoalsAgainstHome)
	}
	if m.addgoalsAgainstAway != nil {
		fields = append(fields, tsbiggest.FieldGoalsAgainstAway)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TSBiggestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tsbiggest.FieldStreakWins:
		return m.AddedStreakWins()
	case tsbiggest.FieldStreakLosses:
		return m.AddedStreakLosses()
	case tsbiggest.FieldStreakDraws:
		return m.AddedStreakDraws()
	case tsbiggest.FieldGoalsForHome:
		return m.AddedGoalsForHome()
	case tsbiggest.FieldGoalsForAway:
		return m.AddedGoalsForAway()
	case tsbiggest.FieldGoalsAgainstHome:
		return m.AddedGoalsAgainstHome()
	case tsbiggest.FieldGoalsAgainstAway:
		return m.AddedGoalsAgainstAway()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TSBiggestMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tsbiggest.FieldStreakWins:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStreakWins(v)
		return nil
	case tsbiggest.FieldStreakLosses:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStreakLosses(v)
		return nil
	case tsbiggest.FieldStreakDraws:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStreakDraws(v)
		return nil
	case tsbiggest.FieldGoalsForHome:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGoalsForHome(v)
		return nil
	case tsbiggest.FieldGoalsForAway:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGoalsForAway(v)
		return nil
	case tsbiggest.FieldGoalsAgainstHome:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGoalsAgainstHome(v)
		return nil
	case tsbiggest.FieldGoalsAgainstAway:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGoalsAgainstAway(v)
		return nil
	}
	return fmt.Errorf("unknown TSBiggest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TSBiggestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tsbiggest.FieldStreakWins) {
		fields = append(fields, tsbiggest.FieldStreakWins)
	}
	if m.FieldCleared(tsbiggest.FieldStreakLosses) {
		fields = append(fields, tsbiggest.FieldStreakLosses)
	}
	if m.FieldCleared(tsbiggest.FieldStreakDraws) {
		fields = append(fields, tsbiggest.FieldStreakDraws)
	}
	if m.FieldCleared(tsbiggest.FieldWinsHome) {
		fields = append(fields, tsbiggest.FieldWinsHome)
	}
	if m.FieldCleared(tsbiggest.FieldWinsAway) {
		fields = append(fields, tsbiggest.FieldWinsAway)
	}
	if m.FieldCleared(tsbiggest.FieldLossesHome) {
		fields = append(fields, tsbiggest.FieldLossesHome)
	}
	if m.FieldCleared(tsbiggest.FieldLossesAway) {
		fields = append(fields, tsbiggest.FieldLossesAway)
	}
	if m.FieldCleared(tsbiggest.FieldGoalsForHome) {
		fields = append(fields, tsbiggest.FieldGoalsForHome)
	}
	if m.FieldCleared(tsbiggest.FieldGoalsForAway) {
		fields = append(fields, tsbiggest.FieldGoalsForAway)
	}
	if m.FieldCleared(tsbiggest.FieldGoalsAgainstHome) {
		fields = append(fields, tsbiggest.FieldGoalsAgainstHome)
	}
	if m.FieldCleared(tsbiggest.FieldGoalsAgainstAway) {
		fields = append(fields, tsbiggest.FieldGoalsAgainstAway)
	}
	if m.FieldCleared(tsbiggest.FieldLastUpdated) {
		fields = append(fields, tsbiggest.FieldLastUpdated)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TSBiggestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TSBiggestMutation) ClearField(name string) error {
	switch name {
	case tsbiggest.FieldStreakWins:
		m.ClearStreakWins()
		return nil
	case tsbiggest.FieldStreakLosses:
		m.ClearStreakLosses()
		return nil
	case tsbiggest.FieldStreakDraws:
		m.ClearStreakDraws()
		return nil
	case tsbiggest.FieldWinsHome:
		m.ClearWinsHome()
		return nil
	case tsbiggest.FieldWinsAway:
		m.ClearWinsAway()
		return nil
	case tsbiggest.FieldLossesHome:
		m.ClearLossesHome()
		return nil
	case tsbiggest.FieldLossesAway:
		m.ClearLossesAway()
		return nil
	case tsbiggest.FieldGoalsForHome:
		m.ClearGoalsForHome()
		return nil
	case tsbiggest.FieldGoalsForAway:
		m.ClearGoalsForAway()
		return nil
	case tsbiggest.FieldGoalsAgainstHome:
		m.ClearGoalsAgainstHome()
		return nil
	case tsbiggest.FieldGoalsAgainstAway:
		m.ClearGoalsAgainstAway()
		return nil
	case tsbiggest.FieldLastUpdated:
		m.ClearLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown TSBiggest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TSBiggestMutation) ResetField(name string) error {
	switch name {
	case tsbiggest.FieldStreakWins:
		m.ResetStreakWins()
		return nil
	case tsbiggest.FieldStreakLosses:
		m.ResetStreakLosses()
		return nil
	case tsbiggest.FieldStreakDraws:
		m.ResetStreakDraws()
		return nil
	case tsbiggest.FieldWinsHome:
		m.ResetWinsHome()
		return nil
	case tsbiggest.FieldWinsAway:
		m.ResetWinsAway()
		return nil
	case tsbiggest.FieldLossesHome:
		m.ResetLossesHome()
		return nil
	case tsbiggest.FieldLossesAway:
		m.ResetLossesAway()
		return nil
	case tsbiggest.FieldGoalsForHome:
		m.ResetGoalsForHome()
		return nil
	case tsbiggest.FieldGoalsForAway:
		m.ResetGoalsForAway()
		return nil
	case tsbiggest.FieldGoalsAgainstHome:
		m.ResetGoalsAgainstHome()
		return nil
	case tsbiggest.FieldGoalsAgainstAway:
		m.ResetGoalsAgainstAway()
		return nil
	case tsbiggest.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown TSBiggest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TSBiggestMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.team != nil {
		edges = append(edges, tsbiggest.EdgeTeam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TSBiggestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tsbiggest.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TSBiggestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TSBiggestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TSBiggestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedteam {
		edges = append(edges, tsbiggest.EdgeTeam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TSBiggestMutation) EdgeCleared(name string) bool {
	switch name {
	case tsbiggest.EdgeTeam:
		return m.clearedteam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TSBiggestMutation) ClearEdge(name string) error {
	switch name {
	case tsbiggest.EdgeTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown TSBiggest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TSBiggestMutation) ResetEdge(name string) error {
	switch name {
	case tsbiggest.EdgeTeam:
		m.ResetTeam()
		return nil
	}
	return fmt.Errorf("unknown TSBiggest edge %s", name)
}

// TSCardsMutation represents an operation that mutates the TSCards nodes in the graph.
type TSCardsMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	yellow0To15Total         *int
	addyellow0To15Total      *int
	yellow0To15Percentage    *string
	yellow16To30Total        *int
	addyellow16To30Total     *int
	yellow16To30Percentage   *string
	yellow31To45Total        *int
	addyellow31To45Total     *int
	yellow31To45Percentage   *string
	yellow46To60Total        *int
	addyellow46To60Total     *int
	yellow46To60Percentage   *string
	yellow61To75Total        *int
	addyellow61To75Total     *int
	yellow61To75Percentage   *string
	yellow76To90Total        *int
	addyellow76To90Total     *int
	yellow76To90Percentage   *string
	yellow91to105Total       *int
	addyellow91to105Total    *int
	yellow91to105Percentage  *string
	yellow106To120Total      *int
	addyellow106To120Total   *int
	yellow106To120Percentage *string
	red0To15Total            *int
	addred0To15Total         *int
	red0To15Percentage       *string
	red16To30Total           *int
	addred16To30Total        *int
	red16To30Percentage      *string
	red31To45Total           *int
	addred31To45Total        *int
	red31To45Percentage      *string
	red46To60Total           *int
	addred46To60Total        *int
	red46To60Percentage      *string
	red61To75Total           *int
	addred61To75Total        *int
	red61To75Percentage      *string
	red76To90Total           *int
	addred76To90Total        *int
	red76To90Percentage      *string
	red91to105Total          *int
	addred91to105Total       *int
	red91to105Percentage     *string
	red106To120Total         *int
	addred106To120Total      *int
	red106To120Percentage    *string
	lastUpdated              *time.Time
	clearedFields            map[string]struct{}
	team                     *int
	clearedteam              bool
	done                     bool
	oldValue                 func(context.Context) (*TSCards, error)
	predicates               []predicate.TSCards
}

var _ ent.Mutation = (*TSCardsMutation)(nil)

// tscardsOption allows management of the mutation configuration using functional options.
type tscardsOption func(*TSCardsMutation)

// newTSCardsMutation creates new mutation for the TSCards entity.
func newTSCardsMutation(c config, op Op, opts ...tscardsOption) *TSCardsMutation {
	m := &TSCardsMutation{
		config:        c,
		op:            op,
		typ:           TypeTSCards,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTSCardsID sets the ID field of the mutation.
func withTSCardsID(id int) tscardsOption {
	return func(m *TSCardsMutation) {
		var (
			err   error
			once  sync.Once
			value *TSCards
		)
		m.oldValue = func(ctx context.Context) (*TSCards, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TSCards.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTSCards sets the old TSCards of the mutation.
func withTSCards(node *TSCards) tscardsOption {
	return func(m *TSCardsMutation) {
		m.oldValue = func(context.Context) (*TSCards, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TSCardsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TSCardsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TSCardsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TSCardsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TSCards.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetYellow0To15Total sets the "yellow0To15Total" field.
func (m *TSCardsMutation) SetYellow0To15Total(i int) {
	m.yellow0To15Total = &i
	m.addyellow0To15Total = nil
}

// Yellow0To15Total returns the value of the "yellow0To15Total" field in the mutation.
func (m *TSCardsMutation) Yellow0To15Total() (r int, exists bool) {
	v := m.yellow0To15Total
	if v == nil {
		return
	}
	return *v, true
}

// OldYellow0To15Total returns the old "yellow0To15Total" field's value of the TSCards entity.
// If the TSCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCardsMutation) OldYellow0To15Total(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYellow0To15Total is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYellow0To15Total requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYellow0To15Total: %w", err)
	}
	return oldValue.Yellow0To15Total, nil
}

// AddYellow0To15Total adds i to the "yellow0To15Total" field.
func (m *TSCardsMutation) AddYellow0To15Total(i int) {
	if m.addyellow0To15Total != nil {
		*m.addyellow0To15Total += i
	} else {
		m.addyellow0To15Total = &i
	}
}

// AddedYellow0To15Total returns the value that was added to the "yellow0To15Total" field in this mutation.
func (m *TSCardsMutation) AddedYellow0To15Total() (r int, exists bool) {
	v := m.addyellow0To15Total
	if v == nil {
		return
	}
	return *v, true
}

// ClearYellow0To15Total clears the value of the "yellow0To15Total" field.
func (m *TSCardsMutation) ClearYellow0To15Total() {
	m.yellow0To15Total = nil
	m.addyellow0To15Total = nil
	m.clearedFields[tscards.FieldYellow0To15Total] = struct{}{}
}

// Yellow0To15TotalCleared returns if the "yellow0To15Total" field was cleared in this mutation.
func (m *TSCardsMutation) Yellow0To15TotalCleared() bool {
	_, ok := m.clearedFields[tscards.FieldYellow0To15Total]
	return ok
}

// ResetYellow0To15Total resets all changes to the "yellow0To15Total" field.
func (m *TSCardsMutation) ResetYellow0To15Total() {
	m.yellow0To15Total = nil
	m.addyellow0To15Total = nil
	delete(m.clearedFields, tscards.FieldYellow0To15Total)
}

// SetYellow0To15Percentage sets the "yellow0To15Percentage" field.
func (m *TSCardsMutation) SetYellow0To15Percentage(s string) {
	m.yellow0To15Percentage = &s
}

// Yellow0To15Percentage returns the value of the "yellow0To15Percentage" field in the mutation.
func (m *TSCardsMutation) Yellow0To15Percentage() (r string, exists bool) {
	v := m.yellow0To15Percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldYellow0To15Percentage returns the old "yellow0To15Percentage" field's value of the TSCards entity.
// If the TSCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCardsMutation) OldYellow0To15Percentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYellow0To15Percentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYellow0To15Percentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYellow0To15Percentage: %w", err)
	}
	return oldValue.Yellow0To15Percentage, nil
}

// ClearYellow0To15Percentage clears the value of the "yellow0To15Percentage" field.
func (m *TSCardsMutation) ClearYellow0To15Percentage() {
	m.yellow0To15Percentage = nil
	m.clearedFields[tscards.FieldYellow0To15Percentage] = struct{}{}
}

// Yellow0To15PercentageCleared returns if the "yellow0To15Percentage" field was cleared in this mutation.
func (m *TSCardsMutation) Yellow0To15PercentageCleared() bool {
	_, ok := m.clearedFields[tscards.FieldYellow0To15Percentage]
	return ok
}

// ResetYellow0To15Percentage resets all changes to the "yellow0To15Percentage" field.
func (m *TSCardsMutation) ResetYellow0To15Percentage() {
	m.yellow0To15Percentage = nil
	delete(m.clearedFields, tscards.FieldYellow0To15Percentage)
}

// SetYellow16To30Total sets the "yellow16To30Total" field.
func (m *TSCardsMutation) SetYellow16To30Total(i int) {
	m.yellow16To30Total = &i
	m.addyellow16To30Total = nil
}

// Yellow16To30Total returns the value of the "yellow16To30Total" field in the mutation.
func (m *TSCardsMutation) Yellow16To30Total() (r int, exists bool) {
	v := m.yellow16To30Total
	if v == nil {
		return
	}
	return *v, true
}

// OldYellow16To30Total returns the old "yellow16To30Total" field's value of the TSCards entity.
// If the TSCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCardsMutation) OldYellow16To30Total(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYellow16To30Total is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYellow16To30Total requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYellow16To30Total: %w", err)
	}
	return oldValue.Yellow16To30Total, nil
}

// AddYellow16To30Total adds i to the "yellow16To30Total" field.
func (m *TSCardsMutation) AddYellow16To30Total(i int) {
	if m.addyellow16To30Total != nil {
		*m.addyellow16To30Total += i
	} else {
		m.addyellow16To30Total = &i
	}
}

// AddedYellow16To30Total returns the value that was added to the "yellow16To30Total" field in this mutation.
func (m *TSCardsMutation) AddedYellow16To30Total() (r int, exists bool) {
	v := m.addyellow16To30Total
	if v == nil {
		return
	}
	return *v, true
}

// ClearYellow16To30Total clears the value of the "yellow16To30Total" field.
func (m *TSCardsMutation) ClearYellow16To30Total() {
	m.yellow16To30Total = nil
	m.addyellow16To30Total = nil
	m.clearedFields[tscards.FieldYellow16To30Total] = struct{}{}
}

// Yellow16To30TotalCleared returns if the "yellow16To30Total" field was cleared in this mutation.
func (m *TSCardsMutation) Yellow16To30TotalCleared() bool {
	_, ok := m.clearedFields[tscards.FieldYellow16To30Total]
	return ok
}

// ResetYellow16To30Total resets all changes to the "yellow16To30Total" field.
func (m *TSCardsMutation) ResetYellow16To30Total() {
	m.yellow16To30Total = nil
	m.addyellow16To30Total = nil
	delete(m.clearedFields, tscards.FieldYellow16To30Total)
}

// SetYellow16To30Percentage sets the "yellow16To30Percentage" field.
func (m *TSCardsMutation) SetYellow16To30Percentage(s string) {
	m.yellow16To30Percentage = &s
}

// Yellow16To30Percentage returns the value of the "yellow16To30Percentage" field in the mutation.
func (m *TSCardsMutation) Yellow16To30Percentage() (r string, exists bool) {
	v := m.yellow16To30Percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldYellow16To30Percentage returns the old "yellow16To30Percentage" field's value of the TSCards entity.
// If the TSCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCardsMutation) OldYellow16To30Percentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYellow16To30Percentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYellow16To30Percentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYellow16To30Percentage: %w", err)
	}
	return oldValue.Yellow16To30Percentage, nil
}

// ClearYellow16To30Percentage clears the value of the "yellow16To30Percentage" field.
func (m *TSCardsMutation) ClearYellow16To30Percentage() {
	m.yellow16To30Percentage = nil
	m.clearedFields[tscards.FieldYellow16To30Percentage] = struct{}{}
}

// Yellow16To30PercentageCleared returns if the "yellow16To30Percentage" field was cleared in this mutation.
func (m *TSCardsMutation) Yellow16To30PercentageCleared() bool {
	_, ok := m.clearedFields[tscards.FieldYellow16To30Percentage]
	return ok
}

// ResetYellow16To30Percentage resets all changes to the "yellow16To30Percentage" field.
func (m *TSCardsMutation) ResetYellow16To30Percentage() {
	m.yellow16To30Percentage = nil
	delete(m.clearedFields, tscards.FieldYellow16To30Percentage)
}

// SetYellow31To45Total sets the "yellow31To45Total" field.
func (m *TSCardsMutation) SetYellow31To45Total(i int) {
	m.yellow31To45Total = &i
	m.addyellow31To45Total = nil
}

// Yellow31To45Total returns the value of the "yellow31To45Total" field in the mutation.
func (m *TSCardsMutation) Yellow31To45Total() (r int, exists bool) {
	v := m.yellow31To45Total
	if v == nil {
		return
	}
	return *v, true
}

// OldYellow31To45Total returns the old "yellow31To45Total" field's value of the TSCards entity.
// If the TSCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCardsMutation) OldYellow31To45Total(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYellow31To45Total is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYellow31To45Total requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYellow31To45Total: %w", err)
	}
	return oldValue.Yellow31To45Total, nil
}

// AddYellow31To45Total adds i to the "yellow31To45Total" field.
func (m *TSCardsMutation) AddYellow31To45Total(i int) {
	if m.addyellow31To45Total != nil {
		*m.addyellow31To45Total += i
	} else {
		m.addyellow31To45Total = &i
	}
}

// AddedYellow31To45Total returns the value that was added to the "yellow31To45Total" field in this mutation.
func (m *TSCardsMutation) AddedYellow31To45Total() (r int, exists bool) {
	v := m.addyellow31To45Total
	if v == nil {
		return
	}
	return *v, true
}

// ClearYellow31To45Total clears the value of the "yellow31To45Total" field.
func (m *TSCardsMutation) ClearYellow31To45Total() {
	m.yellow31To45Total = nil
	m.addyellow31To45Total = nil
	m.clearedFields[tscards.FieldYellow31To45Total] = struct{}{}
}

// Yellow31To45TotalCleared returns if the "yellow31To45Total" field was cleared in this mutation.
func (m *TSCardsMutation) Yellow31To45TotalCleared() bool {
	_, ok := m.clearedFields[tscards.FieldYellow31To45Total]
	return ok
}

// ResetYellow31To45Total resets all changes to the "yellow31To45Total" field.
func (m *TSCardsMutation) ResetYellow31To45Total() {
	m.yellow31To45Total = nil
	m.addyellow31To45Total = nil
	delete(m.clearedFields, tscards.FieldYellow31To45Total)
}

// SetYellow31To45Percentage sets the "yellow31To45Percentage" field.
func (m *TSCardsMutation) SetYellow31To45Percentage(s string) {
	m.yellow31To45Percentage = &s
}

// Yellow31To45Percentage returns the value of the "yellow31To45Percentage" field in the mutation.
func (m *TSCardsMutation) Yellow31To45Percentage() (r string, exists bool) {
	v := m.yellow31To45Percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldYellow31To45Percentage returns the old "yellow31To45Percentage" field's value of the TSCards entity.
// If the TSCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCardsMutation) OldYellow31To45Percentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYellow31To45Percentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYellow31To45Percentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYellow31To45Percentage: %w", err)
	}
	return oldValue.Yellow31To45Percentage, nil
}

// ClearYellow31To45Percentage clears the value of the "yellow31To45Percentage" field.
func (m *TSCardsMutation) ClearYellow31To45Percentage() {
	m.yellow31To45Percentage = nil
	m.clearedFields[tscards.FieldYellow31To45Percentage] = struct{}{}
}

// Yellow31To45PercentageCleared returns if the "yellow31To45Percentage" field was cleared in this mutation.
func (m *TSCardsMutation) Yellow31To45PercentageCleared() bool {
	_, ok := m.clearedFields[tscards.FieldYellow31To45Percentage]
	return ok
}

// ResetYellow31To45Percentage resets all changes to the "yellow31To45Percentage" field.
func (m *TSCardsMutation) ResetYellow31To45Percentage() {
	m.yellow31To45Percentage = nil
	delete(m.clearedFields, tscards.FieldYellow31To45Percentage)
}

// SetYellow46To60Total sets the "yellow46To60Total" field.
func (m *TSCardsMutation) SetYellow46To60Total(i int) {
	m.yellow46To60Total = &i
	m.addyellow46To60Total = nil
}

// Yellow46To60Total returns the value of the "yellow46To60Total" field in the mutation.
func (m *TSCardsMutation) Yellow46To60Total() (r int, exists bool) {
	v := m.yellow46To60Total
	if v == nil {
		return
	}
	return *v, true
}

// OldYellow46To60Total returns the old "yellow46To60Total" field's value of the TSCards entity.
// If the TSCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCardsMutation) OldYellow46To60Total(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYellow46To60Total is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYellow46To60Total requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYellow46To60Total: %w", err)
	}
	return oldValue.Yellow46To60Total, nil
}

// AddYellow46To60Total adds i to the "yellow46To60Total" field.
func (m *TSCardsMutation) AddYellow46To60Total(i int) {
	if m.addyellow46To60Total != nil {
		*m.addyellow46To60Total += i
	} else {
		m.addyellow46To60Total = &i
	}
}

// AddedYellow46To60Total returns the value that was added to the "yellow46To60Total" field in this mutation.
func (m *TSCardsMutation) AddedYellow46To60Total() (r int, exists bool) {
	v := m.addyellow46To60Total
	if v == nil {
		return
	}
	return *v, true
}

// ClearYellow46To60Total clears the value of the "yellow46To60Total" field.
func (m *TSCardsMutation) ClearYellow46To60Total() {
	m.yellow46To60Total = nil
	m.addyellow46To60Total = nil
	m.clearedFields[tscards.FieldYellow46To60Total] = struct{}{}
}

// Yellow46To60TotalCleared returns if the "yellow46To60Total" field was cleared in this mutation.
func (m *TSCardsMutation) Yellow46To60TotalCleared() bool {
	_, ok := m.clearedFields[tscards.FieldYellow46To60Total]
	return ok
}

// ResetYellow46To60Total resets all changes to the "yellow46To60Total" field.
func (m *TSCardsMutation) ResetYellow46To60Total() {
	m.yellow46To60Total = nil
	m.addyellow46To60Total = nil
	delete(m.clearedFields, tscards.FieldYellow46To60Total)
}

// SetYellow46To60Percentage sets the "yellow46To60Percentage" field.
func (m *TSCardsMutation) SetYellow46To60Percentage(s string) {
	m.yellow46To60Percentage = &s
}

// Yellow46To60Percentage returns the value of the "yellow46To60Percentage" field in the mutation.
func (m *TSCardsMutation) Yellow46To60Percentage() (r string, exists bool) {
	v := m.yellow46To60Percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldYellow46To60Percentage returns the old "yellow46To60Percentage" field's value of the TSCards entity.
// If the TSCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCardsMutation) OldYellow46To60Percentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYellow46To60Percentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYellow46To60Percentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYellow46To60Percentage: %w", err)
	}
	return oldValue.Yellow46To60Percentage, nil
}

// ClearYellow46To60Percentage clears the value of the "yellow46To60Percentage" field.
func (m *TSCardsMutation) ClearYellow46To60Percentage() {
	m.yellow46To60Percentage = nil
	m.clearedFields[tscards.FieldYellow46To60Percentage] = struct{}{}
}

// Yellow46To60PercentageCleared returns if the "yellow46To60Percentage" field was cleared in this mutation.
func (m *TSCardsMutation) Yellow46To60PercentageCleared() bool {
	_, ok := m.clearedFields[tscards.FieldYellow46To60Percentage]
	return ok
}

// ResetYellow46To60Percentage resets all changes to the "yellow46To60Percentage" field.
func (m *TSCardsMutation) ResetYellow46To60Percentage() {
	m.yellow46To60Percentage = nil
	delete(m.clearedFields, tscards.FieldYellow46To60Percentage)
}

// SetYellow61To75Total sets the "yellow61To75Total" field.
func (m *TSCardsMutation) SetYellow61To75Total(i int) {
	m.yellow61To75Total = &i
	m.addyellow61To75Total = nil
}

// Yellow61To75Total returns the value of the "yellow61To75Total" field in the mutation.
func (m *TSCardsMutation) Yellow61To75Total() (r int, exists bool) {
	v := m.yellow61To75Total
	if v == nil {
		return
	}
	return *v, true
}

// OldYellow61To75Total returns the old "yellow61To75Total" field's value of the TSCards entity.
// If the TSCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCardsMutation) OldYellow61To75Total(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYellow61To75Total is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYellow61To75Total requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYellow61To75Total: %w", err)
	}
	return oldValue.Yellow61To75Total, nil
}

// AddYellow61To75Total adds i to the "yellow61To75Total" field.
func (m *TSCardsMutation) AddYellow61To75Total(i int) {
	if m.addyellow61To75Total != nil {
		*m.addyellow61To75Total += i
	} else {
		m.addyellow61To75Total = &i
	}
}

// AddedYellow61To75Total returns the value that was added to the "yellow61To75Total" field in this mutation.
func (m *TSCardsMutation) AddedYellow61To75Total() (r int, exists bool) {
	v := m.addyellow61To75Total
	if v == nil {
		return
	}
	return *v, true
}

// ClearYellow61To75Total clears the value of the "yellow61To75Total" field.
func (m *TSCardsMutation) ClearYellow61To75Total() {
	m.yellow61To75Total = nil
	m.addyellow61To75Total = nil
	m.clearedFields[tscards.FieldYellow61To75Total] = struct{}{}
}

// Yellow61To75TotalCleared returns if the "yellow61To75Total" field was cleared in this mutation.
func (m *TSCardsMutation) Yellow61To75TotalCleared() bool {
	_, ok := m.clearedFields[tscards.FieldYellow61To75Total]
	return ok
}

// ResetYellow61To75Total resets all changes to the "yellow61To75Total" field.
func (m *TSCardsMutation) ResetYellow61To75Total() {
	m.yellow61To75Total = nil
	m.addyellow61To75Total = nil
	delete(m.clearedFields, tscards.FieldYellow61To75Total)
}

// SetYellow61To75Percentage sets the "yellow61To75Percentage" field.
func (m *TSCardsMutation) SetYellow61To75Percentage(s string) {
	m.yellow61To75Percentage = &s
}

// Yellow61To75Percentage returns the value of the "yellow61To75Percentage" field in the mutation.
func (m *TSCardsMutation) Yellow61To75Percentage() (r string, exists bool) {
	v := m.yellow61To75Percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldYellow61To75Percentage returns the old "yellow61To75Percentage" field's value of the TSCards entity.
// If the TSCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCardsMutation) OldYellow61To75Percentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYellow61To75Percentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYellow61To75Percentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYellow61To75Percentage: %w", err)
	}
	return oldValue.Yellow61To75Percentage, nil
}

// ClearYellow61To75Percentage clears the value of the "yellow61To75Percentage" field.
func (m *TSCardsMutation) ClearYellow61To75Percentage() {
	m.yellow61To75Percentage = nil
	m.clearedFields[tscards.FieldYellow61To75Percentage] = struct{}{}
}

// Yellow61To75PercentageCleared returns if the "yellow61To75Percentage" field was cleared in this mutation.
func (m *TSCardsMutation) Yellow61To75PercentageCleared() bool {
	_, ok := m.clearedFields[tscards.FieldYellow61To75Percentage]
	return ok
}

// ResetYellow61To75Percentage resets all changes to the "yellow61To75Percentage" field.
func (m *TSCardsMutation) ResetYellow61To75Percentage() {
	m.yellow61To75Percentage = nil
	delete(m.clearedFields, tscards.FieldYellow61To75Percentage)
}

// SetYellow76To90Total sets the "yellow76To90Total" field.
func (m *TSCardsMutation) SetYellow76To90Total(i int) {
	m.yellow76To90Total = &i
	m.addyellow76To90Total = nil
}

// Yellow76To90Total returns the value of the "yellow76To90Total" field in the mutation.
func (m *TSCardsMutation) Yellow76To90Total() (r int, exists bool) {
	v := m.yellow76To90Total
	if v == nil {
		return
	}
	return *v, true
}

// OldYellow76To90Total returns the old "yellow76To90Total" field's value of the TSCards entity.
// If the TSCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCardsMutation) OldYellow76To90Total(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYellow76To90Total is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYellow76To90Total requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYellow76To90Total: %w", err)
	}
	return oldValue.Yellow76To90Total, nil
}

// AddYellow76To90Total adds i to the "yellow76To90Total" field.
func (m *TSCardsMutation) AddYellow76To90Total(i int) {
	if m.addyellow76To90Total != nil {
		*m.addyellow76To90Total += i
	} else {
		m.addyellow76To90Total = &i
	}
}

// AddedYellow76To90Total returns the value that was added to the "yellow76To90Total" field in this mutation.
func (m *TSCardsMutation) AddedYellow76To90Total() (r int, exists bool) {
	v := m.addyellow76To90Total
	if v == nil {
		return
	}
	return *v, true
}

// ClearYellow76To90Total clears the value of the "yellow76To90Total" field.
func (m *TSCardsMutation) ClearYellow76To90Total() {
	m.yellow76To90Total = nil
	m.addyellow76To90Total = nil
	m.clearedFields[tscards.FieldYellow76To90Total] = struct{}{}
}

// Yellow76To90TotalCleared returns if the "yellow76To90Total" field was cleared in this mutation.
func (m *TSCardsMutation) Yellow76To90TotalCleared() bool {
	_, ok := m.clearedFields[tscards.FieldYellow76To90Total]
	return ok
}

// ResetYellow76To90Total resets all changes to the "yellow76To90Total" field.
func (m *TSCardsMutation) ResetYellow76To90Total() {
	m.yellow76To90Total = nil
	m.addyellow76To90Total = nil
	delete(m.clearedFields, tscards.FieldYellow76To90Total)
}

// SetYellow76To90Percentage sets the "yellow76To90Percentage" field.
func (m *TSCardsMutation) SetYellow76To90Percentage(s string) {
	m.yellow76To90Percentage = &s
}

// Yellow76To90Percentage returns the value of the "yellow76To90Percentage" field in the mutation.
func (m *TSCardsMutation) Yellow76To90Percentage() (r string, exists bool) {
	v := m.yellow76To90Percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldYellow76To90Percentage returns the old "yellow76To90Percentage" field's value of the TSCards entity.
// If the TSCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCardsMutation) OldYellow76To90Percentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYellow76To90Percentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYellow76To90Percentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYellow76To90Percentage: %w", err)
	}
	return oldValue.Yellow76To90Percentage, nil
}

// ClearYellow76To90Percentage clears the value of the "yellow76To90Percentage" field.
func (m *TSCardsMutation) ClearYellow76To90Percentage() {
	m.yellow76To90Percentage = nil
	m.clearedFields[tscards.FieldYellow76To90Percentage] = struct{}{}
}

// Yellow76To90PercentageCleared returns if the "yellow76To90Percentage" field was cleared in this mutation.
func (m *TSCardsMutation) Yellow76To90PercentageCleared() bool {
	_, ok := m.clearedFields[tscards.FieldYellow76To90Percentage]
	return ok
}

// ResetYellow76To90Percentage resets all changes to the "yellow76To90Percentage" field.
func (m *TSCardsMutation) ResetYellow76To90Percentage() {
	m.yellow76To90Percentage = nil
	delete(m.clearedFields, tscards.FieldYellow76To90Percentage)
}

// SetYellow91to105Total sets the "yellow91to105Total" field.
func (m *TSCardsMutation) SetYellow91to105Total(i int) {
	m.yellow91to105Total = &i
	m.addyellow91to105Total = nil
}

// Yellow91to105Total returns the value of the "yellow91to105Total" field in the mutation.
func (m *TSCardsMutation) Yellow91to105Total() (r int, exists bool) {
	v := m.yellow91to105Total
	if v == nil {
		return
	}
	return *v, true
}

// OldYellow91to105Total returns the old "yellow91to105Total" field's value of the TSCards entity.
// If the TSCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCardsMutation) OldYellow91to105Total(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYellow91to105Total is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYellow91to105Total requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYellow91to105Total: %w", err)
	}
	return oldValue.Yellow91to105Total, nil
}

// AddYellow91to105Total adds i to the "yellow91to105Total" field.
func (m *TSCardsMutation) AddYellow91to105Total(i int) {
	if m.addyellow91to105Total != nil {
		*m.addyellow91to105Total += i
	} else {
		m.addyellow91to105Total = &i
	}
}

// AddedYellow91to105Total returns the value that was added to the "yellow91to105Total" field in this mutation.
func (m *TSCardsMutation) AddedYellow91to105Total() (r int, exists bool) {
	v := m.addyellow91to105Total
	if v == nil {
		return
	}
	return *v, true
}

// ClearYellow91to105Total clears the value of the "yellow91to105Total" field.
func (m *TSCardsMutation) ClearYellow91to105Total() {
	m.yellow91to105Total = nil
	m.addyellow91to105Total = nil
	m.clearedFields[tscards.FieldYellow91to105Total] = struct{}{}
}

// Yellow91to105TotalCleared returns if the "yellow91to105Total" field was cleared in this mutation.
func (m *TSCardsMutation) Yellow91to105TotalCleared() bool {
	_, ok := m.clearedFields[tscards.FieldYellow91to105Total]
	return ok
}

// ResetYellow91to105Total resets all changes to the "yellow91to105Total" field.
func (m *TSCardsMutation) ResetYellow91to105Total() {
	m.yellow91to105Total = nil
	m.addyellow91to105Total = nil
	delete(m.clearedFields, tscards.FieldYellow91to105Total)
}

// SetYellow91to105Percentage sets the "yellow91to105Percentage" field.
func (m *TSCardsMutation) SetYellow91to105Percentage(s string) {
	m.yellow91to105Percentage = &s
}

// Yellow91to105Percentage returns the value of the "yellow91to105Percentage" field in the mutation.
func (m *TSCardsMutation) Yellow91to105Percentage() (r string, exists bool) {
	v := m.yellow91to105Percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldYellow91to105Percentage returns the old "yellow91to105Percentage" field's value of the TSCards entity.
// If the TSCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCardsMutation) OldYellow91to105Percentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYellow91to105Percentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYellow91to105Percentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYellow91to105Percentage: %w", err)
	}
	return oldValue.Yellow91to105Percentage, nil
}

// ClearYellow91to105Percentage clears the value of the "yellow91to105Percentage" field.
func (m *TSCardsMutation) ClearYellow91to105Percentage() {
	m.yellow91to105Percentage = nil
	m.clearedFields[tscards.FieldYellow91to105Percentage] = struct{}{}
}

// Yellow91to105PercentageCleared returns if the "yellow91to105Percentage" field was cleared in this mutation.
func (m *TSCardsMutation) Yellow91to105PercentageCleared() bool {
	_, ok := m.clearedFields[tscards.FieldYellow91to105Percentage]
	return ok
}

// ResetYellow91to105Percentage resets all changes to the "yellow91to105Percentage" field.
func (m *TSCardsMutation) ResetYellow91to105Percentage() {
	m.yellow91to105Percentage = nil
	delete(m.clearedFields, tscards.FieldYellow91to105Percentage)
}

// SetYellow106To120Total sets the "yellow106To120Total" field.
func (m *TSCardsMutation) SetYellow106To120Total(i int) {
	m.yellow106To120Total = &i
	m.addyellow106To120Total = nil
}

// Yellow106To120Total returns the value of the "yellow106To120Total" field in the mutation.
func (m *TSCardsMutation) Yellow106To120Total() (r int, exists bool) {
	v := m.yellow106To120Total
	if v == nil {
		return
	}
	return *v, true
}

// OldYellow106To120Total returns the old "yellow106To120Total" field's value of the TSCards entity.
// If the TSCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCardsMutation) OldYellow106To120Total(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYellow106To120Total is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYellow106To120Total requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYellow106To120Total: %w", err)
	}
	return oldValue.Yellow106To120Total, nil
}

// AddYellow106To120Total adds i to the "yellow106To120Total" field.
func (m *TSCardsMutation) AddYellow106To120Total(i int) {
	if m.addyellow106To120Total != nil {
		*m.addyellow106To120Total += i
	} else {
		m.addyellow106To120Total = &i
	}
}

// AddedYellow106To120Total returns the value that was added to the "yellow106To120Total" field in this mutation.
func (m *TSCardsMutation) AddedYellow106To120Total() (r int, exists bool) {
	v := m.addyellow106To120Total
	if v == nil {
		return
	}
	return *v, true
}

// ClearYellow106To120Total clears the value of the "yellow106To120Total" field.
func (m *TSCardsMutation) ClearYellow106To120Total() {
	m.yellow106To120Total = nil
	m.addyellow106To120Total = nil
	m.clearedFields[tscards.FieldYellow106To120Total] = struct{}{}
}

// Yellow106To120TotalCleared returns if the "yellow106To120Total" field was cleared in this mutation.
func (m *TSCardsMutation) Yellow106To120TotalCleared() bool {
	_, ok := m.clearedFields[tscards.FieldYellow106To120Total]
	return ok
}

// ResetYellow106To120Total resets all changes to the "yellow106To120Total" field.
func (m *TSCardsMutation) ResetYellow106To120Total() {
	m.yellow106To120Total = nil
	m.addyellow106To120Total = nil
	delete(m.clearedFields, tscards.FieldYellow106To120Total)
}

// SetYellow106To120Percentage sets the "yellow106To120Percentage" field.
func (m *TSCardsMutation) SetYellow106To120Percentage(s string) {
	m.yellow106To120Percentage = &s
}

// Yellow106To120Percentage returns the value of the "yellow106To120Percentage" field in the mutation.
func (m *TSCardsMutation) Yellow106To120Percentage() (r string, exists bool) {
	v := m.yellow106To120Percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldYellow106To120Percentage returns the old "yellow106To120Percentage" field's value of the TSCards entity.
// If the TSCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCardsMutation) OldYellow106To120Percentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYellow106To120Percentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYellow106To120Percentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYellow106To120Percentage: %w", err)
	}
	return oldValue.Yellow106To120Percentage, nil
}

// ClearYellow106To120Percentage clears the value of the "yellow106To120Percentage" field.
func (m *TSCardsMutation) ClearYellow106To120Percentage() {
	m.yellow106To120Percentage = nil
	m.clearedFields[tscards.FieldYellow106To120Percentage] = struct{}{}
}

// Yellow106To120PercentageCleared returns if the "yellow106To120Percentage" field was cleared in this mutation.
func (m *TSCardsMutation) Yellow106To120PercentageCleared() bool {
	_, ok := m.clearedFields[tscards.FieldYellow106To120Percentage]
	return ok
}

// ResetYellow106To120Percentage resets all changes to the "yellow106To120Percentage" field.
func (m *TSCardsMutation) ResetYellow106To120Percentage() {
	m.yellow106To120Percentage = nil
	delete(m.clearedFields, tscards.FieldYellow106To120Percentage)
}

// SetRed0To15Total sets the "red0To15Total" field.
func (m *TSCardsMutation) SetRed0To15Total(i int) {
	m.red0To15Total = &i
	m.addred0To15Total = nil
}

// Red0To15Total returns the value of the "red0To15Total" field in the mutation.
func (m *TSCardsMutation) Red0To15Total() (r int, exists bool) {
	v := m.red0To15Total
	if v == nil {
		return
	}
	return *v, true
}

// OldRed0To15Total returns the old "red0To15Total" field's value of the TSCards entity.
// If the TSCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCardsMutation) OldRed0To15Total(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRed0To15Total is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRed0To15Total requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRed0To15Total: %w", err)
	}
	return oldValue.Red0To15Total, nil
}

// AddRed0To15Total adds i to the "red0To15Total" field.
func (m *TSCardsMutation) AddRed0To15Total(i int) {
	if m.addred0To15Total != nil {
		*m.addred0To15Total += i
	} else {
		m.addred0To15Total = &i
	}
}

// AddedRed0To15Total returns the value that was added to the "red0To15Total" field in this mutation.
func (m *TSCardsMutation) AddedRed0To15Total() (r int, exists bool) {
	v := m.addred0To15Total
	if v == nil {
		return
	}
	return *v, true
}

// ClearRed0To15Total clears the value of the "red0To15Total" field.
func (m *TSCardsMutation) ClearRed0To15Total() {
	m.red0To15Total = nil
	m.addred0To15Total = nil
	m.clearedFields[tscards.FieldRed0To15Total] = struct{}{}
}

// Red0To15TotalCleared returns if the "red0To15Total" field was cleared in this mutation.
func (m *TSCardsMutation) Red0To15TotalCleared() bool {
	_, ok := m.clearedFields[tscards.FieldRed0To15Total]
	return ok
}

// ResetRed0To15Total resets all changes to the "red0To15Total" field.
func (m *TSCardsMutation) ResetRed0To15Total() {
	m.red0To15Total = nil
	m.addred0To15Total = nil
	delete(m.clearedFields, tscards.FieldRed0To15Total)
}

// SetRed0To15Percentage sets the "red0To15Percentage" field.
func (m *TSCardsMutation) SetRed0To15Percentage(s string) {
	m.red0To15Percentage = &s
}

// Red0To15Percentage returns the value of the "red0To15Percentage" field in the mutation.
func (m *TSCardsMutation) Red0To15Percentage() (r string, exists bool) {
	v := m.red0To15Percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldRed0To15Percentage returns the old "red0To15Percentage" field's value of the TSCards entity.
// If the TSCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCardsMutation) OldRed0To15Percentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRed0To15Percentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRed0To15Percentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRed0To15Percentage: %w", err)
	}
	return oldValue.Red0To15Percentage, nil
}

// ClearRed0To15Percentage clears the value of the "red0To15Percentage" field.
func (m *TSCardsMutation) ClearRed0To15Percentage() {
	m.red0To15Percentage = nil
	m.clearedFields[tscards.FieldRed0To15Percentage] = struct{}{}
}

// Red0To15PercentageCleared returns if the "red0To15Percentage" field was cleared in this mutation.
func (m *TSCardsMutation) Red0To15PercentageCleared() bool {
	_, ok := m.clearedFields[tscards.FieldRed0To15Percentage]
	return ok
}

// ResetRed0To15Percentage resets all changes to the "red0To15Percentage" field.
func (m *TSCardsMutation) ResetRed0To15Percentage() {
	m.red0To15Percentage = nil
	delete(m.clearedFields, tscards.FieldRed0To15Percentage)
}

// SetRed16To30Total sets the "red16To30Total" field.
func (m *TSCardsMutation) SetRed16To30Total(i int) {
	m.red16To30Total = &i
	m.addred16To30Total = nil
}

// Red16To30Total returns the value of the "red16To30Total" field in the mutation.
func (m *TSCardsMutation) Red16To30Total() (r int, exists bool) {
	v := m.red16To30Total
	if v == nil {
		return
	}
	return *v, true
}

// OldRed16To30Total returns the old "red16To30Total" field's value of the TSCards entity.
// If the TSCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCardsMutation) OldRed16To30Total(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRed16To30Total is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRed16To30Total requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRed16To30Total: %w", err)
	}
	return oldValue.Red16To30Total, nil
}

// AddRed16To30Total adds i to the "red16To30Total" field.
func (m *TSCardsMutation) AddRed16To30Total(i int) {
	if m.addred16To30Total != nil {
		*m.addred16To30Total += i
	} else {
		m.addred16To30Total = &i
	}
}

// AddedRed16To30Total returns the value that was added to the "red16To30Total" field in this mutation.
func (m *TSCardsMutation) AddedRed16To30Total() (r int, exists bool) {
	v := m.addred16To30Total
	if v == nil {
		return
	}
	return *v, true
}

// ClearRed16To30Total clears the value of the "red16To30Total" field.
func (m *TSCardsMutation) ClearRed16To30Total() {
	m.red16To30Total = nil
	m.addred16To30Total = nil
	m.clearedFields[tscards.FieldRed16To30Total] = struct{}{}
}

// Red16To30TotalCleared returns if the "red16To30Total" field was cleared in this mutation.
func (m *TSCardsMutation) Red16To30TotalCleared() bool {
	_, ok := m.clearedFields[tscards.FieldRed16To30Total]
	return ok
}

// ResetRed16To30Total resets all changes to the "red16To30Total" field.
func (m *TSCardsMutation) ResetRed16To30Total() {
	m.red16To30Total = nil
	m.addred16To30Total = nil
	delete(m.clearedFields, tscards.FieldRed16To30Total)
}

// SetRed16To30Percentage sets the "red16To30Percentage" field.
func (m *TSCardsMutation) SetRed16To30Percentage(s string) {
	m.red16To30Percentage = &s
}

// Red16To30Percentage returns the value of the "red16To30Percentage" field in the mutation.
func (m *TSCardsMutation) Red16To30Percentage() (r string, exists bool) {
	v := m.red16To30Percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldRed16To30Percentage returns the old "red16To30Percentage" field's value of the TSCards entity.
// If the TSCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCardsMutation) OldRed16To30Percentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRed16To30Percentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRed16To30Percentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRed16To30Percentage: %w", err)
	}
	return oldValue.Red16To30Percentage, nil
}

// ClearRed16To30Percentage clears the value of the "red16To30Percentage" field.
func (m *TSCardsMutation) ClearRed16To30Percentage() {
	m.red16To30Percentage = nil
	m.clearedFields[tscards.FieldRed16To30Percentage] = struct{}{}
}

// Red16To30PercentageCleared returns if the "red16To30Percentage" field was cleared in this mutation.
func (m *TSCardsMutation) Red16To30PercentageCleared() bool {
	_, ok := m.clearedFields[tscards.FieldRed16To30Percentage]
	return ok
}

// ResetRed16To30Percentage resets all changes to the "red16To30Percentage" field.
func (m *TSCardsMutation) ResetRed16To30Percentage() {
	m.red16To30Percentage = nil
	delete(m.clearedFields, tscards.FieldRed16To30Percentage)
}

// SetRed31To45Total sets the "red31To45Total" field.
func (m *TSCardsMutation) SetRed31To45Total(i int) {
	m.red31To45Total = &i
	m.addred31To45Total = nil
}

// Red31To45Total returns the value of the "red31To45Total" field in the mutation.
func (m *TSCardsMutation) Red31To45Total() (r int, exists bool) {
	v := m.red31To45Total
	if v == nil {
		return
	}
	return *v, true
}

// OldRed31To45Total returns the old "red31To45Total" field's value of the TSCards entity.
// If the TSCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCardsMutation) OldRed31To45Total(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRed31To45Total is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRed31To45Total requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRed31To45Total: %w", err)
	}
	return oldValue.Red31To45Total, nil
}

// AddRed31To45Total adds i to the "red31To45Total" field.
func (m *TSCardsMutation) AddRed31To45Total(i int) {
	if m.addred31To45Total != nil {
		*m.addred31To45Total += i
	} else {
		m.addred31To45Total = &i
	}
}

// AddedRed31To45Total returns the value that was added to the "red31To45Total" field in this mutation.
func (m *TSCardsMutation) AddedRed31To45Total() (r int, exists bool) {
	v := m.addred31To45Total
	if v == nil {
		return
	}
	return *v, true
}

// ClearRed31To45Total clears the value of the "red31To45Total" field.
func (m *TSCardsMutation) ClearRed31To45Total() {
	m.red31To45Total = nil
	m.addred31To45Total = nil
	m.clearedFields[tscards.FieldRed31To45Total] = struct{}{}
}

// Red31To45TotalCleared returns if the "red31To45Total" field was cleared in this mutation.
func (m *TSCardsMutation) Red31To45TotalCleared() bool {
	_, ok := m.clearedFields[tscards.FieldRed31To45Total]
	return ok
}

// ResetRed31To45Total resets all changes to the "red31To45Total" field.
func (m *TSCardsMutation) ResetRed31To45Total() {
	m.red31To45Total = nil
	m.addred31To45Total = nil
	delete(m.clearedFields, tscards.FieldRed31To45Total)
}

// SetRed31To45Percentage sets the "red31To45Percentage" field.
func (m *TSCardsMutation) SetRed31To45Percentage(s string) {
	m.red31To45Percentage = &s
}

// Red31To45Percentage returns the value of the "red31To45Percentage" field in the mutation.
func (m *TSCardsMutation) Red31To45Percentage() (r string, exists bool) {
	v := m.red31To45Percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldRed31To45Percentage returns the old "red31To45Percentage" field's value of the TSCards entity.
// If the TSCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCardsMutation) OldRed31To45Percentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRed31To45Percentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRed31To45Percentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRed31To45Percentage: %w", err)
	}
	return oldValue.Red31To45Percentage, nil
}

// ClearRed31To45Percentage clears the value of the "red31To45Percentage" field.
func (m *TSCardsMutation) ClearRed31To45Percentage() {
	m.red31To45Percentage = nil
	m.clearedFields[tscards.FieldRed31To45Percentage] = struct{}{}
}

// Red31To45PercentageCleared returns if the "red31To45Percentage" field was cleared in this mutation.
func (m *TSCardsMutation) Red31To45PercentageCleared() bool {
	_, ok := m.clearedFields[tscards.FieldRed31To45Percentage]
	return ok
}

// ResetRed31To45Percentage resets all changes to the "red31To45Percentage" field.
func (m *TSCardsMutation) ResetRed31To45Percentage() {
	m.red31To45Percentage = nil
	delete(m.clearedFields, tscards.FieldRed31To45Percentage)
}

// SetRed46To60Total sets the "red46To60Total" field.
func (m *TSCardsMutation) SetRed46To60Total(i int) {
	m.red46To60Total = &i
	m.addred46To60Total = nil
}

// Red46To60Total returns the value of the "red46To60Total" field in the mutation.
func (m *TSCardsMutation) Red46To60Total() (r int, exists bool) {
	v := m.red46To60Total
	if v == nil {
		return
	}
	return *v, true
}

// OldRed46To60Total returns the old "red46To60Total" field's value of the TSCards entity.
// If the TSCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCardsMutation) OldRed46To60Total(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRed46To60Total is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRed46To60Total requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRed46To60Total: %w", err)
	}
	return oldValue.Red46To60Total, nil
}

// AddRed46To60Total adds i to the "red46To60Total" field.
func (m *TSCardsMutation) AddRed46To60Total(i int) {
	if m.addred46To60Total != nil {
		*m.addred46To60Total += i
	} else {
		m.addred46To60Total = &i
	}
}

// AddedRed46To60Total returns the value that was added to the "red46To60Total" field in this mutation.
func (m *TSCardsMutation) AddedRed46To60Total() (r int, exists bool) {
	v := m.addred46To60Total
	if v == nil {
		return
	}
	return *v, true
}

// ClearRed46To60Total clears the value of the "red46To60Total" field.
func (m *TSCardsMutation) ClearRed46To60Total() {
	m.red46To60Total = nil
	m.addred46To60Total = nil
	m.clearedFields[tscards.FieldRed46To60Total] = struct{}{}
}

// Red46To60TotalCleared returns if the "red46To60Total" field was cleared in this mutation.
func (m *TSCardsMutation) Red46To60TotalCleared() bool {
	_, ok := m.clearedFields[tscards.FieldRed46To60Total]
	return ok
}

// ResetRed46To60Total resets all changes to the "red46To60Total" field.
func (m *TSCardsMutation) ResetRed46To60Total() {
	m.red46To60Total = nil
	m.addred46To60Total = nil
	delete(m.clearedFields, tscards.FieldRed46To60Total)
}

// SetRed46To60Percentage sets the "red46To60Percentage" field.
func (m *TSCardsMutation) SetRed46To60Percentage(s string) {
	m.red46To60Percentage = &s
}

// Red46To60Percentage returns the value of the "red46To60Percentage" field in the mutation.
func (m *TSCardsMutation) Red46To60Percentage() (r string, exists bool) {
	v := m.red46To60Percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldRed46To60Percentage returns the old "red46To60Percentage" field's value of the TSCards entity.
// If the TSCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCardsMutation) OldRed46To60Percentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRed46To60Percentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRed46To60Percentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRed46To60Percentage: %w", err)
	}
	return oldValue.Red46To60Percentage, nil
}

// ClearRed46To60Percentage clears the value of the "red46To60Percentage" field.
func (m *TSCardsMutation) ClearRed46To60Percentage() {
	m.red46To60Percentage = nil
	m.clearedFields[tscards.FieldRed46To60Percentage] = struct{}{}
}

// Red46To60PercentageCleared returns if the "red46To60Percentage" field was cleared in this mutation.
func (m *TSCardsMutation) Red46To60PercentageCleared() bool {
	_, ok := m.clearedFields[tscards.FieldRed46To60Percentage]
	return ok
}

// ResetRed46To60Percentage resets all changes to the "red46To60Percentage" field.
func (m *TSCardsMutation) ResetRed46To60Percentage() {
	m.red46To60Percentage = nil
	delete(m.clearedFields, tscards.FieldRed46To60Percentage)
}

// SetRed61To75Total sets the "red61To75Total" field.
func (m *TSCardsMutation) SetRed61To75Total(i int) {
	m.red61To75Total = &i
	m.addred61To75Total = nil
}

// Red61To75Total returns the value of the "red61To75Total" field in the mutation.
func (m *TSCardsMutation) Red61To75Total() (r int, exists bool) {
	v := m.red61To75Total
	if v == nil {
		return
	}
	return *v, true
}

// OldRed61To75Total returns the old "red61To75Total" field's value of the TSCards entity.
// If the TSCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCardsMutation) OldRed61To75Total(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRed61To75Total is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRed61To75Total requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRed61To75Total: %w", err)
	}
	return oldValue.Red61To75Total, nil
}

// AddRed61To75Total adds i to the "red61To75Total" field.
func (m *TSCardsMutation) AddRed61To75Total(i int) {
	if m.addred61To75Total != nil {
		*m.addred61To75Total += i
	} else {
		m.addred61To75Total = &i
	}
}

// AddedRed61To75Total returns the value that was added to the "red61To75Total" field in this mutation.
func (m *TSCardsMutation) AddedRed61To75Total() (r int, exists bool) {
	v := m.addred61To75Total
	if v == nil {
		return
	}
	return *v, true
}

// ClearRed61To75Total clears the value of the "red61To75Total" field.
func (m *TSCardsMutation) ClearRed61To75Total() {
	m.red61To75Total = nil
	m.addred61To75Total = nil
	m.clearedFields[tscards.FieldRed61To75Total] = struct{}{}
}

// Red61To75TotalCleared returns if the "red61To75Total" field was cleared in this mutation.
func (m *TSCardsMutation) Red61To75TotalCleared() bool {
	_, ok := m.clearedFields[tscards.FieldRed61To75Total]
	return ok
}

// ResetRed61To75Total resets all changes to the "red61To75Total" field.
func (m *TSCardsMutation) ResetRed61To75Total() {
	m.red61To75Total = nil
	m.addred61To75Total = nil
	delete(m.clearedFields, tscards.FieldRed61To75Total)
}

// SetRed61To75Percentage sets the "red61To75Percentage" field.
func (m *TSCardsMutation) SetRed61To75Percentage(s string) {
	m.red61To75Percentage = &s
}

// Red61To75Percentage returns the value of the "red61To75Percentage" field in the mutation.
func (m *TSCardsMutation) Red61To75Percentage() (r string, exists bool) {
	v := m.red61To75Percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldRed61To75Percentage returns the old "red61To75Percentage" field's value of the TSCards entity.
// If the TSCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCardsMutation) OldRed61To75Percentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRed61To75Percentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRed61To75Percentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRed61To75Percentage: %w", err)
	}
	return oldValue.Red61To75Percentage, nil
}

// ClearRed61To75Percentage clears the value of the "red61To75Percentage" field.
func (m *TSCardsMutation) ClearRed61To75Percentage() {
	m.red61To75Percentage = nil
	m.clearedFields[tscards.FieldRed61To75Percentage] = struct{}{}
}

// Red61To75PercentageCleared returns if the "red61To75Percentage" field was cleared in this mutation.
func (m *TSCardsMutation) Red61To75PercentageCleared() bool {
	_, ok := m.clearedFields[tscards.FieldRed61To75Percentage]
	return ok
}

// ResetRed61To75Percentage resets all changes to the "red61To75Percentage" field.
func (m *TSCardsMutation) ResetRed61To75Percentage() {
	m.red61To75Percentage = nil
	delete(m.clearedFields, tscards.FieldRed61To75Percentage)
}

// SetRed76To90Total sets the "red76To90Total" field.
func (m *TSCardsMutation) SetRed76To90Total(i int) {
	m.red76To90Total = &i
	m.addred76To90Total = nil
}

// Red76To90Total returns the value of the "red76To90Total" field in the mutation.
func (m *TSCardsMutation) Red76To90Total() (r int, exists bool) {
	v := m.red76To90Total
	if v == nil {
		return
	}
	return *v, true
}

// OldRed76To90Total returns the old "red76To90Total" field's value of the TSCards entity.
// If the TSCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCardsMutation) OldRed76To90Total(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRed76To90Total is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRed76To90Total requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRed76To90Total: %w", err)
	}
	return oldValue.Red76To90Total, nil
}

// AddRed76To90Total adds i to the "red76To90Total" field.
func (m *TSCardsMutation) AddRed76To90Total(i int) {
	if m.addred76To90Total != nil {
		*m.addred76To90Total += i
	} else {
		m.addred76To90Total = &i
	}
}

// AddedRed76To90Total returns the value that was added to the "red76To90Total" field in this mutation.
func (m *TSCardsMutation) AddedRed76To90Total() (r int, exists bool) {
	v := m.addred76To90Total
	if v == nil {
		return
	}
	return *v, true
}

// ClearRed76To90Total clears the value of the "red76To90Total" field.
func (m *TSCardsMutation) ClearRed76To90Total() {
	m.red76To90Total = nil
	m.addred76To90Total = nil
	m.clearedFields[tscards.FieldRed76To90Total] = struct{}{}
}

// Red76To90TotalCleared returns if the "red76To90Total" field was cleared in this mutation.
func (m *TSCardsMutation) Red76To90TotalCleared() bool {
	_, ok := m.clearedFields[tscards.FieldRed76To90Total]
	return ok
}

// ResetRed76To90Total resets all changes to the "red76To90Total" field.
func (m *TSCardsMutation) ResetRed76To90Total() {
	m.red76To90Total = nil
	m.addred76To90Total = nil
	delete(m.clearedFields, tscards.FieldRed76To90Total)
}

// SetRed76To90Percentage sets the "red76To90Percentage" field.
func (m *TSCardsMutation) SetRed76To90Percentage(s string) {
	m.red76To90Percentage = &s
}

// Red76To90Percentage returns the value of the "red76To90Percentage" field in the mutation.
func (m *TSCardsMutation) Red76To90Percentage() (r string, exists bool) {
	v := m.red76To90Percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldRed76To90Percentage returns the old "red76To90Percentage" field's value of the TSCards entity.
// If the TSCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCardsMutation) OldRed76To90Percentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRed76To90Percentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRed76To90Percentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRed76To90Percentage: %w", err)
	}
	return oldValue.Red76To90Percentage, nil
}

// ClearRed76To90Percentage clears the value of the "red76To90Percentage" field.
func (m *TSCardsMutation) ClearRed76To90Percentage() {
	m.red76To90Percentage = nil
	m.clearedFields[tscards.FieldRed76To90Percentage] = struct{}{}
}

// Red76To90PercentageCleared returns if the "red76To90Percentage" field was cleared in this mutation.
func (m *TSCardsMutation) Red76To90PercentageCleared() bool {
	_, ok := m.clearedFields[tscards.FieldRed76To90Percentage]
	return ok
}

// ResetRed76To90Percentage resets all changes to the "red76To90Percentage" field.
func (m *TSCardsMutation) ResetRed76To90Percentage() {
	m.red76To90Percentage = nil
	delete(m.clearedFields, tscards.FieldRed76To90Percentage)
}

// SetRed91to105Total sets the "red91to105Total" field.
func (m *TSCardsMutation) SetRed91to105Total(i int) {
	m.red91to105Total = &i
	m.addred91to105Total = nil
}

// Red91to105Total returns the value of the "red91to105Total" field in the mutation.
func (m *TSCardsMutation) Red91to105Total() (r int, exists bool) {
	v := m.red91to105Total
	if v == nil {
		return
	}
	return *v, true
}

// OldRed91to105Total returns the old "red91to105Total" field's value of the TSCards entity.
// If the TSCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCardsMutation) OldRed91to105Total(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRed91to105Total is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRed91to105Total requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRed91to105Total: %w", err)
	}
	return oldValue.Red91to105Total, nil
}

// AddRed91to105Total adds i to the "red91to105Total" field.
func (m *TSCardsMutation) AddRed91to105Total(i int) {
	if m.addred91to105Total != nil {
		*m.addred91to105Total += i
	} else {
		m.addred91to105Total = &i
	}
}

// AddedRed91to105Total returns the value that was added to the "red91to105Total" field in this mutation.
func (m *TSCardsMutation) AddedRed91to105Total() (r int, exists bool) {
	v := m.addred91to105Total
	if v == nil {
		return
	}
	return *v, true
}

// ClearRed91to105Total clears the value of the "red91to105Total" field.
func (m *TSCardsMutation) ClearRed91to105Total() {
	m.red91to105Total = nil
	m.addred91to105Total = nil
	m.clearedFields[tscards.FieldRed91to105Total] = struct{}{}
}

// Red91to105TotalCleared returns if the "red91to105Total" field was cleared in this mutation.
func (m *TSCardsMutation) Red91to105TotalCleared() bool {
	_, ok := m.clearedFields[tscards.FieldRed91to105Total]
	return ok
}

// ResetRed91to105Total resets all changes to the "red91to105Total" field.
func (m *TSCardsMutation) ResetRed91to105Total() {
	m.red91to105Total = nil
	m.addred91to105Total = nil
	delete(m.clearedFields, tscards.FieldRed91to105Total)
}

// SetRed91to105Percentage sets the "red91to105Percentage" field.
func (m *TSCardsMutation) SetRed91to105Percentage(s string) {
	m.red91to105Percentage = &s
}

// Red91to105Percentage returns the value of the "red91to105Percentage" field in the mutation.
func (m *TSCardsMutation) Red91to105Percentage() (r string, exists bool) {
	v := m.red91to105Percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldRed91to105Percentage returns the old "red91to105Percentage" field's value of the TSCards entity.
// If the TSCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCardsMutation) OldRed91to105Percentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRed91to105Percentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRed91to105Percentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRed91to105Percentage: %w", err)
	}
	return oldValue.Red91to105Percentage, nil
}

// ClearRed91to105Percentage clears the value of the "red91to105Percentage" field.
func (m *TSCardsMutation) ClearRed91to105Percentage() {
	m.red91to105Percentage = nil
	m.clearedFields[tscards.FieldRed91to105Percentage] = struct{}{}
}

// Red91to105PercentageCleared returns if the "red91to105Percentage" field was cleared in this mutation.
func (m *TSCardsMutation) Red91to105PercentageCleared() bool {
	_, ok := m.clearedFields[tscards.FieldRed91to105Percentage]
	return ok
}

// ResetRed91to105Percentage resets all changes to the "red91to105Percentage" field.
func (m *TSCardsMutation) ResetRed91to105Percentage() {
	m.red91to105Percentage = nil
	delete(m.clearedFields, tscards.FieldRed91to105Percentage)
}

// SetRed106To120Total sets the "red106To120Total" field.
func (m *TSCardsMutation) SetRed106To120Total(i int) {
	m.red106To120Total = &i
	m.addred106To120Total = nil
}

// Red106To120Total returns the value of the "red106To120Total" field in the mutation.
func (m *TSCardsMutation) Red106To120Total() (r int, exists bool) {
	v := m.red106To120Total
	if v == nil {
		return
	}
	return *v, true
}

// OldRed106To120Total returns the old "red106To120Total" field's value of the TSCards entity.
// If the TSCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCardsMutation) OldRed106To120Total(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRed106To120Total is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRed106To120Total requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRed106To120Total: %w", err)
	}
	return oldValue.Red106To120Total, nil
}

// AddRed106To120Total adds i to the "red106To120Total" field.
func (m *TSCardsMutation) AddRed106To120Total(i int) {
	if m.addred106To120Total != nil {
		*m.addred106To120Total += i
	} else {
		m.addred106To120Total = &i
	}
}

// AddedRed106To120Total returns the value that was added to the "red106To120Total" field in this mutation.
func (m *TSCardsMutation) AddedRed106To120Total() (r int, exists bool) {
	v := m.addred106To120Total
	if v == nil {
		return
	}
	return *v, true
}

// ClearRed106To120Total clears the value of the "red106To120Total" field.
func (m *TSCardsMutation) ClearRed106To120Total() {
	m.red106To120Total = nil
	m.addred106To120Total = nil
	m.clearedFields[tscards.FieldRed106To120Total] = struct{}{}
}

// Red106To120TotalCleared returns if the "red106To120Total" field was cleared in this mutation.
func (m *TSCardsMutation) Red106To120TotalCleared() bool {
	_, ok := m.clearedFields[tscards.FieldRed106To120Total]
	return ok
}

// ResetRed106To120Total resets all changes to the "red106To120Total" field.
func (m *TSCardsMutation) ResetRed106To120Total() {
	m.red106To120Total = nil
	m.addred106To120Total = nil
	delete(m.clearedFields, tscards.FieldRed106To120Total)
}

// SetRed106To120Percentage sets the "red106To120Percentage" field.
func (m *TSCardsMutation) SetRed106To120Percentage(s string) {
	m.red106To120Percentage = &s
}

// Red106To120Percentage returns the value of the "red106To120Percentage" field in the mutation.
func (m *TSCardsMutation) Red106To120Percentage() (r string, exists bool) {
	v := m.red106To120Percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldRed106To120Percentage returns the old "red106To120Percentage" field's value of the TSCards entity.
// If the TSCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCardsMutation) OldRed106To120Percentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRed106To120Percentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRed106To120Percentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRed106To120Percentage: %w", err)
	}
	return oldValue.Red106To120Percentage, nil
}

// ClearRed106To120Percentage clears the value of the "red106To120Percentage" field.
func (m *TSCardsMutation) ClearRed106To120Percentage() {
	m.red106To120Percentage = nil
	m.clearedFields[tscards.FieldRed106To120Percentage] = struct{}{}
}

// Red106To120PercentageCleared returns if the "red106To120Percentage" field was cleared in this mutation.
func (m *TSCardsMutation) Red106To120PercentageCleared() bool {
	_, ok := m.clearedFields[tscards.FieldRed106To120Percentage]
	return ok
}

// ResetRed106To120Percentage resets all changes to the "red106To120Percentage" field.
func (m *TSCardsMutation) ResetRed106To120Percentage() {
	m.red106To120Percentage = nil
	delete(m.clearedFields, tscards.FieldRed106To120Percentage)
}

// SetLastUpdated sets the "lastUpdated" field.
func (m *TSCardsMutation) SetLastUpdated(t time.Time) {
	m.lastUpdated = &t
}

// LastUpdated returns the value of the "lastUpdated" field in the mutation.
func (m *TSCardsMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.lastUpdated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "lastUpdated" field's value of the TSCards entity.
// If the TSCards object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCardsMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ClearLastUpdated clears the value of the "lastUpdated" field.
func (m *TSCardsMutation) ClearLastUpdated() {
	m.lastUpdated = nil
	m.clearedFields[tscards.FieldLastUpdated] = struct{}{}
}

// LastUpdatedCleared returns if the "lastUpdated" field was cleared in this mutation.
func (m *TSCardsMutation) LastUpdatedCleared() bool {
	_, ok := m.clearedFields[tscards.FieldLastUpdated]
	return ok
}

// ResetLastUpdated resets all changes to the "lastUpdated" field.
func (m *TSCardsMutation) ResetLastUpdated() {
	m.lastUpdated = nil
	delete(m.clearedFields, tscards.FieldLastUpdated)
}

// SetTeamID sets the "team" edge to the Team entity by id.
func (m *TSCardsMutation) SetTeamID(id int) {
	m.team = &id
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *TSCardsMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *TSCardsMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamID returns the "team" edge ID in the mutation.
func (m *TSCardsMutation) TeamID() (id int, exists bool) {
	if m.team != nil {
		return *m.team, true
	}
	return
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *TSCardsMutation) TeamIDs() (ids []int) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *TSCardsMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// Where appends a list predicates to the TSCardsMutation builder.
func (m *TSCardsMutation) Where(ps ...predicate.TSCards) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TSCardsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TSCardsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TSCards, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TSCardsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TSCardsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TSCards).
func (m *TSCardsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TSCardsMutation) Fields() []string {
	fields := make([]string, 0, 33)
	if m.yellow0To15Total != nil {
		fields = append(fields, tscards.FieldYellow0To15Total)
	}
	if m.yellow0To15Percentage != nil {
		fields = append(fields, tscards.FieldYellow0To15Percentage)
	}
	if m.yellow16To30Total != nil {
		fields = append(fields, tscards.FieldYellow16To30Total)
	}
	if m.yellow16To30Percentage != nil {
		fields = append(fields, tscards.FieldYellow16To30Percentage)
	}
	if m.yellow31To45Total != nil {
		fields = append(fields, tscards.FieldYellow31To45Total)
	}
	if m.yellow31To45Percentage != nil {
		fields = append(fields, tscards.FieldYellow31To45Percentage)
	}
	if m.yellow46To60Total != nil {
		fields = append(fields, tscards.FieldYellow46To60Total)
	}
	if m.yellow46To60Percentage != nil {
		fields = append(fields, tscards.FieldYellow46To60Percentage)
	}
	if m.yellow61To75Total != nil {
		fields = append(fields, tscards.FieldYellow61To75Total)
	}
	if m.yellow61To75Percentage != nil {
		fields = append(fields, tscards.FieldYellow61To75Percentage)
	}
	if m.yellow76To90Total != nil {
		fields = append(fields, tscards.FieldYellow76To90Total)
	}
	if m.yellow76To90Percentage != nil {
		fields = append(fields, tscards.FieldYellow76To90Percentage)
	}
	if m.yellow91to105Total != nil {
		fields = append(fields, tscards.FieldYellow91to105Total)
	}
	if m.yellow91to105Percentage != nil {
		fields = append(fields, tscards.FieldYellow91to105Percentage)
	}
	if m.yellow106To120Total != nil {
		fields = append(fields, tscards.FieldYellow106To120Total)
	}
	if m.yellow106To120Percentage != nil {
		fields = append(fields, tscards.FieldYellow106To120Percentage)
	}
	if m.red0To15Total != nil {
		fields = append(fields, tscards.FieldRed0To15Total)
	}
	if m.red0To15Percentage != nil {
		fields = append(fields, tscards.FieldRed0To15Percentage)
	}
	if m.red16To30Total != nil {
		fields = append(fields, tscards.FieldRed16To30Total)
	}
	if m.red16To30Percentage != nil {
		fields = append(fields, tscards.FieldRed16To30Percentage)
	}
	if m.red31To45Total != nil {
		fields = append(fields, tscards.FieldRed31To45Total)
	}
	if m.red31To45Percentage != nil {
		fields = append(fields, tscards.FieldRed31To45Percentage)
	}
	if m.red46To60Total != nil {
		fields = append(fields, tscards.FieldRed46To60Total)
	}
	if m.red46To60Percentage != nil {
		fields = append(fields, tscards.FieldRed46To60Percentage)
	}
	if m.red61To75Total != nil {
		fields = append(fields, tscards.FieldRed61To75Total)
	}
	if m.red61To75Percentage != nil {
		fields = append(fields, tscards.FieldRed61To75Percentage)
	}
	if m.red76To90Total != nil {
		fields = append(fields, tscards.FieldRed76To90Total)
	}
	if m.red76To90Percentage != nil {
		fields = append(fields, tscards.FieldRed76To90Percentage)
	}
	if m.red91to105Total != nil {
		fields = append(fields, tscards.FieldRed91to105Total)
	}
	if m.red91to105Percentage != nil {
		fields = append(fields, tscards.FieldRed91to105Percentage)
	}
	if m.red106To120Total != nil {
		fields = append(fields, tscards.FieldRed106To120Total)
	}
	if m.red106To120Percentage != nil {
		fields = append(fields, tscards.FieldRed106To120Percentage)
	}
	if m.lastUpdated != nil {
		fields = append(fields, tscards.FieldLastUpdated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TSCardsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tscards.FieldYellow0To15Total:
		return m.Yellow0To15Total()
	case tscards.FieldYellow0To15Percentage:
		return m.Yellow0To15Percentage()
	case tscards.FieldYellow16To30Total:
		return m.Yellow16To30Total()
	case tscards.FieldYellow16To30Percentage:
		return m.Yellow16To30Percentage()
	case tscards.FieldYellow31To45Total:
		return m.Yellow31To45Total()
	case tscards.FieldYellow31To45Percentage:
		return m.Yellow31To45Percentage()
	case tscards.FieldYellow46To60Total:
		return m.Yellow46To60Total()
	case tscards.FieldYellow46To60Percentage:
		return m.Yellow46To60Percentage()
	case tscards.FieldYellow61To75Total:
		return m.Yellow61To75Total()
	case tscards.FieldYellow61To75Percentage:
		return m.Yellow61To75Percentage()
	case tscards.FieldYellow76To90Total:
		return m.Yellow76To90Total()
	case tscards.FieldYellow76To90Percentage:
		return m.Yellow76To90Percentage()
	case tscards.FieldYellow91to105Total:
		return m.Yellow91to105Total()
	case tscards.FieldYellow91to105Percentage:
		return m.Yellow91to105Percentage()
	case tscards.FieldYellow106To120Total:
		return m.Yellow106To120Total()
	case tscards.FieldYellow106To120Percentage:
		return m.Yellow106To120Percentage()
	case tscards.FieldRed0To15Total:
		return m.Red0To15Total()
	case tscards.FieldRed0To15Percentage:
		return m.Red0To15Percentage()
	case tscards.FieldRed16To30Total:
		return m.Red16To30Total()
	case tscards.FieldRed16To30Percentage:
		return m.Red16To30Percentage()
	case tscards.FieldRed31To45Total:
		return m.Red31To45Total()
	case tscards.FieldRed31To45Percentage:
		return m.Red31To45Percentage()
	case tscards.FieldRed46To60Total:
		return m.Red46To60Total()
	case tscards.FieldRed46To60Percentage:
		return m.Red46To60Percentage()
	case tscards.FieldRed61To75Total:
		return m.Red61To75Total()
	case tscards.FieldRed61To75Percentage:
		return m.Red61To75Percentage()
	case tscards.FieldRed76To90Total:
		return m.Red76To90Total()
	case tscards.FieldRed76To90Percentage:
		return m.Red76To90Percentage()
	case tscards.FieldRed91to105Total:
		return m.Red91to105Total()
	case tscards.FieldRed91to105Percentage:
		return m.Red91to105Percentage()
	case tscards.FieldRed106To120Total:
		return m.Red106To120Total()
	case tscards.FieldRed106To120Percentage:
		return m.Red106To120Percentage()
	case tscards.FieldLastUpdated:
		return m.LastUpdated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TSCardsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tscards.FieldYellow0To15Total:
		return m.OldYellow0To15Total(ctx)
	case tscards.FieldYellow0To15Percentage:
		return m.OldYellow0To15Percentage(ctx)
	case tscards.FieldYellow16To30Total:
		return m.OldYellow16To30Total(ctx)
	case tscards.FieldYellow16To30Percentage:
		return m.OldYellow16To30Percentage(ctx)
	case tscards.FieldYellow31To45Total:
		return m.OldYellow31To45Total(ctx)
	case tscards.FieldYellow31To45Percentage:
		return m.OldYellow31To45Percentage(ctx)
	case tscards.FieldYellow46To60Total:
		return m.OldYellow46To60Total(ctx)
	case tscards.FieldYellow46To60Percentage:
		return m.OldYellow46To60Percentage(ctx)
	case tscards.FieldYellow61To75Total:
		return m.OldYellow61To75Total(ctx)
	case tscards.FieldYellow61To75Percentage:
		return m.OldYellow61To75Percentage(ctx)
	case tscards.FieldYellow76To90Total:
		return m.OldYellow76To90Total(ctx)
	case tscards.FieldYellow76To90Percentage:
		return m.OldYellow76To90Percentage(ctx)
	case tscards.FieldYellow91to105Total:
		return m.OldYellow91to105Total(ctx)
	case tscards.FieldYellow91to105Percentage:
		return m.OldYellow91to105Percentage(ctx)
	case tscards.FieldYellow106To120Total:
		return m.OldYellow106To120Total(ctx)
	case tscards.FieldYellow106To120Percentage:
		return m.OldYellow106To120Percentage(ctx)
	case tscards.FieldRed0To15Total:
		return m.OldRed0To15Total(ctx)
	case tscards.FieldRed0To15Percentage:
		return m.OldRed0To15Percentage(ctx)
	case tscards.FieldRed16To30Total:
		return m.OldRed16To30Total(ctx)
	case tscards.FieldRed16To30Percentage:
		return m.OldRed16To30Percentage(ctx)
	case tscards.FieldRed31To45Total:
		return m.OldRed31To45Total(ctx)
	case tscards.FieldRed31To45Percentage:
		return m.OldRed31To45Percentage(ctx)
	case tscards.FieldRed46To60Total:
		return m.OldRed46To60Total(ctx)
	case tscards.FieldRed46To60Percentage:
		return m.OldRed46To60Percentage(ctx)
	case tscards.FieldRed61To75Total:
		return m.OldRed61To75Total(ctx)
	case tscards.FieldRed61To75Percentage:
		return m.OldRed61To75Percentage(ctx)
	case tscards.FieldRed76To90Total:
		return m.OldRed76To90Total(ctx)
	case tscards.FieldRed76To90Percentage:
		return m.OldRed76To90Percentage(ctx)
	case tscards.FieldRed91to105Total:
		return m.OldRed91to105Total(ctx)
	case tscards.FieldRed91to105Percentage:
		return m.OldRed91to105Percentage(ctx)
	case tscards.FieldRed106To120Total:
		return m.OldRed106To120Total(ctx)
	case tscards.FieldRed106To120Percentage:
		return m.OldRed106To120Percentage(ctx)
	case tscards.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	}
	return nil, fmt.Errorf("unknown TSCards field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TSCardsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tscards.FieldYellow0To15Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYellow0To15Total(v)
		return nil
	case tscards.FieldYellow0To15Percentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYellow0To15Percentage(v)
		return nil
	case tscards.FieldYellow16To30Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYellow16To30Total(v)
		return nil
	case tscards.FieldYellow16To30Percentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYellow16To30Percentage(v)
		return nil
	case tscards.FieldYellow31To45Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYellow31To45Total(v)
		return nil
	case tscards.FieldYellow31To45Percentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYellow31To45Percentage(v)
		return nil
	case tscards.FieldYellow46To60Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYellow46To60Total(v)
		return nil
	case tscards.FieldYellow46To60Percentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYellow46To60Percentage(v)
		return nil
	case tscards.FieldYellow61To75Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYellow61To75Total(v)
		return nil
	case tscards.FieldYellow61To75Percentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYellow61To75Percentage(v)
		return nil
	case tscards.FieldYellow76To90Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYellow76To90Total(v)
		return nil
	case tscards.FieldYellow76To90Percentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYellow76To90Percentage(v)
		return nil
	case tscards.FieldYellow91to105Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYellow91to105Total(v)
		return nil
	case tscards.FieldYellow91to105Percentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYellow91to105Percentage(v)
		return nil
	case tscards.FieldYellow106To120Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYellow106To120Total(v)
		return nil
	case tscards.FieldYellow106To120Percentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYellow106To120Percentage(v)
		return nil
	case tscards.FieldRed0To15Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRed0To15Total(v)
		return nil
	case tscards.FieldRed0To15Percentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRed0To15Percentage(v)
		return nil
	case tscards.FieldRed16To30Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRed16To30Total(v)
		return nil
	case tscards.FieldRed16To30Percentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRed16To30Percentage(v)
		return nil
	case tscards.FieldRed31To45Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRed31To45Total(v)
		return nil
	case tscards.FieldRed31To45Percentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRed31To45Percentage(v)
		return nil
	case tscards.FieldRed46To60Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRed46To60Total(v)
		return nil
	case tscards.FieldRed46To60Percentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRed46To60Percentage(v)
		return nil
	case tscards.FieldRed61To75Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRed61To75Total(v)
		return nil
	case tscards.FieldRed61To75Percentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRed61To75Percentage(v)
		return nil
	case tscards.FieldRed76To90Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRed76To90Total(v)
		return nil
	case tscards.FieldRed76To90Percentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRed76To90Percentage(v)
		return nil
	case tscards.FieldRed91to105Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRed91to105Total(v)
		return nil
	case tscards.FieldRed91to105Percentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRed91to105Percentage(v)
		return nil
	case tscards.FieldRed106To120Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRed106To120Total(v)
		return nil
	case tscards.FieldRed106To120Percentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRed106To120Percentage(v)
		return nil
	case tscards.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	}
	return fmt.Errorf("unknown TSCards field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TSCardsMutation) AddedFields() []string {
	var fields []string
	if m.addyellow0To15Total != nil {
		fields = append(fields, tscards.FieldYellow0To15Total)
	}
	if m.addyellow16To30Total != nil {
		fields = append(fields, tscards.FieldYellow16To30Total)
	}
	if m.addyellow31To45Total != nil {
		fields = append(fields, tscards.FieldYellow31To45Total)
	}
	if m.addyellow46To60Total != nil {
		fields = append(fields, tscards.FieldYellow46To60Total)
	}
	if m.addyellow61To75Total != nil {
		fields = append(fields, tscards.FieldYellow61To75Total)
	}
	if m.addyellow76To90Total != nil {
		fields = append(fields, tscards.FieldYellow76To90Total)
	}
	if m.addyellow91to105Total != nil {
		fields = append(fields, tscards.FieldYellow91to105Total)
	}
	if m.addyellow106To120Total != nil {
		fields = append(fields, tscards.FieldYellow106To120Total)
	}
	if m.addred0To15Total != nil {
		fields = append(fields, tscards.FieldRed0To15Total)
	}
	if m.addred16To30Total != nil {
		fields = append(fields, tscards.FieldRed16To30Total)
	}
	if m.addred31To45Total != nil {
		fields = append(fields, tscards.FieldRed31To45Total)
	}
	if m.addred46To60Total != nil {
		fields = append(fields, tscards.FieldRed46To60Total)
	}
	if m.addred61To75Total != nil {
		fields = append(fields, tscards.FieldRed61To75Total)
	}
	if m.addred76To90Total != nil {
		fields = append(fields, tscards.FieldRed76To90Total)
	}
	if m.addred91to105Total != nil {
		fields = append(fields, tscards.FieldRed91to105Total)
	}
	if m.addred106To120Total != nil {
		fields = append(fields, tscards.FieldRed106To120Total)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TSCardsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tscards.FieldYellow0To15Total:
		return m.AddedYellow0To15Total()
	case tscards.FieldYellow16To30Total:
		return m.AddedYellow16To30Total()
	case tscards.FieldYellow31To45Total:
		return m.AddedYellow31To45Total()
	case tscards.FieldYellow46To60Total:
		return m.AddedYellow46To60Total()
	case tscards.FieldYellow61To75Total:
		return m.AddedYellow61To75Total()
	case tscards.FieldYellow76To90Total:
		return m.AddedYellow76To90Total()
	case tscards.FieldYellow91to105Total:
		return m.AddedYellow91to105Total()
	case tscards.FieldYellow106To120Total:
		return m.AddedYellow106To120Total()
	case tscards.FieldRed0To15Total:
		return m.AddedRed0To15Total()
	case tscards.FieldRed16To30Total:
		return m.AddedRed16To30Total()
	case tscards.FieldRed31To45Total:
		return m.AddedRed31To45Total()
	case tscards.FieldRed46To60Total:
		return m.AddedRed46To60Total()
	case tscards.FieldRed61To75Total:
		return m.AddedRed61To75Total()
	case tscards.FieldRed76To90Total:
		return m.AddedRed76To90Total()
	case tscards.FieldRed91to105Total:
		return m.AddedRed91to105Total()
	case tscards.FieldRed106To120Total:
		return m.AddedRed106To120Total()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TSCardsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tscards.FieldYellow0To15Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYellow0To15Total(v)
		return nil
	case tscards.FieldYellow16To30Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYellow16To30Total(v)
		return nil
	case tscards.FieldYellow31To45Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYellow31To45Total(v)
		return nil
	case tscards.FieldYellow46To60Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYellow46To60Total(v)
		return nil
	case tscards.FieldYellow61To75Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYellow61To75Total(v)
		return nil
	case tscards.FieldYellow76To90Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYellow76To90Total(v)
		return nil
	case tscards.FieldYellow91to105Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYellow91to105Total(v)
		return nil
	case tscards.FieldYellow106To120Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYellow106To120Total(v)
		return nil
	case tscards.FieldRed0To15Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRed0To15Total(v)
		return nil
	case tscards.FieldRed16To30Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRed16To30Total(v)
		return nil
	case tscards.FieldRed31To45Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRed31To45Total(v)
		return nil
	case tscards.FieldRed46To60Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRed46To60Total(v)
		return nil
	case tscards.FieldRed61To75Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRed61To75Total(v)
		return nil
	case tscards.FieldRed76To90Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRed76To90Total(v)
		return nil
	case tscards.FieldRed91to105Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRed91to105Total(v)
		return nil
	case tscards.FieldRed106To120Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRed106To120Total(v)
		return nil
	}
	return fmt.Errorf("unknown TSCards numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TSCardsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tscards.FieldYellow0To15Total) {
		fields = append(fields, tscards.FieldYellow0To15Total)
	}
	if m.FieldCleared(tscards.FieldYellow0To15Percentage) {
		fields = append(fields, tscards.FieldYellow0To15Percentage)
	}
	if m.FieldCleared(tscards.FieldYellow16To30Total) {
		fields = append(fields, tscards.FieldYellow16To30Total)
	}
	if m.FieldCleared(tscards.FieldYellow16To30Percentage) {
		fields = append(fields, tscards.FieldYellow16To30Percentage)
	}
	if m.FieldCleared(tscards.FieldYellow31To45Total) {
		fields = append(fields, tscards.FieldYellow31To45Total)
	}
	if m.FieldCleared(tscards.FieldYellow31To45Percentage) {
		fields = append(fields, tscards.FieldYellow31To45Percentage)
	}
	if m.FieldCleared(tscards.FieldYellow46To60Total) {
		fields = append(fields, tscards.FieldYellow46To60Total)
	}
	if m.FieldCleared(tscards.FieldYellow46To60Percentage) {
		fields = append(fields, tscards.FieldYellow46To60Percentage)
	}
	if m.FieldCleared(tscards.FieldYellow61To75Total) {
		fields = append(fields, tscards.FieldYellow61To75Total)
	}
	if m.FieldCleared(tscards.FieldYellow61To75Percentage) {
		fields = append(fields, tscards.FieldYellow61To75Percentage)
	}
	if m.FieldCleared(tscards.FieldYellow76To90Total) {
		fields = append(fields, tscards.FieldYellow76To90Total)
	}
	if m.FieldCleared(tscards.FieldYellow76To90Percentage) {
		fields = append(fields, tscards.FieldYellow76To90Percentage)
	}
	if m.FieldCleared(tscards.FieldYellow91to105Total) {
		fields = append(fields, tscards.FieldYellow91to105Total)
	}
	if m.FieldCleared(tscards.FieldYellow91to105Percentage) {
		fields = append(fields, tscards.FieldYellow91to105Percentage)
	}
	if m.FieldCleared(tscards.FieldYellow106To120Total) {
		fields = append(fields, tscards.FieldYellow106To120Total)
	}
	if m.FieldCleared(tscards.FieldYellow106To120Percentage) {
		fields = append(fields, tscards.FieldYellow106To120Percentage)
	}
	if m.FieldCleared(tscards.FieldRed0To15Total) {
		fields = append(fields, tscards.FieldRed0To15Total)
	}
	if m.FieldCleared(tscards.FieldRed0To15Percentage) {
		fields = append(fields, tscards.FieldRed0To15Percentage)
	}
	if m.FieldCleared(tscards.FieldRed16To30Total) {
		fields = append(fields, tscards.FieldRed16To30Total)
	}
	if m.FieldCleared(tscards.FieldRed16To30Percentage) {
		fields = append(fields, tscards.FieldRed16To30Percentage)
	}
	if m.FieldCleared(tscards.FieldRed31To45Total) {
		fields = append(fields, tscards.FieldRed31To45Total)
	}
	if m.FieldCleared(tscards.FieldRed31To45Percentage) {
		fields = append(fields, tscards.FieldRed31To45Percentage)
	}
	if m.FieldCleared(tscards.FieldRed46To60Total) {
		fields = append(fields, tscards.FieldRed46To60Total)
	}
	if m.FieldCleared(tscards.FieldRed46To60Percentage) {
		fields = append(fields, tscards.FieldRed46To60Percentage)
	}
	if m.FieldCleared(tscards.FieldRed61To75Total) {
		fields = append(fields, tscards.FieldRed61To75Total)
	}
	if m.FieldCleared(tscards.FieldRed61To75Percentage) {
		fields = append(fields, tscards.FieldRed61To75Percentage)
	}
	if m.FieldCleared(tscards.FieldRed76To90Total) {
		fields = append(fields, tscards.FieldRed76To90Total)
	}
	if m.FieldCleared(tscards.FieldRed76To90Percentage) {
		fields = append(fields, tscards.FieldRed76To90Percentage)
	}
	if m.FieldCleared(tscards.FieldRed91to105Total) {
		fields = append(fields, tscards.FieldRed91to105Total)
	}
	if m.FieldCleared(tscards.FieldRed91to105Percentage) {
		fields = append(fields, tscards.FieldRed91to105Percentage)
	}
	if m.FieldCleared(tscards.FieldRed106To120Total) {
		fields = append(fields, tscards.FieldRed106To120Total)
	}
	if m.FieldCleared(tscards.FieldRed106To120Percentage) {
		fields = append(fields, tscards.FieldRed106To120Percentage)
	}
	if m.FieldCleared(tscards.FieldLastUpdated) {
		fields = append(fields, tscards.FieldLastUpdated)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TSCardsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TSCardsMutation) ClearField(name string) error {
	switch name {
	case tscards.FieldYellow0To15Total:
		m.ClearYellow0To15Total()
		return nil
	case tscards.FieldYellow0To15Percentage:
		m.ClearYellow0To15Percentage()
		return nil
	case tscards.FieldYellow16To30Total:
		m.ClearYellow16To30Total()
		return nil
	case tscards.FieldYellow16To30Percentage:
		m.ClearYellow16To30Percentage()
		return nil
	case tscards.FieldYellow31To45Total:
		m.ClearYellow31To45Total()
		return nil
	case tscards.FieldYellow31To45Percentage:
		m.ClearYellow31To45Percentage()
		return nil
	case tscards.FieldYellow46To60Total:
		m.ClearYellow46To60Total()
		return nil
	case tscards.FieldYellow46To60Percentage:
		m.ClearYellow46To60Percentage()
		return nil
	case tscards.FieldYellow61To75Total:
		m.ClearYellow61To75Total()
		return nil
	case tscards.FieldYellow61To75Percentage:
		m.ClearYellow61To75Percentage()
		return nil
	case tscards.FieldYellow76To90Total:
		m.ClearYellow76To90Total()
		return nil
	case tscards.FieldYellow76To90Percentage:
		m.ClearYellow76To90Percentage()
		return nil
	case tscards.FieldYellow91to105Total:
		m.ClearYellow91to105Total()
		return nil
	case tscards.FieldYellow91to105Percentage:
		m.ClearYellow91to105Percentage()
		return nil
	case tscards.FieldYellow106To120Total:
		m.ClearYellow106To120Total()
		return nil
	case tscards.FieldYellow106To120Percentage:
		m.ClearYellow106To120Percentage()
		return nil
	case tscards.FieldRed0To15Total:
		m.ClearRed0To15Total()
		return nil
	case tscards.FieldRed0To15Percentage:
		m.ClearRed0To15Percentage()
		return nil
	case tscards.FieldRed16To30Total:
		m.ClearRed16To30Total()
		return nil
	case tscards.FieldRed16To30Percentage:
		m.ClearRed16To30Percentage()
		return nil
	case tscards.FieldRed31To45Total:
		m.ClearRed31To45Total()
		return nil
	case tscards.FieldRed31To45Percentage:
		m.ClearRed31To45Percentage()
		return nil
	case tscards.FieldRed46To60Total:
		m.ClearRed46To60Total()
		return nil
	case tscards.FieldRed46To60Percentage:
		m.ClearRed46To60Percentage()
		return nil
	case tscards.FieldRed61To75Total:
		m.ClearRed61To75Total()
		return nil
	case tscards.FieldRed61To75Percentage:
		m.ClearRed61To75Percentage()
		return nil
	case tscards.FieldRed76To90Total:
		m.ClearRed76To90Total()
		return nil
	case tscards.FieldRed76To90Percentage:
		m.ClearRed76To90Percentage()
		return nil
	case tscards.FieldRed91to105Total:
		m.ClearRed91to105Total()
		return nil
	case tscards.FieldRed91to105Percentage:
		m.ClearRed91to105Percentage()
		return nil
	case tscards.FieldRed106To120Total:
		m.ClearRed106To120Total()
		return nil
	case tscards.FieldRed106To120Percentage:
		m.ClearRed106To120Percentage()
		return nil
	case tscards.FieldLastUpdated:
		m.ClearLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown TSCards nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TSCardsMutation) ResetField(name string) error {
	switch name {
	case tscards.FieldYellow0To15Total:
		m.ResetYellow0To15Total()
		return nil
	case tscards.FieldYellow0To15Percentage:
		m.ResetYellow0To15Percentage()
		return nil
	case tscards.FieldYellow16To30Total:
		m.ResetYellow16To30Total()
		return nil
	case tscards.FieldYellow16To30Percentage:
		m.ResetYellow16To30Percentage()
		return nil
	case tscards.FieldYellow31To45Total:
		m.ResetYellow31To45Total()
		return nil
	case tscards.FieldYellow31To45Percentage:
		m.ResetYellow31To45Percentage()
		return nil
	case tscards.FieldYellow46To60Total:
		m.ResetYellow46To60Total()
		return nil
	case tscards.FieldYellow46To60Percentage:
		m.ResetYellow46To60Percentage()
		return nil
	case tscards.FieldYellow61To75Total:
		m.ResetYellow61To75Total()
		return nil
	case tscards.FieldYellow61To75Percentage:
		m.ResetYellow61To75Percentage()
		return nil
	case tscards.FieldYellow76To90Total:
		m.ResetYellow76To90Total()
		return nil
	case tscards.FieldYellow76To90Percentage:
		m.ResetYellow76To90Percentage()
		return nil
	case tscards.FieldYellow91to105Total:
		m.ResetYellow91to105Total()
		return nil
	case tscards.FieldYellow91to105Percentage:
		m.ResetYellow91to105Percentage()
		return nil
	case tscards.FieldYellow106To120Total:
		m.ResetYellow106To120Total()
		return nil
	case tscards.FieldYellow106To120Percentage:
		m.ResetYellow106To120Percentage()
		return nil
	case tscards.FieldRed0To15Total:
		m.ResetRed0To15Total()
		return nil
	case tscards.FieldRed0To15Percentage:
		m.ResetRed0To15Percentage()
		return nil
	case tscards.FieldRed16To30Total:
		m.ResetRed16To30Total()
		return nil
	case tscards.FieldRed16To30Percentage:
		m.ResetRed16To30Percentage()
		return nil
	case tscards.FieldRed31To45Total:
		m.ResetRed31To45Total()
		return nil
	case tscards.FieldRed31To45Percentage:
		m.ResetRed31To45Percentage()
		return nil
	case tscards.FieldRed46To60Total:
		m.ResetRed46To60Total()
		return nil
	case tscards.FieldRed46To60Percentage:
		m.ResetRed46To60Percentage()
		return nil
	case tscards.FieldRed61To75Total:
		m.ResetRed61To75Total()
		return nil
	case tscards.FieldRed61To75Percentage:
		m.ResetRed61To75Percentage()
		return nil
	case tscards.FieldRed76To90Total:
		m.ResetRed76To90Total()
		return nil
	case tscards.FieldRed76To90Percentage:
		m.ResetRed76To90Percentage()
		return nil
	case tscards.FieldRed91to105Total:
		m.ResetRed91to105Total()
		return nil
	case tscards.FieldRed91to105Percentage:
		m.ResetRed91to105Percentage()
		return nil
	case tscards.FieldRed106To120Total:
		m.ResetRed106To120Total()
		return nil
	case tscards.FieldRed106To120Percentage:
		m.ResetRed106To120Percentage()
		return nil
	case tscards.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown TSCards field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TSCardsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.team != nil {
		edges = append(edges, tscards.EdgeTeam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TSCardsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tscards.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TSCardsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TSCardsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TSCardsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedteam {
		edges = append(edges, tscards.EdgeTeam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TSCardsMutation) EdgeCleared(name string) bool {
	switch name {
	case tscards.EdgeTeam:
		return m.clearedteam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TSCardsMutation) ClearEdge(name string) error {
	switch name {
	case tscards.EdgeTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown TSCards unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TSCardsMutation) ResetEdge(name string) error {
	switch name {
	case tscards.EdgeTeam:
		m.ResetTeam()
		return nil
	}
	return fmt.Errorf("unknown TSCards edge %s", name)
}

// TSCleanSheetMutation represents an operation that mutates the TSCleanSheet nodes in the graph.
type TSCleanSheetMutation struct {
	config
	op            Op
	typ           string
	id            *int
	home          *int
	addhome       *int
	away          *int
	addaway       *int
	total         *int
	addtotal      *int
	lastUpdated   *time.Time
	clearedFields map[string]struct{}
	team          *int
	clearedteam   bool
	done          bool
	oldValue      func(context.Context) (*TSCleanSheet, error)
	predicates    []predicate.TSCleanSheet
}

var _ ent.Mutation = (*TSCleanSheetMutation)(nil)

// tscleansheetOption allows management of the mutation configuration using functional options.
type tscleansheetOption func(*TSCleanSheetMutation)

// newTSCleanSheetMutation creates new mutation for the TSCleanSheet entity.
func newTSCleanSheetMutation(c config, op Op, opts ...tscleansheetOption) *TSCleanSheetMutation {
	m := &TSCleanSheetMutation{
		config:        c,
		op:            op,
		typ:           TypeTSCleanSheet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTSCleanSheetID sets the ID field of the mutation.
func withTSCleanSheetID(id int) tscleansheetOption {
	return func(m *TSCleanSheetMutation) {
		var (
			err   error
			once  sync.Once
			value *TSCleanSheet
		)
		m.oldValue = func(ctx context.Context) (*TSCleanSheet, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TSCleanSheet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTSCleanSheet sets the old TSCleanSheet of the mutation.
func withTSCleanSheet(node *TSCleanSheet) tscleansheetOption {
	return func(m *TSCleanSheetMutation) {
		m.oldValue = func(context.Context) (*TSCleanSheet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TSCleanSheetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TSCleanSheetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TSCleanSheetMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TSCleanSheetMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TSCleanSheet.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHome sets the "home" field.
func (m *TSCleanSheetMutation) SetHome(i int) {
	m.home = &i
	m.addhome = nil
}

// Home returns the value of the "home" field in the mutation.
func (m *TSCleanSheetMutation) Home() (r int, exists bool) {
	v := m.home
	if v == nil {
		return
	}
	return *v, true
}

// OldHome returns the old "home" field's value of the TSCleanSheet entity.
// If the TSCleanSheet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCleanSheetMutation) OldHome(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHome is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHome requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHome: %w", err)
	}
	return oldValue.Home, nil
}

// AddHome adds i to the "home" field.
func (m *TSCleanSheetMutation) AddHome(i int) {
	if m.addhome != nil {
		*m.addhome += i
	} else {
		m.addhome = &i
	}
}

// AddedHome returns the value that was added to the "home" field in this mutation.
func (m *TSCleanSheetMutation) AddedHome() (r int, exists bool) {
	v := m.addhome
	if v == nil {
		return
	}
	return *v, true
}

// ClearHome clears the value of the "home" field.
func (m *TSCleanSheetMutation) ClearHome() {
	m.home = nil
	m.addhome = nil
	m.clearedFields[tscleansheet.FieldHome] = struct{}{}
}

// HomeCleared returns if the "home" field was cleared in this mutation.
func (m *TSCleanSheetMutation) HomeCleared() bool {
	_, ok := m.clearedFields[tscleansheet.FieldHome]
	return ok
}

// ResetHome resets all changes to the "home" field.
func (m *TSCleanSheetMutation) ResetHome() {
	m.home = nil
	m.addhome = nil
	delete(m.clearedFields, tscleansheet.FieldHome)
}

// SetAway sets the "away" field.
func (m *TSCleanSheetMutation) SetAway(i int) {
	m.away = &i
	m.addaway = nil
}

// Away returns the value of the "away" field in the mutation.
func (m *TSCleanSheetMutation) Away() (r int, exists bool) {
	v := m.away
	if v == nil {
		return
	}
	return *v, true
}

// OldAway returns the old "away" field's value of the TSCleanSheet entity.
// If the TSCleanSheet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCleanSheetMutation) OldAway(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAway is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAway requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAway: %w", err)
	}
	return oldValue.Away, nil
}

// AddAway adds i to the "away" field.
func (m *TSCleanSheetMutation) AddAway(i int) {
	if m.addaway != nil {
		*m.addaway += i
	} else {
		m.addaway = &i
	}
}

// AddedAway returns the value that was added to the "away" field in this mutation.
func (m *TSCleanSheetMutation) AddedAway() (r int, exists bool) {
	v := m.addaway
	if v == nil {
		return
	}
	return *v, true
}

// ClearAway clears the value of the "away" field.
func (m *TSCleanSheetMutation) ClearAway() {
	m.away = nil
	m.addaway = nil
	m.clearedFields[tscleansheet.FieldAway] = struct{}{}
}

// AwayCleared returns if the "away" field was cleared in this mutation.
func (m *TSCleanSheetMutation) AwayCleared() bool {
	_, ok := m.clearedFields[tscleansheet.FieldAway]
	return ok
}

// ResetAway resets all changes to the "away" field.
func (m *TSCleanSheetMutation) ResetAway() {
	m.away = nil
	m.addaway = nil
	delete(m.clearedFields, tscleansheet.FieldAway)
}

// SetTotal sets the "total" field.
func (m *TSCleanSheetMutation) SetTotal(i int) {
	m.total = &i
	m.addtotal = nil
}

// Total returns the value of the "total" field in the mutation.
func (m *TSCleanSheetMutation) Total() (r int, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old "total" field's value of the TSCleanSheet entity.
// If the TSCleanSheet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCleanSheetMutation) OldTotal(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// AddTotal adds i to the "total" field.
func (m *TSCleanSheetMutation) AddTotal(i int) {
	if m.addtotal != nil {
		*m.addtotal += i
	} else {
		m.addtotal = &i
	}
}

// AddedTotal returns the value that was added to the "total" field in this mutation.
func (m *TSCleanSheetMutation) AddedTotal() (r int, exists bool) {
	v := m.addtotal
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotal clears the value of the "total" field.
func (m *TSCleanSheetMutation) ClearTotal() {
	m.total = nil
	m.addtotal = nil
	m.clearedFields[tscleansheet.FieldTotal] = struct{}{}
}

// TotalCleared returns if the "total" field was cleared in this mutation.
func (m *TSCleanSheetMutation) TotalCleared() bool {
	_, ok := m.clearedFields[tscleansheet.FieldTotal]
	return ok
}

// ResetTotal resets all changes to the "total" field.
func (m *TSCleanSheetMutation) ResetTotal() {
	m.total = nil
	m.addtotal = nil
	delete(m.clearedFields, tscleansheet.FieldTotal)
}

// SetLastUpdated sets the "lastUpdated" field.
func (m *TSCleanSheetMutation) SetLastUpdated(t time.Time) {
	m.lastUpdated = &t
}

// LastUpdated returns the value of the "lastUpdated" field in the mutation.
func (m *TSCleanSheetMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.lastUpdated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "lastUpdated" field's value of the TSCleanSheet entity.
// If the TSCleanSheet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSCleanSheetMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ClearLastUpdated clears the value of the "lastUpdated" field.
func (m *TSCleanSheetMutation) ClearLastUpdated() {
	m.lastUpdated = nil
	m.clearedFields[tscleansheet.FieldLastUpdated] = struct{}{}
}

// LastUpdatedCleared returns if the "lastUpdated" field was cleared in this mutation.
func (m *TSCleanSheetMutation) LastUpdatedCleared() bool {
	_, ok := m.clearedFields[tscleansheet.FieldLastUpdated]
	return ok
}

// ResetLastUpdated resets all changes to the "lastUpdated" field.
func (m *TSCleanSheetMutation) ResetLastUpdated() {
	m.lastUpdated = nil
	delete(m.clearedFields, tscleansheet.FieldLastUpdated)
}

// SetTeamID sets the "team" edge to the Team entity by id.
func (m *TSCleanSheetMutation) SetTeamID(id int) {
	m.team = &id
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *TSCleanSheetMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *TSCleanSheetMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamID returns the "team" edge ID in the mutation.
func (m *TSCleanSheetMutation) TeamID() (id int, exists bool) {
	if m.team != nil {
		return *m.team, true
	}
	return
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *TSCleanSheetMutation) TeamIDs() (ids []int) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *TSCleanSheetMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// Where appends a list predicates to the TSCleanSheetMutation builder.
func (m *TSCleanSheetMutation) Where(ps ...predicate.TSCleanSheet) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TSCleanSheetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TSCleanSheetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TSCleanSheet, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TSCleanSheetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TSCleanSheetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TSCleanSheet).
func (m *TSCleanSheetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TSCleanSheetMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.home != nil {
		fields = append(fields, tscleansheet.FieldHome)
	}
	if m.away != nil {
		fields = append(fields, tscleansheet.FieldAway)
	}
	if m.total != nil {
		fields = append(fields, tscleansheet.FieldTotal)
	}
	if m.lastUpdated != nil {
		fields = append(fields, tscleansheet.FieldLastUpdated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TSCleanSheetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tscleansheet.FieldHome:
		return m.Home()
	case tscleansheet.FieldAway:
		return m.Away()
	case tscleansheet.FieldTotal:
		return m.Total()
	case tscleansheet.FieldLastUpdated:
		return m.LastUpdated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TSCleanSheetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tscleansheet.FieldHome:
		return m.OldHome(ctx)
	case tscleansheet.FieldAway:
		return m.OldAway(ctx)
	case tscleansheet.FieldTotal:
		return m.OldTotal(ctx)
	case tscleansheet.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	}
	return nil, fmt.Errorf("unknown TSCleanSheet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TSCleanSheetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tscleansheet.FieldHome:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHome(v)
		return nil
	case tscleansheet.FieldAway:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAway(v)
		return nil
	case tscleansheet.FieldTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	case tscleansheet.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	}
	return fmt.Errorf("unknown TSCleanSheet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TSCleanSheetMutation) AddedFields() []string {
	var fields []string
	if m.addhome != nil {
		fields = append(fields, tscleansheet.FieldHome)
	}
	if m.addaway != nil {
		fields = append(fields, tscleansheet.FieldAway)
	}
	if m.addtotal != nil {
		fields = append(fields, tscleansheet.FieldTotal)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TSCleanSheetMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tscleansheet.FieldHome:
		return m.AddedHome()
	case tscleansheet.FieldAway:
		return m.AddedAway()
	case tscleansheet.FieldTotal:
		return m.AddedTotal()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TSCleanSheetMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tscleansheet.FieldHome:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHome(v)
		return nil
	case tscleansheet.FieldAway:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAway(v)
		return nil
	case tscleansheet.FieldTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotal(v)
		return nil
	}
	return fmt.Errorf("unknown TSCleanSheet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TSCleanSheetMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tscleansheet.FieldHome) {
		fields = append(fields, tscleansheet.FieldHome)
	}
	if m.FieldCleared(tscleansheet.FieldAway) {
		fields = append(fields, tscleansheet.FieldAway)
	}
	if m.FieldCleared(tscleansheet.FieldTotal) {
		fields = append(fields, tscleansheet.FieldTotal)
	}
	if m.FieldCleared(tscleansheet.FieldLastUpdated) {
		fields = append(fields, tscleansheet.FieldLastUpdated)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TSCleanSheetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TSCleanSheetMutation) ClearField(name string) error {
	switch name {
	case tscleansheet.FieldHome:
		m.ClearHome()
		return nil
	case tscleansheet.FieldAway:
		m.ClearAway()
		return nil
	case tscleansheet.FieldTotal:
		m.ClearTotal()
		return nil
	case tscleansheet.FieldLastUpdated:
		m.ClearLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown TSCleanSheet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TSCleanSheetMutation) ResetField(name string) error {
	switch name {
	case tscleansheet.FieldHome:
		m.ResetHome()
		return nil
	case tscleansheet.FieldAway:
		m.ResetAway()
		return nil
	case tscleansheet.FieldTotal:
		m.ResetTotal()
		return nil
	case tscleansheet.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown TSCleanSheet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TSCleanSheetMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.team != nil {
		edges = append(edges, tscleansheet.EdgeTeam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TSCleanSheetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tscleansheet.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TSCleanSheetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TSCleanSheetMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TSCleanSheetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedteam {
		edges = append(edges, tscleansheet.EdgeTeam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TSCleanSheetMutation) EdgeCleared(name string) bool {
	switch name {
	case tscleansheet.EdgeTeam:
		return m.clearedteam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TSCleanSheetMutation) ClearEdge(name string) error {
	switch name {
	case tscleansheet.EdgeTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown TSCleanSheet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TSCleanSheetMutation) ResetEdge(name string) error {
	switch name {
	case tscleansheet.EdgeTeam:
		m.ResetTeam()
		return nil
	}
	return fmt.Errorf("unknown TSCleanSheet edge %s", name)
}

// TSFailedToScoreMutation represents an operation that mutates the TSFailedToScore nodes in the graph.
type TSFailedToScoreMutation struct {
	config
	op            Op
	typ           string
	id            *int
	home          *int
	addhome       *int
	away          *int
	addaway       *int
	total         *int
	addtotal      *int
	lastUpdated   *time.Time
	clearedFields map[string]struct{}
	team          *int
	clearedteam   bool
	done          bool
	oldValue      func(context.Context) (*TSFailedToScore, error)
	predicates    []predicate.TSFailedToScore
}

var _ ent.Mutation = (*TSFailedToScoreMutation)(nil)

// tsfailedtoscoreOption allows management of the mutation configuration using functional options.
type tsfailedtoscoreOption func(*TSFailedToScoreMutation)

// newTSFailedToScoreMutation creates new mutation for the TSFailedToScore entity.
func newTSFailedToScoreMutation(c config, op Op, opts ...tsfailedtoscoreOption) *TSFailedToScoreMutation {
	m := &TSFailedToScoreMutation{
		config:        c,
		op:            op,
		typ:           TypeTSFailedToScore,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTSFailedToScoreID sets the ID field of the mutation.
func withTSFailedToScoreID(id int) tsfailedtoscoreOption {
	return func(m *TSFailedToScoreMutation) {
		var (
			err   error
			once  sync.Once
			value *TSFailedToScore
		)
		m.oldValue = func(ctx context.Context) (*TSFailedToScore, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TSFailedToScore.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTSFailedToScore sets the old TSFailedToScore of the mutation.
func withTSFailedToScore(node *TSFailedToScore) tsfailedtoscoreOption {
	return func(m *TSFailedToScoreMutation) {
		m.oldValue = func(context.Context) (*TSFailedToScore, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TSFailedToScoreMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TSFailedToScoreMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TSFailedToScoreMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TSFailedToScoreMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TSFailedToScore.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHome sets the "home" field.
func (m *TSFailedToScoreMutation) SetHome(i int) {
	m.home = &i
	m.addhome = nil
}

// Home returns the value of the "home" field in the mutation.
func (m *TSFailedToScoreMutation) Home() (r int, exists bool) {
	v := m.home
	if v == nil {
		return
	}
	return *v, true
}

// OldHome returns the old "home" field's value of the TSFailedToScore entity.
// If the TSFailedToScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSFailedToScoreMutation) OldHome(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHome is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHome requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHome: %w", err)
	}
	return oldValue.Home, nil
}

// AddHome adds i to the "home" field.
func (m *TSFailedToScoreMutation) AddHome(i int) {
	if m.addhome != nil {
		*m.addhome += i
	} else {
		m.addhome = &i
	}
}

// AddedHome returns the value that was added to the "home" field in this mutation.
func (m *TSFailedToScoreMutation) AddedHome() (r int, exists bool) {
	v := m.addhome
	if v == nil {
		return
	}
	return *v, true
}

// ClearHome clears the value of the "home" field.
func (m *TSFailedToScoreMutation) ClearHome() {
	m.home = nil
	m.addhome = nil
	m.clearedFields[tsfailedtoscore.FieldHome] = struct{}{}
}

// HomeCleared returns if the "home" field was cleared in this mutation.
func (m *TSFailedToScoreMutation) HomeCleared() bool {
	_, ok := m.clearedFields[tsfailedtoscore.FieldHome]
	return ok
}

// ResetHome resets all changes to the "home" field.
func (m *TSFailedToScoreMutation) ResetHome() {
	m.home = nil
	m.addhome = nil
	delete(m.clearedFields, tsfailedtoscore.FieldHome)
}

// SetAway sets the "away" field.
func (m *TSFailedToScoreMutation) SetAway(i int) {
	m.away = &i
	m.addaway = nil
}

// Away returns the value of the "away" field in the mutation.
func (m *TSFailedToScoreMutation) Away() (r int, exists bool) {
	v := m.away
	if v == nil {
		return
	}
	return *v, true
}

// OldAway returns the old "away" field's value of the TSFailedToScore entity.
// If the TSFailedToScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSFailedToScoreMutation) OldAway(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAway is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAway requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAway: %w", err)
	}
	return oldValue.Away, nil
}

// AddAway adds i to the "away" field.
func (m *TSFailedToScoreMutation) AddAway(i int) {
	if m.addaway != nil {
		*m.addaway += i
	} else {
		m.addaway = &i
	}
}

// AddedAway returns the value that was added to the "away" field in this mutation.
func (m *TSFailedToScoreMutation) AddedAway() (r int, exists bool) {
	v := m.addaway
	if v == nil {
		return
	}
	return *v, true
}

// ClearAway clears the value of the "away" field.
func (m *TSFailedToScoreMutation) ClearAway() {
	m.away = nil
	m.addaway = nil
	m.clearedFields[tsfailedtoscore.FieldAway] = struct{}{}
}

// AwayCleared returns if the "away" field was cleared in this mutation.
func (m *TSFailedToScoreMutation) AwayCleared() bool {
	_, ok := m.clearedFields[tsfailedtoscore.FieldAway]
	return ok
}

// ResetAway resets all changes to the "away" field.
func (m *TSFailedToScoreMutation) ResetAway() {
	m.away = nil
	m.addaway = nil
	delete(m.clearedFields, tsfailedtoscore.FieldAway)
}

// SetTotal sets the "total" field.
func (m *TSFailedToScoreMutation) SetTotal(i int) {
	m.total = &i
	m.addtotal = nil
}

// Total returns the value of the "total" field in the mutation.
func (m *TSFailedToScoreMutation) Total() (r int, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old "total" field's value of the TSFailedToScore entity.
// If the TSFailedToScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSFailedToScoreMutation) OldTotal(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// AddTotal adds i to the "total" field.
func (m *TSFailedToScoreMutation) AddTotal(i int) {
	if m.addtotal != nil {
		*m.addtotal += i
	} else {
		m.addtotal = &i
	}
}

// AddedTotal returns the value that was added to the "total" field in this mutation.
func (m *TSFailedToScoreMutation) AddedTotal() (r int, exists bool) {
	v := m.addtotal
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotal clears the value of the "total" field.
func (m *TSFailedToScoreMutation) ClearTotal() {
	m.total = nil
	m.addtotal = nil
	m.clearedFields[tsfailedtoscore.FieldTotal] = struct{}{}
}

// TotalCleared returns if the "total" field was cleared in this mutation.
func (m *TSFailedToScoreMutation) TotalCleared() bool {
	_, ok := m.clearedFields[tsfailedtoscore.FieldTotal]
	return ok
}

// ResetTotal resets all changes to the "total" field.
func (m *TSFailedToScoreMutation) ResetTotal() {
	m.total = nil
	m.addtotal = nil
	delete(m.clearedFields, tsfailedtoscore.FieldTotal)
}

// SetLastUpdated sets the "lastUpdated" field.
func (m *TSFailedToScoreMutation) SetLastUpdated(t time.Time) {
	m.lastUpdated = &t
}

// LastUpdated returns the value of the "lastUpdated" field in the mutation.
func (m *TSFailedToScoreMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.lastUpdated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "lastUpdated" field's value of the TSFailedToScore entity.
// If the TSFailedToScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSFailedToScoreMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ClearLastUpdated clears the value of the "lastUpdated" field.
func (m *TSFailedToScoreMutation) ClearLastUpdated() {
	m.lastUpdated = nil
	m.clearedFields[tsfailedtoscore.FieldLastUpdated] = struct{}{}
}

// LastUpdatedCleared returns if the "lastUpdated" field was cleared in this mutation.
func (m *TSFailedToScoreMutation) LastUpdatedCleared() bool {
	_, ok := m.clearedFields[tsfailedtoscore.FieldLastUpdated]
	return ok
}

// ResetLastUpdated resets all changes to the "lastUpdated" field.
func (m *TSFailedToScoreMutation) ResetLastUpdated() {
	m.lastUpdated = nil
	delete(m.clearedFields, tsfailedtoscore.FieldLastUpdated)
}

// SetTeamID sets the "team" edge to the Team entity by id.
func (m *TSFailedToScoreMutation) SetTeamID(id int) {
	m.team = &id
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *TSFailedToScoreMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *TSFailedToScoreMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamID returns the "team" edge ID in the mutation.
func (m *TSFailedToScoreMutation) TeamID() (id int, exists bool) {
	if m.team != nil {
		return *m.team, true
	}
	return
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *TSFailedToScoreMutation) TeamIDs() (ids []int) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *TSFailedToScoreMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// Where appends a list predicates to the TSFailedToScoreMutation builder.
func (m *TSFailedToScoreMutation) Where(ps ...predicate.TSFailedToScore) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TSFailedToScoreMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TSFailedToScoreMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TSFailedToScore, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TSFailedToScoreMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TSFailedToScoreMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TSFailedToScore).
func (m *TSFailedToScoreMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TSFailedToScoreMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.home != nil {
		fields = append(fields, tsfailedtoscore.FieldHome)
	}
	if m.away != nil {
		fields = append(fields, tsfailedtoscore.FieldAway)
	}
	if m.total != nil {
		fields = append(fields, tsfailedtoscore.FieldTotal)
	}
	if m.lastUpdated != nil {
		fields = append(fields, tsfailedtoscore.FieldLastUpdated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TSFailedToScoreMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tsfailedtoscore.FieldHome:
		return m.Home()
	case tsfailedtoscore.FieldAway:
		return m.Away()
	case tsfailedtoscore.FieldTotal:
		return m.Total()
	case tsfailedtoscore.FieldLastUpdated:
		return m.LastUpdated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TSFailedToScoreMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tsfailedtoscore.FieldHome:
		return m.OldHome(ctx)
	case tsfailedtoscore.FieldAway:
		return m.OldAway(ctx)
	case tsfailedtoscore.FieldTotal:
		return m.OldTotal(ctx)
	case tsfailedtoscore.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	}
	return nil, fmt.Errorf("unknown TSFailedToScore field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TSFailedToScoreMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tsfailedtoscore.FieldHome:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHome(v)
		return nil
	case tsfailedtoscore.FieldAway:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAway(v)
		return nil
	case tsfailedtoscore.FieldTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	case tsfailedtoscore.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	}
	return fmt.Errorf("unknown TSFailedToScore field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TSFailedToScoreMutation) AddedFields() []string {
	var fields []string
	if m.addhome != nil {
		fields = append(fields, tsfailedtoscore.FieldHome)
	}
	if m.addaway != nil {
		fields = append(fields, tsfailedtoscore.FieldAway)
	}
	if m.addtotal != nil {
		fields = append(fields, tsfailedtoscore.FieldTotal)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TSFailedToScoreMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tsfailedtoscore.FieldHome:
		return m.AddedHome()
	case tsfailedtoscore.FieldAway:
		return m.AddedAway()
	case tsfailedtoscore.FieldTotal:
		return m.AddedTotal()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TSFailedToScoreMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tsfailedtoscore.FieldHome:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHome(v)
		return nil
	case tsfailedtoscore.FieldAway:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAway(v)
		return nil
	case tsfailedtoscore.FieldTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotal(v)
		return nil
	}
	return fmt.Errorf("unknown TSFailedToScore numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TSFailedToScoreMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tsfailedtoscore.FieldHome) {
		fields = append(fields, tsfailedtoscore.FieldHome)
	}
	if m.FieldCleared(tsfailedtoscore.FieldAway) {
		fields = append(fields, tsfailedtoscore.FieldAway)
	}
	if m.FieldCleared(tsfailedtoscore.FieldTotal) {
		fields = append(fields, tsfailedtoscore.FieldTotal)
	}
	if m.FieldCleared(tsfailedtoscore.FieldLastUpdated) {
		fields = append(fields, tsfailedtoscore.FieldLastUpdated)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TSFailedToScoreMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TSFailedToScoreMutation) ClearField(name string) error {
	switch name {
	case tsfailedtoscore.FieldHome:
		m.ClearHome()
		return nil
	case tsfailedtoscore.FieldAway:
		m.ClearAway()
		return nil
	case tsfailedtoscore.FieldTotal:
		m.ClearTotal()
		return nil
	case tsfailedtoscore.FieldLastUpdated:
		m.ClearLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown TSFailedToScore nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TSFailedToScoreMutation) ResetField(name string) error {
	switch name {
	case tsfailedtoscore.FieldHome:
		m.ResetHome()
		return nil
	case tsfailedtoscore.FieldAway:
		m.ResetAway()
		return nil
	case tsfailedtoscore.FieldTotal:
		m.ResetTotal()
		return nil
	case tsfailedtoscore.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown TSFailedToScore field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TSFailedToScoreMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.team != nil {
		edges = append(edges, tsfailedtoscore.EdgeTeam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TSFailedToScoreMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tsfailedtoscore.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TSFailedToScoreMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TSFailedToScoreMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TSFailedToScoreMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedteam {
		edges = append(edges, tsfailedtoscore.EdgeTeam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TSFailedToScoreMutation) EdgeCleared(name string) bool {
	switch name {
	case tsfailedtoscore.EdgeTeam:
		return m.clearedteam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TSFailedToScoreMutation) ClearEdge(name string) error {
	switch name {
	case tsfailedtoscore.EdgeTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown TSFailedToScore unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TSFailedToScoreMutation) ResetEdge(name string) error {
	switch name {
	case tsfailedtoscore.EdgeTeam:
		m.ResetTeam()
		return nil
	}
	return fmt.Errorf("unknown TSFailedToScore edge %s", name)
}

// TSFixturesMutation represents an operation that mutates the TSFixtures nodes in the graph.
type TSFixturesMutation struct {
	config
	op             Op
	typ            string
	id             *int
	playedHome     *int
	addplayedHome  *int
	playedAway     *int
	addplayedAway  *int
	playedTotal    *int
	addplayedTotal *int
	winsHome       *int
	addwinsHome    *int
	winsAway       *int
	addwinsAway    *int
	winsTotal      *int
	addwinsTotal   *int
	drawsHome      *int
	adddrawsHome   *int
	drawsAway      *int
	adddrawsAway   *int
	drawsTotal     *int
	adddrawsTotal  *int
	lossesHome     *int
	addlossesHome  *int
	lossesAway     *int
	addlossesAway  *int
	lossesTotal    *int
	addlossesTotal *int
	lastUpdated    *time.Time
	clearedFields  map[string]struct{}
	team           *int
	clearedteam    bool
	done           bool
	oldValue       func(context.Context) (*TSFixtures, error)
	predicates     []predicate.TSFixtures
}

var _ ent.Mutation = (*TSFixturesMutation)(nil)

// tsfixturesOption allows management of the mutation configuration using functional options.
type tsfixturesOption func(*TSFixturesMutation)

// newTSFixturesMutation creates new mutation for the TSFixtures entity.
func newTSFixturesMutation(c config, op Op, opts ...tsfixturesOption) *TSFixturesMutation {
	m := &TSFixturesMutation{
		config:        c,
		op:            op,
		typ:           TypeTSFixtures,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTSFixturesID sets the ID field of the mutation.
func withTSFixturesID(id int) tsfixturesOption {
	return func(m *TSFixturesMutation) {
		var (
			err   error
			once  sync.Once
			value *TSFixtures
		)
		m.oldValue = func(ctx context.Context) (*TSFixtures, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TSFixtures.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTSFixtures sets the old TSFixtures of the mutation.
func withTSFixtures(node *TSFixtures) tsfixturesOption {
	return func(m *TSFixturesMutation) {
		m.oldValue = func(context.Context) (*TSFixtures, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TSFixturesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TSFixturesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TSFixturesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TSFixturesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TSFixtures.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPlayedHome sets the "playedHome" field.
func (m *TSFixturesMutation) SetPlayedHome(i int) {
	m.playedHome = &i
	m.addplayedHome = nil
}

// PlayedHome returns the value of the "playedHome" field in the mutation.
func (m *TSFixturesMutation) PlayedHome() (r int, exists bool) {
	v := m.playedHome
	if v == nil {
		return
	}
	return *v, true
}

// OldPlayedHome returns the old "playedHome" field's value of the TSFixtures entity.
// If the TSFixtures object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSFixturesMutation) OldPlayedHome(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlayedHome is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlayedHome requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlayedHome: %w", err)
	}
	return oldValue.PlayedHome, nil
}

// AddPlayedHome adds i to the "playedHome" field.
func (m *TSFixturesMutation) AddPlayedHome(i int) {
	if m.addplayedHome != nil {
		*m.addplayedHome += i
	} else {
		m.addplayedHome = &i
	}
}

// AddedPlayedHome returns the value that was added to the "playedHome" field in this mutation.
func (m *TSFixturesMutation) AddedPlayedHome() (r int, exists bool) {
	v := m.addplayedHome
	if v == nil {
		return
	}
	return *v, true
}

// ClearPlayedHome clears the value of the "playedHome" field.
func (m *TSFixturesMutation) ClearPlayedHome() {
	m.playedHome = nil
	m.addplayedHome = nil
	m.clearedFields[tsfixtures.FieldPlayedHome] = struct{}{}
}

// PlayedHomeCleared returns if the "playedHome" field was cleared in this mutation.
func (m *TSFixturesMutation) PlayedHomeCleared() bool {
	_, ok := m.clearedFields[tsfixtures.FieldPlayedHome]
	return ok
}

// ResetPlayedHome resets all changes to the "playedHome" field.
func (m *TSFixturesMutation) ResetPlayedHome() {
	m.playedHome = nil
	m.addplayedHome = nil
	delete(m.clearedFields, tsfixtures.FieldPlayedHome)
}

// SetPlayedAway sets the "playedAway" field.
func (m *TSFixturesMutation) SetPlayedAway(i int) {
	m.playedAway = &i
	m.addplayedAway = nil
}

// PlayedAway returns the value of the "playedAway" field in the mutation.
func (m *TSFixturesMutation) PlayedAway() (r int, exists bool) {
	v := m.playedAway
	if v == nil {
		return
	}
	return *v, true
}

// OldPlayedAway returns the old "playedAway" field's value of the TSFixtures entity.
// If the TSFixtures object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSFixturesMutation) OldPlayedAway(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlayedAway is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlayedAway requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlayedAway: %w", err)
	}
	return oldValue.PlayedAway, nil
}

// AddPlayedAway adds i to the "playedAway" field.
func (m *TSFixturesMutation) AddPlayedAway(i int) {
	if m.addplayedAway != nil {
		*m.addplayedAway += i
	} else {
		m.addplayedAway = &i
	}
}

// AddedPlayedAway returns the value that was added to the "playedAway" field in this mutation.
func (m *TSFixturesMutation) AddedPlayedAway() (r int, exists bool) {
	v := m.addplayedAway
	if v == nil {
		return
	}
	return *v, true
}

// ClearPlayedAway clears the value of the "playedAway" field.
func (m *TSFixturesMutation) ClearPlayedAway() {
	m.playedAway = nil
	m.addplayedAway = nil
	m.clearedFields[tsfixtures.FieldPlayedAway] = struct{}{}
}

// PlayedAwayCleared returns if the "playedAway" field was cleared in this mutation.
func (m *TSFixturesMutation) PlayedAwayCleared() bool {
	_, ok := m.clearedFields[tsfixtures.FieldPlayedAway]
	return ok
}

// ResetPlayedAway resets all changes to the "playedAway" field.
func (m *TSFixturesMutation) ResetPlayedAway() {
	m.playedAway = nil
	m.addplayedAway = nil
	delete(m.clearedFields, tsfixtures.FieldPlayedAway)
}

// SetPlayedTotal sets the "playedTotal" field.
func (m *TSFixturesMutation) SetPlayedTotal(i int) {
	m.playedTotal = &i
	m.addplayedTotal = nil
}

// PlayedTotal returns the value of the "playedTotal" field in the mutation.
func (m *TSFixturesMutation) PlayedTotal() (r int, exists bool) {
	v := m.playedTotal
	if v == nil {
		return
	}
	return *v, true
}

// OldPlayedTotal returns the old "playedTotal" field's value of the TSFixtures entity.
// If the TSFixtures object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSFixturesMutation) OldPlayedTotal(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlayedTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlayedTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlayedTotal: %w", err)
	}
	return oldValue.PlayedTotal, nil
}

// AddPlayedTotal adds i to the "playedTotal" field.
func (m *TSFixturesMutation) AddPlayedTotal(i int) {
	if m.addplayedTotal != nil {
		*m.addplayedTotal += i
	} else {
		m.addplayedTotal = &i
	}
}

// AddedPlayedTotal returns the value that was added to the "playedTotal" field in this mutation.
func (m *TSFixturesMutation) AddedPlayedTotal() (r int, exists bool) {
	v := m.addplayedTotal
	if v == nil {
		return
	}
	return *v, true
}

// ClearPlayedTotal clears the value of the "playedTotal" field.
func (m *TSFixturesMutation) ClearPlayedTotal() {
	m.playedTotal = nil
	m.addplayedTotal = nil
	m.clearedFields[tsfixtures.FieldPlayedTotal] = struct{}{}
}

// PlayedTotalCleared returns if the "playedTotal" field was cleared in this mutation.
func (m *TSFixturesMutation) PlayedTotalCleared() bool {
	_, ok := m.clearedFields[tsfixtures.FieldPlayedTotal]
	return ok
}

// ResetPlayedTotal resets all changes to the "playedTotal" field.
func (m *TSFixturesMutation) ResetPlayedTotal() {
	m.playedTotal = nil
	m.addplayedTotal = nil
	delete(m.clearedFields, tsfixtures.FieldPlayedTotal)
}

// SetWinsHome sets the "winsHome" field.
func (m *TSFixturesMutation) SetWinsHome(i int) {
	m.winsHome = &i
	m.addwinsHome = nil
}

// WinsHome returns the value of the "winsHome" field in the mutation.
func (m *TSFixturesMutation) WinsHome() (r int, exists bool) {
	v := m.winsHome
	if v == nil {
		return
	}
	return *v, true
}

// OldWinsHome returns the old "winsHome" field's value of the TSFixtures entity.
// If the TSFixtures object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSFixturesMutation) OldWinsHome(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWinsHome is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWinsHome requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWinsHome: %w", err)
	}
	return oldValue.WinsHome, nil
}

// AddWinsHome adds i to the "winsHome" field.
func (m *TSFixturesMutation) AddWinsHome(i int) {
	if m.addwinsHome != nil {
		*m.addwinsHome += i
	} else {
		m.addwinsHome = &i
	}
}

// AddedWinsHome returns the value that was added to the "winsHome" field in this mutation.
func (m *TSFixturesMutation) AddedWinsHome() (r int, exists bool) {
	v := m.addwinsHome
	if v == nil {
		return
	}
	return *v, true
}

// ClearWinsHome clears the value of the "winsHome" field.
func (m *TSFixturesMutation) ClearWinsHome() {
	m.winsHome = nil
	m.addwinsHome = nil
	m.clearedFields[tsfixtures.FieldWinsHome] = struct{}{}
}

// WinsHomeCleared returns if the "winsHome" field was cleared in this mutation.
func (m *TSFixturesMutation) WinsHomeCleared() bool {
	_, ok := m.clearedFields[tsfixtures.FieldWinsHome]
	return ok
}

// ResetWinsHome resets all changes to the "winsHome" field.
func (m *TSFixturesMutation) ResetWinsHome() {
	m.winsHome = nil
	m.addwinsHome = nil
	delete(m.clearedFields, tsfixtures.FieldWinsHome)
}

// SetWinsAway sets the "winsAway" field.
func (m *TSFixturesMutation) SetWinsAway(i int) {
	m.winsAway = &i
	m.addwinsAway = nil
}

// WinsAway returns the value of the "winsAway" field in the mutation.
func (m *TSFixturesMutation) WinsAway() (r int, exists bool) {
	v := m.winsAway
	if v == nil {
		return
	}
	return *v, true
}

// OldWinsAway returns the old "winsAway" field's value of the TSFixtures entity.
// If the TSFixtures object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSFixturesMutation) OldWinsAway(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWinsAway is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWinsAway requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWinsAway: %w", err)
	}
	return oldValue.WinsAway, nil
}

// AddWinsAway adds i to the "winsAway" field.
func (m *TSFixturesMutation) AddWinsAway(i int) {
	if m.addwinsAway != nil {
		*m.addwinsAway += i
	} else {
		m.addwinsAway = &i
	}
}

// AddedWinsAway returns the value that was added to the "winsAway" field in this mutation.
func (m *TSFixturesMutation) AddedWinsAway() (r int, exists bool) {
	v := m.addwinsAway
	if v == nil {
		return
	}
	return *v, true
}

// ClearWinsAway clears the value of the "winsAway" field.
func (m *TSFixturesMutation) ClearWinsAway() {
	m.winsAway = nil
	m.addwinsAway = nil
	m.clearedFields[tsfixtures.FieldWinsAway] = struct{}{}
}

// WinsAwayCleared returns if the "winsAway" field was cleared in this mutation.
func (m *TSFixturesMutation) WinsAwayCleared() bool {
	_, ok := m.clearedFields[tsfixtures.FieldWinsAway]
	return ok
}

// ResetWinsAway resets all changes to the "winsAway" field.
func (m *TSFixturesMutation) ResetWinsAway() {
	m.winsAway = nil
	m.addwinsAway = nil
	delete(m.clearedFields, tsfixtures.FieldWinsAway)
}

// SetWinsTotal sets the "winsTotal" field.
func (m *TSFixturesMutation) SetWinsTotal(i int) {
	m.winsTotal = &i
	m.addwinsTotal = nil
}

// WinsTotal returns the value of the "winsTotal" field in the mutation.
func (m *TSFixturesMutation) WinsTotal() (r int, exists bool) {
	v := m.winsTotal
	if v == nil {
		return
	}
	return *v, true
}

// OldWinsTotal returns the old "winsTotal" field's value of the TSFixtures entity.
// If the TSFixtures object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSFixturesMutation) OldWinsTotal(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWinsTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWinsTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWinsTotal: %w", err)
	}
	return oldValue.WinsTotal, nil
}

// AddWinsTotal adds i to the "winsTotal" field.
func (m *TSFixturesMutation) AddWinsTotal(i int) {
	if m.addwinsTotal != nil {
		*m.addwinsTotal += i
	} else {
		m.addwinsTotal = &i
	}
}

// AddedWinsTotal returns the value that was added to the "winsTotal" field in this mutation.
func (m *TSFixturesMutation) AddedWinsTotal() (r int, exists bool) {
	v := m.addwinsTotal
	if v == nil {
		return
	}
	return *v, true
}

// ClearWinsTotal clears the value of the "winsTotal" field.
func (m *TSFixturesMutation) ClearWinsTotal() {
	m.winsTotal = nil
	m.addwinsTotal = nil
	m.clearedFields[tsfixtures.FieldWinsTotal] = struct{}{}
}

// WinsTotalCleared returns if the "winsTotal" field was cleared in this mutation.
func (m *TSFixturesMutation) WinsTotalCleared() bool {
	_, ok := m.clearedFields[tsfixtures.FieldWinsTotal]
	return ok
}

// ResetWinsTotal resets all changes to the "winsTotal" field.
func (m *TSFixturesMutation) ResetWinsTotal() {
	m.winsTotal = nil
	m.addwinsTotal = nil
	delete(m.clearedFields, tsfixtures.FieldWinsTotal)
}

// SetDrawsHome sets the "drawsHome" field.
func (m *TSFixturesMutation) SetDrawsHome(i int) {
	m.drawsHome = &i
	m.adddrawsHome = nil
}

// DrawsHome returns the value of the "drawsHome" field in the mutation.
func (m *TSFixturesMutation) DrawsHome() (r int, exists bool) {
	v := m.drawsHome
	if v == nil {
		return
	}
	return *v, true
}

// OldDrawsHome returns the old "drawsHome" field's value of the TSFixtures entity.
// If the TSFixtures object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSFixturesMutation) OldDrawsHome(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDrawsHome is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDrawsHome requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDrawsHome: %w", err)
	}
	return oldValue.DrawsHome, nil
}

// AddDrawsHome adds i to the "drawsHome" field.
func (m *TSFixturesMutation) AddDrawsHome(i int) {
	if m.adddrawsHome != nil {
		*m.adddrawsHome += i
	} else {
		m.adddrawsHome = &i
	}
}

// AddedDrawsHome returns the value that was added to the "drawsHome" field in this mutation.
func (m *TSFixturesMutation) AddedDrawsHome() (r int, exists bool) {
	v := m.adddrawsHome
	if v == nil {
		return
	}
	return *v, true
}

// ClearDrawsHome clears the value of the "drawsHome" field.
func (m *TSFixturesMutation) ClearDrawsHome() {
	m.drawsHome = nil
	m.adddrawsHome = nil
	m.clearedFields[tsfixtures.FieldDrawsHome] = struct{}{}
}

// DrawsHomeCleared returns if the "drawsHome" field was cleared in this mutation.
func (m *TSFixturesMutation) DrawsHomeCleared() bool {
	_, ok := m.clearedFields[tsfixtures.FieldDrawsHome]
	return ok
}

// ResetDrawsHome resets all changes to the "drawsHome" field.
func (m *TSFixturesMutation) ResetDrawsHome() {
	m.drawsHome = nil
	m.adddrawsHome = nil
	delete(m.clearedFields, tsfixtures.FieldDrawsHome)
}

// SetDrawsAway sets the "drawsAway" field.
func (m *TSFixturesMutation) SetDrawsAway(i int) {
	m.drawsAway = &i
	m.adddrawsAway = nil
}

// DrawsAway returns the value of the "drawsAway" field in the mutation.
func (m *TSFixturesMutation) DrawsAway() (r int, exists bool) {
	v := m.drawsAway
	if v == nil {
		return
	}
	return *v, true
}

// OldDrawsAway returns the old "drawsAway" field's value of the TSFixtures entity.
// If the TSFixtures object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSFixturesMutation) OldDrawsAway(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDrawsAway is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDrawsAway requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDrawsAway: %w", err)
	}
	return oldValue.DrawsAway, nil
}

// AddDrawsAway adds i to the "drawsAway" field.
func (m *TSFixturesMutation) AddDrawsAway(i int) {
	if m.adddrawsAway != nil {
		*m.adddrawsAway += i
	} else {
		m.adddrawsAway = &i
	}
}

// AddedDrawsAway returns the value that was added to the "drawsAway" field in this mutation.
func (m *TSFixturesMutation) AddedDrawsAway() (r int, exists bool) {
	v := m.adddrawsAway
	if v == nil {
		return
	}
	return *v, true
}

// ClearDrawsAway clears the value of the "drawsAway" field.
func (m *TSFixturesMutation) ClearDrawsAway() {
	m.drawsAway = nil
	m.adddrawsAway = nil
	m.clearedFields[tsfixtures.FieldDrawsAway] = struct{}{}
}

// DrawsAwayCleared returns if the "drawsAway" field was cleared in this mutation.
func (m *TSFixturesMutation) DrawsAwayCleared() bool {
	_, ok := m.clearedFields[tsfixtures.FieldDrawsAway]
	return ok
}

// ResetDrawsAway resets all changes to the "drawsAway" field.
func (m *TSFixturesMutation) ResetDrawsAway() {
	m.drawsAway = nil
	m.adddrawsAway = nil
	delete(m.clearedFields, tsfixtures.FieldDrawsAway)
}

// SetDrawsTotal sets the "drawsTotal" field.
func (m *TSFixturesMutation) SetDrawsTotal(i int) {
	m.drawsTotal = &i
	m.adddrawsTotal = nil
}

// DrawsTotal returns the value of the "drawsTotal" field in the mutation.
func (m *TSFixturesMutation) DrawsTotal() (r int, exists bool) {
	v := m.drawsTotal
	if v == nil {
		return
	}
	return *v, true
}

// OldDrawsTotal returns the old "drawsTotal" field's value of the TSFixtures entity.
// If the TSFixtures object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSFixturesMutation) OldDrawsTotal(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDrawsTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDrawsTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDrawsTotal: %w", err)
	}
	return oldValue.DrawsTotal, nil
}

// AddDrawsTotal adds i to the "drawsTotal" field.
func (m *TSFixturesMutation) AddDrawsTotal(i int) {
	if m.adddrawsTotal != nil {
		*m.adddrawsTotal += i
	} else {
		m.adddrawsTotal = &i
	}
}

// AddedDrawsTotal returns the value that was added to the "drawsTotal" field in this mutation.
func (m *TSFixturesMutation) AddedDrawsTotal() (r int, exists bool) {
	v := m.adddrawsTotal
	if v == nil {
		return
	}
	return *v, true
}

// ClearDrawsTotal clears the value of the "drawsTotal" field.
func (m *TSFixturesMutation) ClearDrawsTotal() {
	m.drawsTotal = nil
	m.adddrawsTotal = nil
	m.clearedFields[tsfixtures.FieldDrawsTotal] = struct{}{}
}

// DrawsTotalCleared returns if the "drawsTotal" field was cleared in this mutation.
func (m *TSFixturesMutation) DrawsTotalCleared() bool {
	_, ok := m.clearedFields[tsfixtures.FieldDrawsTotal]
	return ok
}

// ResetDrawsTotal resets all changes to the "drawsTotal" field.
func (m *TSFixturesMutation) ResetDrawsTotal() {
	m.drawsTotal = nil
	m.adddrawsTotal = nil
	delete(m.clearedFields, tsfixtures.FieldDrawsTotal)
}

// SetLossesHome sets the "lossesHome" field.
func (m *TSFixturesMutation) SetLossesHome(i int) {
	m.lossesHome = &i
	m.addlossesHome = nil
}

// LossesHome returns the value of the "lossesHome" field in the mutation.
func (m *TSFixturesMutation) LossesHome() (r int, exists bool) {
	v := m.lossesHome
	if v == nil {
		return
	}
	return *v, true
}

// OldLossesHome returns the old "lossesHome" field's value of the TSFixtures entity.
// If the TSFixtures object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSFixturesMutation) OldLossesHome(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLossesHome is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLossesHome requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLossesHome: %w", err)
	}
	return oldValue.LossesHome, nil
}

// AddLossesHome adds i to the "lossesHome" field.
func (m *TSFixturesMutation) AddLossesHome(i int) {
	if m.addlossesHome != nil {
		*m.addlossesHome += i
	} else {
		m.addlossesHome = &i
	}
}

// AddedLossesHome returns the value that was added to the "lossesHome" field in this mutation.
func (m *TSFixturesMutation) AddedLossesHome() (r int, exists bool) {
	v := m.addlossesHome
	if v == nil {
		return
	}
	return *v, true
}

// ClearLossesHome clears the value of the "lossesHome" field.
func (m *TSFixturesMutation) ClearLossesHome() {
	m.lossesHome = nil
	m.addlossesHome = nil
	m.clearedFields[tsfixtures.FieldLossesHome] = struct{}{}
}

// LossesHomeCleared returns if the "lossesHome" field was cleared in this mutation.
func (m *TSFixturesMutation) LossesHomeCleared() bool {
	_, ok := m.clearedFields[tsfixtures.FieldLossesHome]
	return ok
}

// ResetLossesHome resets all changes to the "lossesHome" field.
func (m *TSFixturesMutation) ResetLossesHome() {
	m.lossesHome = nil
	m.addlossesHome = nil
	delete(m.clearedFields, tsfixtures.FieldLossesHome)
}

// SetLossesAway sets the "lossesAway" field.
func (m *TSFixturesMutation) SetLossesAway(i int) {
	m.lossesAway = &i
	m.addlossesAway = nil
}

// LossesAway returns the value of the "lossesAway" field in the mutation.
func (m *TSFixturesMutation) LossesAway() (r int, exists bool) {
	v := m.lossesAway
	if v == nil {
		return
	}
	return *v, true
}

// OldLossesAway returns the old "lossesAway" field's value of the TSFixtures entity.
// If the TSFixtures object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSFixturesMutation) OldLossesAway(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLossesAway is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLossesAway requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLossesAway: %w", err)
	}
	return oldValue.LossesAway, nil
}

// AddLossesAway adds i to the "lossesAway" field.
func (m *TSFixturesMutation) AddLossesAway(i int) {
	if m.addlossesAway != nil {
		*m.addlossesAway += i
	} else {
		m.addlossesAway = &i
	}
}

// AddedLossesAway returns the value that was added to the "lossesAway" field in this mutation.
func (m *TSFixturesMutation) AddedLossesAway() (r int, exists bool) {
	v := m.addlossesAway
	if v == nil {
		return
	}
	return *v, true
}

// ClearLossesAway clears the value of the "lossesAway" field.
func (m *TSFixturesMutation) ClearLossesAway() {
	m.lossesAway = nil
	m.addlossesAway = nil
	m.clearedFields[tsfixtures.FieldLossesAway] = struct{}{}
}

// LossesAwayCleared returns if the "lossesAway" field was cleared in this mutation.
func (m *TSFixturesMutation) LossesAwayCleared() bool {
	_, ok := m.clearedFields[tsfixtures.FieldLossesAway]
	return ok
}

// ResetLossesAway resets all changes to the "lossesAway" field.
func (m *TSFixturesMutation) ResetLossesAway() {
	m.lossesAway = nil
	m.addlossesAway = nil
	delete(m.clearedFields, tsfixtures.FieldLossesAway)
}

// SetLossesTotal sets the "lossesTotal" field.
func (m *TSFixturesMutation) SetLossesTotal(i int) {
	m.lossesTotal = &i
	m.addlossesTotal = nil
}

// LossesTotal returns the value of the "lossesTotal" field in the mutation.
func (m *TSFixturesMutation) LossesTotal() (r int, exists bool) {
	v := m.lossesTotal
	if v == nil {
		return
	}
	return *v, true
}

// OldLossesTotal returns the old "lossesTotal" field's value of the TSFixtures entity.
// If the TSFixtures object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSFixturesMutation) OldLossesTotal(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLossesTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLossesTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLossesTotal: %w", err)
	}
	return oldValue.LossesTotal, nil
}

// AddLossesTotal adds i to the "lossesTotal" field.
func (m *TSFixturesMutation) AddLossesTotal(i int) {
	if m.addlossesTotal != nil {
		*m.addlossesTotal += i
	} else {
		m.addlossesTotal = &i
	}
}

// AddedLossesTotal returns the value that was added to the "lossesTotal" field in this mutation.
func (m *TSFixturesMutation) AddedLossesTotal() (r int, exists bool) {
	v := m.addlossesTotal
	if v == nil {
		return
	}
	return *v, true
}

// ClearLossesTotal clears the value of the "lossesTotal" field.
func (m *TSFixturesMutation) ClearLossesTotal() {
	m.lossesTotal = nil
	m.addlossesTotal = nil
	m.clearedFields[tsfixtures.FieldLossesTotal] = struct{}{}
}

// LossesTotalCleared returns if the "lossesTotal" field was cleared in this mutation.
func (m *TSFixturesMutation) LossesTotalCleared() bool {
	_, ok := m.clearedFields[tsfixtures.FieldLossesTotal]
	return ok
}

// ResetLossesTotal resets all changes to the "lossesTotal" field.
func (m *TSFixturesMutation) ResetLossesTotal() {
	m.lossesTotal = nil
	m.addlossesTotal = nil
	delete(m.clearedFields, tsfixtures.FieldLossesTotal)
}

// SetLastUpdated sets the "lastUpdated" field.
func (m *TSFixturesMutation) SetLastUpdated(t time.Time) {
	m.lastUpdated = &t
}

// LastUpdated returns the value of the "lastUpdated" field in the mutation.
func (m *TSFixturesMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.lastUpdated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "lastUpdated" field's value of the TSFixtures entity.
// If the TSFixtures object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSFixturesMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ClearLastUpdated clears the value of the "lastUpdated" field.
func (m *TSFixturesMutation) ClearLastUpdated() {
	m.lastUpdated = nil
	m.clearedFields[tsfixtures.FieldLastUpdated] = struct{}{}
}

// LastUpdatedCleared returns if the "lastUpdated" field was cleared in this mutation.
func (m *TSFixturesMutation) LastUpdatedCleared() bool {
	_, ok := m.clearedFields[tsfixtures.FieldLastUpdated]
	return ok
}

// ResetLastUpdated resets all changes to the "lastUpdated" field.
func (m *TSFixturesMutation) ResetLastUpdated() {
	m.lastUpdated = nil
	delete(m.clearedFields, tsfixtures.FieldLastUpdated)
}

// SetTeamID sets the "team" edge to the Team entity by id.
func (m *TSFixturesMutation) SetTeamID(id int) {
	m.team = &id
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *TSFixturesMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *TSFixturesMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamID returns the "team" edge ID in the mutation.
func (m *TSFixturesMutation) TeamID() (id int, exists bool) {
	if m.team != nil {
		return *m.team, true
	}
	return
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *TSFixturesMutation) TeamIDs() (ids []int) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *TSFixturesMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// Where appends a list predicates to the TSFixturesMutation builder.
func (m *TSFixturesMutation) Where(ps ...predicate.TSFixtures) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TSFixturesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TSFixturesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TSFixtures, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TSFixturesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TSFixturesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TSFixtures).
func (m *TSFixturesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TSFixturesMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.playedHome != nil {
		fields = append(fields, tsfixtures.FieldPlayedHome)
	}
	if m.playedAway != nil {
		fields = append(fields, tsfixtures.FieldPlayedAway)
	}
	if m.playedTotal != nil {
		fields = append(fields, tsfixtures.FieldPlayedTotal)
	}
	if m.winsHome != nil {
		fields = append(fields, tsfixtures.FieldWinsHome)
	}
	if m.winsAway != nil {
		fields = append(fields, tsfixtures.FieldWinsAway)
	}
	if m.winsTotal != nil {
		fields = append(fields, tsfixtures.FieldWinsTotal)
	}
	if m.drawsHome != nil {
		fields = append(fields, tsfixtures.FieldDrawsHome)
	}
	if m.drawsAway != nil {
		fields = append(fields, tsfixtures.FieldDrawsAway)
	}
	if m.drawsTotal != nil {
		fields = append(fields, tsfixtures.FieldDrawsTotal)
	}
	if m.lossesHome != nil {
		fields = append(fields, tsfixtures.FieldLossesHome)
	}
	if m.lossesAway != nil {
		fields = append(fields, tsfixtures.FieldLossesAway)
	}
	if m.lossesTotal != nil {
		fields = append(fields, tsfixtures.FieldLossesTotal)
	}
	if m.lastUpdated != nil {
		fields = append(fields, tsfixtures.FieldLastUpdated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TSFixturesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tsfixtures.FieldPlayedHome:
		return m.PlayedHome()
	case tsfixtures.FieldPlayedAway:
		return m.PlayedAway()
	case tsfixtures.FieldPlayedTotal:
		return m.PlayedTotal()
	case tsfixtures.FieldWinsHome:
		return m.WinsHome()
	case tsfixtures.FieldWinsAway:
		return m.WinsAway()
	case tsfixtures.FieldWinsTotal:
		return m.WinsTotal()
	case tsfixtures.FieldDrawsHome:
		return m.DrawsHome()
	case tsfixtures.FieldDrawsAway:
		return m.DrawsAway()
	case tsfixtures.FieldDrawsTotal:
		return m.DrawsTotal()
	case tsfixtures.FieldLossesHome:
		return m.LossesHome()
	case tsfixtures.FieldLossesAway:
		return m.LossesAway()
	case tsfixtures.FieldLossesTotal:
		return m.LossesTotal()
	case tsfixtures.FieldLastUpdated:
		return m.LastUpdated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TSFixturesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tsfixtures.FieldPlayedHome:
		return m.OldPlayedHome(ctx)
	case tsfixtures.FieldPlayedAway:
		return m.OldPlayedAway(ctx)
	case tsfixtures.FieldPlayedTotal:
		return m.OldPlayedTotal(ctx)
	case tsfixtures.FieldWinsHome:
		return m.OldWinsHome(ctx)
	case tsfixtures.FieldWinsAway:
		return m.OldWinsAway(ctx)
	case tsfixtures.FieldWinsTotal:
		return m.OldWinsTotal(ctx)
	case tsfixtures.FieldDrawsHome:
		return m.OldDrawsHome(ctx)
	case tsfixtures.FieldDrawsAway:
		return m.OldDrawsAway(ctx)
	case tsfixtures.FieldDrawsTotal:
		return m.OldDrawsTotal(ctx)
	case tsfixtures.FieldLossesHome:
		return m.OldLossesHome(ctx)
	case tsfixtures.FieldLossesAway:
		return m.OldLossesAway(ctx)
	case tsfixtures.FieldLossesTotal:
		return m.OldLossesTotal(ctx)
	case tsfixtures.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	}
	return nil, fmt.Errorf("unknown TSFixtures field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TSFixturesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tsfixtures.FieldPlayedHome:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlayedHome(v)
		return nil
	case tsfixtures.FieldPlayedAway:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlayedAway(v)
		return nil
	case tsfixtures.FieldPlayedTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlayedTotal(v)
		return nil
	case tsfixtures.FieldWinsHome:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWinsHome(v)
		return nil
	case tsfixtures.FieldWinsAway:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWinsAway(v)
		return nil
	case tsfixtures.FieldWinsTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWinsTotal(v)
		return nil
	case tsfixtures.FieldDrawsHome:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDrawsHome(v)
		return nil
	case tsfixtures.FieldDrawsAway:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDrawsAway(v)
		return nil
	case tsfixtures.FieldDrawsTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDrawsTotal(v)
		return nil
	case tsfixtures.FieldLossesHome:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLossesHome(v)
		return nil
	case tsfixtures.FieldLossesAway:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLossesAway(v)
		return nil
	case tsfixtures.FieldLossesTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLossesTotal(v)
		return nil
	case tsfixtures.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	}
	return fmt.Errorf("unknown TSFixtures field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TSFixturesMutation) AddedFields() []string {
	var fields []string
	if m.addplayedHome != nil {
		fields = append(fields, tsfixtures.FieldPlayedHome)
	}
	if m.addplayedAway != nil {
		fields = append(fields, tsfixtures.FieldPlayedAway)
	}
	if m.addplayedTotal != nil {
		fields = append(fields, tsfixtures.FieldPlayedTotal)
	}
	if m.addwinsHome != nil {
		fields = append(fields, tsfixtures.FieldWinsHome)
	}
	if m.addwinsAway != nil {
		fields = append(fields, tsfixtures.FieldWinsAway)
	}
	if m.addwinsTotal != nil {
		fields = append(fields, tsfixtures.FieldWinsTotal)
	}
	if m.adddrawsHome != nil {
		fields = append(fields, tsfixtures.FieldDrawsHome)
	}
	if m.adddrawsAway != nil {
		fields = append(fields, tsfixtures.FieldDrawsAway)
	}
	if m.adddrawsTotal != nil {
		fields = append(fields, tsfixtures.FieldDrawsTotal)
	}
	if m.addlossesHome != nil {
		fields = append(fields, tsfixtures.FieldLossesHome)
	}
	if m.addlossesAway != nil {
		fields = append(fields, tsfixtures.FieldLossesAway)
	}
	if m.addlossesTotal != nil {
		fields = append(fields, tsfixtures.FieldLossesTotal)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TSFixturesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tsfixtures.FieldPlayedHome:
		return m.AddedPlayedHome()
	case tsfixtures.FieldPlayedAway:
		return m.AddedPlayedAway()
	case tsfixtures.FieldPlayedTotal:
		return m.AddedPlayedTotal()
	case tsfixtures.FieldWinsHome:
		return m.AddedWinsHome()
	case tsfixtures.FieldWinsAway:
		return m.AddedWinsAway()
	case tsfixtures.FieldWinsTotal:
		return m.AddedWinsTotal()
	case tsfixtures.FieldDrawsHome:
		return m.AddedDrawsHome()
	case tsfixtures.FieldDrawsAway:
		return m.AddedDrawsAway()
	case tsfixtures.FieldDrawsTotal:
		return m.AddedDrawsTotal()
	case tsfixtures.FieldLossesHome:
		return m.AddedLossesHome()
	case tsfixtures.FieldLossesAway:
		return m.AddedLossesAway()
	case tsfixtures.FieldLossesTotal:
		return m.AddedLossesTotal()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TSFixturesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tsfixtures.FieldPlayedHome:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlayedHome(v)
		return nil
	case tsfixtures.FieldPlayedAway:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlayedAway(v)
		return nil
	case tsfixtures.FieldPlayedTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlayedTotal(v)
		return nil
	case tsfixtures.FieldWinsHome:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWinsHome(v)
		return nil
	case tsfixtures.FieldWinsAway:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWinsAway(v)
		return nil
	case tsfixtures.FieldWinsTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWinsTotal(v)
		return nil
	case tsfixtures.FieldDrawsHome:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDrawsHome(v)
		return nil
	case tsfixtures.FieldDrawsAway:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDrawsAway(v)
		return nil
	case tsfixtures.FieldDrawsTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDrawsTotal(v)
		return nil
	case tsfixtures.FieldLossesHome:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLossesHome(v)
		return nil
	case tsfixtures.FieldLossesAway:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLossesAway(v)
		return nil
	case tsfixtures.FieldLossesTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLossesTotal(v)
		return nil
	}
	return fmt.Errorf("unknown TSFixtures numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TSFixturesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tsfixtures.FieldPlayedHome) {
		fields = append(fields, tsfixtures.FieldPlayedHome)
	}
	if m.FieldCleared(tsfixtures.FieldPlayedAway) {
		fields = append(fields, tsfixtures.FieldPlayedAway)
	}
	if m.FieldCleared(tsfixtures.FieldPlayedTotal) {
		fields = append(fields, tsfixtures.FieldPlayedTotal)
	}
	if m.FieldCleared(tsfixtures.FieldWinsHome) {
		fields = append(fields, tsfixtures.FieldWinsHome)
	}
	if m.FieldCleared(tsfixtures.FieldWinsAway) {
		fields = append(fields, tsfixtures.FieldWinsAway)
	}
	if m.FieldCleared(tsfixtures.FieldWinsTotal) {
		fields = append(fields, tsfixtures.FieldWinsTotal)
	}
	if m.FieldCleared(tsfixtures.FieldDrawsHome) {
		fields = append(fields, tsfixtures.FieldDrawsHome)
	}
	if m.FieldCleared(tsfixtures.FieldDrawsAway) {
		fields = append(fields, tsfixtures.FieldDrawsAway)
	}
	if m.FieldCleared(tsfixtures.FieldDrawsTotal) {
		fields = append(fields, tsfixtures.FieldDrawsTotal)
	}
	if m.FieldCleared(tsfixtures.FieldLossesHome) {
		fields = append(fields, tsfixtures.FieldLossesHome)
	}
	if m.FieldCleared(tsfixtures.FieldLossesAway) {
		fields = append(fields, tsfixtures.FieldLossesAway)
	}
	if m.FieldCleared(tsfixtures.FieldLossesTotal) {
		fields = append(fields, tsfixtures.FieldLossesTotal)
	}
	if m.FieldCleared(tsfixtures.FieldLastUpdated) {
		fields = append(fields, tsfixtures.FieldLastUpdated)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TSFixturesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TSFixturesMutation) ClearField(name string) error {
	switch name {
	case tsfixtures.FieldPlayedHome:
		m.ClearPlayedHome()
		return nil
	case tsfixtures.FieldPlayedAway:
		m.ClearPlayedAway()
		return nil
	case tsfixtures.FieldPlayedTotal:
		m.ClearPlayedTotal()
		return nil
	case tsfixtures.FieldWinsHome:
		m.ClearWinsHome()
		return nil
	case tsfixtures.FieldWinsAway:
		m.ClearWinsAway()
		return nil
	case tsfixtures.FieldWinsTotal:
		m.ClearWinsTotal()
		return nil
	case tsfixtures.FieldDrawsHome:
		m.ClearDrawsHome()
		return nil
	case tsfixtures.FieldDrawsAway:
		m.ClearDrawsAway()
		return nil
	case tsfixtures.FieldDrawsTotal:
		m.ClearDrawsTotal()
		return nil
	case tsfixtures.FieldLossesHome:
		m.ClearLossesHome()
		return nil
	case tsfixtures.FieldLossesAway:
		m.ClearLossesAway()
		return nil
	case tsfixtures.FieldLossesTotal:
		m.ClearLossesTotal()
		return nil
	case tsfixtures.FieldLastUpdated:
		m.ClearLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown TSFixtures nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TSFixturesMutation) ResetField(name string) error {
	switch name {
	case tsfixtures.FieldPlayedHome:
		m.ResetPlayedHome()
		return nil
	case tsfixtures.FieldPlayedAway:
		m.ResetPlayedAway()
		return nil
	case tsfixtures.FieldPlayedTotal:
		m.ResetPlayedTotal()
		return nil
	case tsfixtures.FieldWinsHome:
		m.ResetWinsHome()
		return nil
	case tsfixtures.FieldWinsAway:
		m.ResetWinsAway()
		return nil
	case tsfixtures.FieldWinsTotal:
		m.ResetWinsTotal()
		return nil
	case tsfixtures.FieldDrawsHome:
		m.ResetDrawsHome()
		return nil
	case tsfixtures.FieldDrawsAway:
		m.ResetDrawsAway()
		return nil
	case tsfixtures.FieldDrawsTotal:
		m.ResetDrawsTotal()
		return nil
	case tsfixtures.FieldLossesHome:
		m.ResetLossesHome()
		return nil
	case tsfixtures.FieldLossesAway:
		m.ResetLossesAway()
		return nil
	case tsfixtures.FieldLossesTotal:
		m.ResetLossesTotal()
		return nil
	case tsfixtures.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown TSFixtures field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TSFixturesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.team != nil {
		edges = append(edges, tsfixtures.EdgeTeam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TSFixturesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tsfixtures.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TSFixturesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TSFixturesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TSFixturesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedteam {
		edges = append(edges, tsfixtures.EdgeTeam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TSFixturesMutation) EdgeCleared(name string) bool {
	switch name {
	case tsfixtures.EdgeTeam:
		return m.clearedteam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TSFixturesMutation) ClearEdge(name string) error {
	switch name {
	case tsfixtures.EdgeTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown TSFixtures unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TSFixturesMutation) ResetEdge(name string) error {
	switch name {
	case tsfixtures.EdgeTeam:
		m.ResetTeam()
		return nil
	}
	return fmt.Errorf("unknown TSFixtures edge %s", name)
}

// TSGoalsMutation represents an operation that mutates the TSGoals nodes in the graph.
type TSGoalsMutation struct {
	config
	op                                   Op
	typ                                  string
	id                                   *int
	goalsForTotalHome                    *int
	addgoalsForTotalHome                 *int
	goalsForTotalAway                    *int
	addgoalsForTotalAway                 *int
	goalsForTotal                        *int
	addgoalsForTotal                     *int
	goalsForAverageHome                  *string
	goalsForAverageAway                  *string
	goalsForAverageTotal                 *string
	goalsForMinute0To15Total             *int
	addgoalsForMinute0To15Total          *int
	goalsForMinute0To15Percentage        *string
	goalsForMinute16To30Total            *int
	addgoalsForMinute16To30Total         *int
	goalsForMinute16To30Percentage       *string
	goalsForMinute31To45Total            *int
	addgoalsForMinute31To45Total         *int
	goalsForMinute31To45Percentage       *string
	goalsForMinute46To60Total            *int
	addgoalsForMinute46To60Total         *int
	goalsForMinute46To60Percentage       *string
	goalsForMinute61To75Total            *int
	addgoalsForMinute61To75Total         *int
	goalsForMinute61To75Percentage       *string
	goalsForMinute76To90Total            *int
	addgoalsForMinute76To90Total         *int
	goalsForMinute76To90Percentage       *string
	goalsForMinute91To105Total           *int
	addgoalsForMinute91To105Total        *int
	goalsForMinute91To105Percentage      *string
	goalsForMinute106To120Total          *int
	addgoalsForMinute106To120Total       *int
	goalsForMinute106To120Percentage     *string
	goalsAgainstTotalHome                *int
	addgoalsAgainstTotalHome             *int
	goalsAgainstTotalAway                *int
	addgoalsAgainstTotalAway             *int
	goalsAgainstTotal                    *int
	addgoalsAgainstTotal                 *int
	goalsAgainstAverageHome              *string
	goalsAgainstAverageAway              *string
	goalsAgainstAverageTotal             *string
	goalsAgainstMinute0To15Total         *int
	addgoalsAgainstMinute0To15Total      *int
	goalsAgainstMinute0To15Percentage    *string
	goalsAgainstMinute16To30Total        *int
	addgoalsAgainstMinute16To30Total     *int
	goalsAgainstMinute16To30Percentage   *string
	goalsAgainstMinute31To45Total        *int
	addgoalsAgainstMinute31To45Total     *int
	goalsAgainstMinute31To45Percentage   *string
	goalsAgainstMinute46To60Total        *int
	addgoalsAgainstMinute46To60Total     *int
	goalsAgainstMinute46To60Percentage   *string
	goalsAgainstMinute61To75Total        *int
	addgoalsAgainstMinute61To75Total     *int
	goalsAgainstMinute61To75Percentage   *string
	goalsAgainstMinute76To90Total        *int
	addgoalsAgainstMinute76To90Total     *int
	goalsAgainstMinute76To90Percentage   *string
	goalsAgainstMinute91To105Total       *int
	addgoalsAgainstMinute91To105Total    *int
	goalsAgainstMinute91To105Percentage  *string
	goalsAgainstMinute106To120Total      *int
	addgoalsAgainstMinute106To120Total   *int
	goalsAgainstMinute106To120Percentage *string
	lastUpdated                          *time.Time
	clearedFields                        map[string]struct{}
	team                                 *int
	clearedteam                          bool
	done                                 bool
	oldValue                             func(context.Context) (*TSGoals, error)
	predicates                           []predicate.TSGoals
}

var _ ent.Mutation = (*TSGoalsMutation)(nil)

// tsgoalsOption allows management of the mutation configuration using functional options.
type tsgoalsOption func(*TSGoalsMutation)

// newTSGoalsMutation creates new mutation for the TSGoals entity.
func newTSGoalsMutation(c config, op Op, opts ...tsgoalsOption) *TSGoalsMutation {
	m := &TSGoalsMutation{
		config:        c,
		op:            op,
		typ:           TypeTSGoals,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTSGoalsID sets the ID field of the mutation.
func withTSGoalsID(id int) tsgoalsOption {
	return func(m *TSGoalsMutation) {
		var (
			err   error
			once  sync.Once
			value *TSGoals
		)
		m.oldValue = func(ctx context.Context) (*TSGoals, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TSGoals.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTSGoals sets the old TSGoals of the mutation.
func withTSGoals(node *TSGoals) tsgoalsOption {
	return func(m *TSGoalsMutation) {
		m.oldValue = func(context.Context) (*TSGoals, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TSGoalsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TSGoalsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TSGoalsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TSGoalsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TSGoals.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetGoalsForTotalHome sets the "goalsForTotalHome" field.
func (m *TSGoalsMutation) SetGoalsForTotalHome(i int) {
	m.goalsForTotalHome = &i
	m.addgoalsForTotalHome = nil
}

// GoalsForTotalHome returns the value of the "goalsForTotalHome" field in the mutation.
func (m *TSGoalsMutation) GoalsForTotalHome() (r int, exists bool) {
	v := m.goalsForTotalHome
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsForTotalHome returns the old "goalsForTotalHome" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsForTotalHome(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsForTotalHome is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsForTotalHome requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsForTotalHome: %w", err)
	}
	return oldValue.GoalsForTotalHome, nil
}

// AddGoalsForTotalHome adds i to the "goalsForTotalHome" field.
func (m *TSGoalsMutation) AddGoalsForTotalHome(i int) {
	if m.addgoalsForTotalHome != nil {
		*m.addgoalsForTotalHome += i
	} else {
		m.addgoalsForTotalHome = &i
	}
}

// AddedGoalsForTotalHome returns the value that was added to the "goalsForTotalHome" field in this mutation.
func (m *TSGoalsMutation) AddedGoalsForTotalHome() (r int, exists bool) {
	v := m.addgoalsForTotalHome
	if v == nil {
		return
	}
	return *v, true
}

// ClearGoalsForTotalHome clears the value of the "goalsForTotalHome" field.
func (m *TSGoalsMutation) ClearGoalsForTotalHome() {
	m.goalsForTotalHome = nil
	m.addgoalsForTotalHome = nil
	m.clearedFields[tsgoals.FieldGoalsForTotalHome] = struct{}{}
}

// GoalsForTotalHomeCleared returns if the "goalsForTotalHome" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsForTotalHomeCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsForTotalHome]
	return ok
}

// ResetGoalsForTotalHome resets all changes to the "goalsForTotalHome" field.
func (m *TSGoalsMutation) ResetGoalsForTotalHome() {
	m.goalsForTotalHome = nil
	m.addgoalsForTotalHome = nil
	delete(m.clearedFields, tsgoals.FieldGoalsForTotalHome)
}

// SetGoalsForTotalAway sets the "goalsForTotalAway" field.
func (m *TSGoalsMutation) SetGoalsForTotalAway(i int) {
	m.goalsForTotalAway = &i
	m.addgoalsForTotalAway = nil
}

// GoalsForTotalAway returns the value of the "goalsForTotalAway" field in the mutation.
func (m *TSGoalsMutation) GoalsForTotalAway() (r int, exists bool) {
	v := m.goalsForTotalAway
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsForTotalAway returns the old "goalsForTotalAway" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsForTotalAway(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsForTotalAway is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsForTotalAway requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsForTotalAway: %w", err)
	}
	return oldValue.GoalsForTotalAway, nil
}

// AddGoalsForTotalAway adds i to the "goalsForTotalAway" field.
func (m *TSGoalsMutation) AddGoalsForTotalAway(i int) {
	if m.addgoalsForTotalAway != nil {
		*m.addgoalsForTotalAway += i
	} else {
		m.addgoalsForTotalAway = &i
	}
}

// AddedGoalsForTotalAway returns the value that was added to the "goalsForTotalAway" field in this mutation.
func (m *TSGoalsMutation) AddedGoalsForTotalAway() (r int, exists bool) {
	v := m.addgoalsForTotalAway
	if v == nil {
		return
	}
	return *v, true
}

// ClearGoalsForTotalAway clears the value of the "goalsForTotalAway" field.
func (m *TSGoalsMutation) ClearGoalsForTotalAway() {
	m.goalsForTotalAway = nil
	m.addgoalsForTotalAway = nil
	m.clearedFields[tsgoals.FieldGoalsForTotalAway] = struct{}{}
}

// GoalsForTotalAwayCleared returns if the "goalsForTotalAway" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsForTotalAwayCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsForTotalAway]
	return ok
}

// ResetGoalsForTotalAway resets all changes to the "goalsForTotalAway" field.
func (m *TSGoalsMutation) ResetGoalsForTotalAway() {
	m.goalsForTotalAway = nil
	m.addgoalsForTotalAway = nil
	delete(m.clearedFields, tsgoals.FieldGoalsForTotalAway)
}

// SetGoalsForTotal sets the "goalsForTotal" field.
func (m *TSGoalsMutation) SetGoalsForTotal(i int) {
	m.goalsForTotal = &i
	m.addgoalsForTotal = nil
}

// GoalsForTotal returns the value of the "goalsForTotal" field in the mutation.
func (m *TSGoalsMutation) GoalsForTotal() (r int, exists bool) {
	v := m.goalsForTotal
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsForTotal returns the old "goalsForTotal" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsForTotal(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsForTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsForTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsForTotal: %w", err)
	}
	return oldValue.GoalsForTotal, nil
}

// AddGoalsForTotal adds i to the "goalsForTotal" field.
func (m *TSGoalsMutation) AddGoalsForTotal(i int) {
	if m.addgoalsForTotal != nil {
		*m.addgoalsForTotal += i
	} else {
		m.addgoalsForTotal = &i
	}
}

// AddedGoalsForTotal returns the value that was added to the "goalsForTotal" field in this mutation.
func (m *TSGoalsMutation) AddedGoalsForTotal() (r int, exists bool) {
	v := m.addgoalsForTotal
	if v == nil {
		return
	}
	return *v, true
}

// ClearGoalsForTotal clears the value of the "goalsForTotal" field.
func (m *TSGoalsMutation) ClearGoalsForTotal() {
	m.goalsForTotal = nil
	m.addgoalsForTotal = nil
	m.clearedFields[tsgoals.FieldGoalsForTotal] = struct{}{}
}

// GoalsForTotalCleared returns if the "goalsForTotal" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsForTotalCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsForTotal]
	return ok
}

// ResetGoalsForTotal resets all changes to the "goalsForTotal" field.
func (m *TSGoalsMutation) ResetGoalsForTotal() {
	m.goalsForTotal = nil
	m.addgoalsForTotal = nil
	delete(m.clearedFields, tsgoals.FieldGoalsForTotal)
}

// SetGoalsForAverageHome sets the "goalsForAverageHome" field.
func (m *TSGoalsMutation) SetGoalsForAverageHome(s string) {
	m.goalsForAverageHome = &s
}

// GoalsForAverageHome returns the value of the "goalsForAverageHome" field in the mutation.
func (m *TSGoalsMutation) GoalsForAverageHome() (r string, exists bool) {
	v := m.goalsForAverageHome
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsForAverageHome returns the old "goalsForAverageHome" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsForAverageHome(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsForAverageHome is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsForAverageHome requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsForAverageHome: %w", err)
	}
	return oldValue.GoalsForAverageHome, nil
}

// ClearGoalsForAverageHome clears the value of the "goalsForAverageHome" field.
func (m *TSGoalsMutation) ClearGoalsForAverageHome() {
	m.goalsForAverageHome = nil
	m.clearedFields[tsgoals.FieldGoalsForAverageHome] = struct{}{}
}

// GoalsForAverageHomeCleared returns if the "goalsForAverageHome" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsForAverageHomeCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsForAverageHome]
	return ok
}

// ResetGoalsForAverageHome resets all changes to the "goalsForAverageHome" field.
func (m *TSGoalsMutation) ResetGoalsForAverageHome() {
	m.goalsForAverageHome = nil
	delete(m.clearedFields, tsgoals.FieldGoalsForAverageHome)
}

// SetGoalsForAverageAway sets the "goalsForAverageAway" field.
func (m *TSGoalsMutation) SetGoalsForAverageAway(s string) {
	m.goalsForAverageAway = &s
}

// GoalsForAverageAway returns the value of the "goalsForAverageAway" field in the mutation.
func (m *TSGoalsMutation) GoalsForAverageAway() (r string, exists bool) {
	v := m.goalsForAverageAway
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsForAverageAway returns the old "goalsForAverageAway" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsForAverageAway(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsForAverageAway is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsForAverageAway requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsForAverageAway: %w", err)
	}
	return oldValue.GoalsForAverageAway, nil
}

// ClearGoalsForAverageAway clears the value of the "goalsForAverageAway" field.
func (m *TSGoalsMutation) ClearGoalsForAverageAway() {
	m.goalsForAverageAway = nil
	m.clearedFields[tsgoals.FieldGoalsForAverageAway] = struct{}{}
}

// GoalsForAverageAwayCleared returns if the "goalsForAverageAway" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsForAverageAwayCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsForAverageAway]
	return ok
}

// ResetGoalsForAverageAway resets all changes to the "goalsForAverageAway" field.
func (m *TSGoalsMutation) ResetGoalsForAverageAway() {
	m.goalsForAverageAway = nil
	delete(m.clearedFields, tsgoals.FieldGoalsForAverageAway)
}

// SetGoalsForAverageTotal sets the "goalsForAverageTotal" field.
func (m *TSGoalsMutation) SetGoalsForAverageTotal(s string) {
	m.goalsForAverageTotal = &s
}

// GoalsForAverageTotal returns the value of the "goalsForAverageTotal" field in the mutation.
func (m *TSGoalsMutation) GoalsForAverageTotal() (r string, exists bool) {
	v := m.goalsForAverageTotal
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsForAverageTotal returns the old "goalsForAverageTotal" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsForAverageTotal(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsForAverageTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsForAverageTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsForAverageTotal: %w", err)
	}
	return oldValue.GoalsForAverageTotal, nil
}

// ClearGoalsForAverageTotal clears the value of the "goalsForAverageTotal" field.
func (m *TSGoalsMutation) ClearGoalsForAverageTotal() {
	m.goalsForAverageTotal = nil
	m.clearedFields[tsgoals.FieldGoalsForAverageTotal] = struct{}{}
}

// GoalsForAverageTotalCleared returns if the "goalsForAverageTotal" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsForAverageTotalCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsForAverageTotal]
	return ok
}

// ResetGoalsForAverageTotal resets all changes to the "goalsForAverageTotal" field.
func (m *TSGoalsMutation) ResetGoalsForAverageTotal() {
	m.goalsForAverageTotal = nil
	delete(m.clearedFields, tsgoals.FieldGoalsForAverageTotal)
}

// SetGoalsForMinute0To15Total sets the "goalsForMinute0To15Total" field.
func (m *TSGoalsMutation) SetGoalsForMinute0To15Total(i int) {
	m.goalsForMinute0To15Total = &i
	m.addgoalsForMinute0To15Total = nil
}

// GoalsForMinute0To15Total returns the value of the "goalsForMinute0To15Total" field in the mutation.
func (m *TSGoalsMutation) GoalsForMinute0To15Total() (r int, exists bool) {
	v := m.goalsForMinute0To15Total
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsForMinute0To15Total returns the old "goalsForMinute0To15Total" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsForMinute0To15Total(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsForMinute0To15Total is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsForMinute0To15Total requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsForMinute0To15Total: %w", err)
	}
	return oldValue.GoalsForMinute0To15Total, nil
}

// AddGoalsForMinute0To15Total adds i to the "goalsForMinute0To15Total" field.
func (m *TSGoalsMutation) AddGoalsForMinute0To15Total(i int) {
	if m.addgoalsForMinute0To15Total != nil {
		*m.addgoalsForMinute0To15Total += i
	} else {
		m.addgoalsForMinute0To15Total = &i
	}
}

// AddedGoalsForMinute0To15Total returns the value that was added to the "goalsForMinute0To15Total" field in this mutation.
func (m *TSGoalsMutation) AddedGoalsForMinute0To15Total() (r int, exists bool) {
	v := m.addgoalsForMinute0To15Total
	if v == nil {
		return
	}
	return *v, true
}

// ClearGoalsForMinute0To15Total clears the value of the "goalsForMinute0To15Total" field.
func (m *TSGoalsMutation) ClearGoalsForMinute0To15Total() {
	m.goalsForMinute0To15Total = nil
	m.addgoalsForMinute0To15Total = nil
	m.clearedFields[tsgoals.FieldGoalsForMinute0To15Total] = struct{}{}
}

// GoalsForMinute0To15TotalCleared returns if the "goalsForMinute0To15Total" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsForMinute0To15TotalCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsForMinute0To15Total]
	return ok
}

// ResetGoalsForMinute0To15Total resets all changes to the "goalsForMinute0To15Total" field.
func (m *TSGoalsMutation) ResetGoalsForMinute0To15Total() {
	m.goalsForMinute0To15Total = nil
	m.addgoalsForMinute0To15Total = nil
	delete(m.clearedFields, tsgoals.FieldGoalsForMinute0To15Total)
}

// SetGoalsForMinute0To15Percentage sets the "goalsForMinute0To15Percentage" field.
func (m *TSGoalsMutation) SetGoalsForMinute0To15Percentage(s string) {
	m.goalsForMinute0To15Percentage = &s
}

// GoalsForMinute0To15Percentage returns the value of the "goalsForMinute0To15Percentage" field in the mutation.
func (m *TSGoalsMutation) GoalsForMinute0To15Percentage() (r string, exists bool) {
	v := m.goalsForMinute0To15Percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsForMinute0To15Percentage returns the old "goalsForMinute0To15Percentage" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsForMinute0To15Percentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsForMinute0To15Percentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsForMinute0To15Percentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsForMinute0To15Percentage: %w", err)
	}
	return oldValue.GoalsForMinute0To15Percentage, nil
}

// ClearGoalsForMinute0To15Percentage clears the value of the "goalsForMinute0To15Percentage" field.
func (m *TSGoalsMutation) ClearGoalsForMinute0To15Percentage() {
	m.goalsForMinute0To15Percentage = nil
	m.clearedFields[tsgoals.FieldGoalsForMinute0To15Percentage] = struct{}{}
}

// GoalsForMinute0To15PercentageCleared returns if the "goalsForMinute0To15Percentage" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsForMinute0To15PercentageCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsForMinute0To15Percentage]
	return ok
}

// ResetGoalsForMinute0To15Percentage resets all changes to the "goalsForMinute0To15Percentage" field.
func (m *TSGoalsMutation) ResetGoalsForMinute0To15Percentage() {
	m.goalsForMinute0To15Percentage = nil
	delete(m.clearedFields, tsgoals.FieldGoalsForMinute0To15Percentage)
}

// SetGoalsForMinute16To30Total sets the "goalsForMinute16To30Total" field.
func (m *TSGoalsMutation) SetGoalsForMinute16To30Total(i int) {
	m.goalsForMinute16To30Total = &i
	m.addgoalsForMinute16To30Total = nil
}

// GoalsForMinute16To30Total returns the value of the "goalsForMinute16To30Total" field in the mutation.
func (m *TSGoalsMutation) GoalsForMinute16To30Total() (r int, exists bool) {
	v := m.goalsForMinute16To30Total
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsForMinute16To30Total returns the old "goalsForMinute16To30Total" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsForMinute16To30Total(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsForMinute16To30Total is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsForMinute16To30Total requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsForMinute16To30Total: %w", err)
	}
	return oldValue.GoalsForMinute16To30Total, nil
}

// AddGoalsForMinute16To30Total adds i to the "goalsForMinute16To30Total" field.
func (m *TSGoalsMutation) AddGoalsForMinute16To30Total(i int) {
	if m.addgoalsForMinute16To30Total != nil {
		*m.addgoalsForMinute16To30Total += i
	} else {
		m.addgoalsForMinute16To30Total = &i
	}
}

// AddedGoalsForMinute16To30Total returns the value that was added to the "goalsForMinute16To30Total" field in this mutation.
func (m *TSGoalsMutation) AddedGoalsForMinute16To30Total() (r int, exists bool) {
	v := m.addgoalsForMinute16To30Total
	if v == nil {
		return
	}
	return *v, true
}

// ClearGoalsForMinute16To30Total clears the value of the "goalsForMinute16To30Total" field.
func (m *TSGoalsMutation) ClearGoalsForMinute16To30Total() {
	m.goalsForMinute16To30Total = nil
	m.addgoalsForMinute16To30Total = nil
	m.clearedFields[tsgoals.FieldGoalsForMinute16To30Total] = struct{}{}
}

// GoalsForMinute16To30TotalCleared returns if the "goalsForMinute16To30Total" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsForMinute16To30TotalCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsForMinute16To30Total]
	return ok
}

// ResetGoalsForMinute16To30Total resets all changes to the "goalsForMinute16To30Total" field.
func (m *TSGoalsMutation) ResetGoalsForMinute16To30Total() {
	m.goalsForMinute16To30Total = nil
	m.addgoalsForMinute16To30Total = nil
	delete(m.clearedFields, tsgoals.FieldGoalsForMinute16To30Total)
}

// SetGoalsForMinute16To30Percentage sets the "goalsForMinute16To30Percentage" field.
func (m *TSGoalsMutation) SetGoalsForMinute16To30Percentage(s string) {
	m.goalsForMinute16To30Percentage = &s
}

// GoalsForMinute16To30Percentage returns the value of the "goalsForMinute16To30Percentage" field in the mutation.
func (m *TSGoalsMutation) GoalsForMinute16To30Percentage() (r string, exists bool) {
	v := m.goalsForMinute16To30Percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsForMinute16To30Percentage returns the old "goalsForMinute16To30Percentage" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsForMinute16To30Percentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsForMinute16To30Percentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsForMinute16To30Percentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsForMinute16To30Percentage: %w", err)
	}
	return oldValue.GoalsForMinute16To30Percentage, nil
}

// ClearGoalsForMinute16To30Percentage clears the value of the "goalsForMinute16To30Percentage" field.
func (m *TSGoalsMutation) ClearGoalsForMinute16To30Percentage() {
	m.goalsForMinute16To30Percentage = nil
	m.clearedFields[tsgoals.FieldGoalsForMinute16To30Percentage] = struct{}{}
}

// GoalsForMinute16To30PercentageCleared returns if the "goalsForMinute16To30Percentage" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsForMinute16To30PercentageCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsForMinute16To30Percentage]
	return ok
}

// ResetGoalsForMinute16To30Percentage resets all changes to the "goalsForMinute16To30Percentage" field.
func (m *TSGoalsMutation) ResetGoalsForMinute16To30Percentage() {
	m.goalsForMinute16To30Percentage = nil
	delete(m.clearedFields, tsgoals.FieldGoalsForMinute16To30Percentage)
}

// SetGoalsForMinute31To45Total sets the "goalsForMinute31To45Total" field.
func (m *TSGoalsMutation) SetGoalsForMinute31To45Total(i int) {
	m.goalsForMinute31To45Total = &i
	m.addgoalsForMinute31To45Total = nil
}

// GoalsForMinute31To45Total returns the value of the "goalsForMinute31To45Total" field in the mutation.
func (m *TSGoalsMutation) GoalsForMinute31To45Total() (r int, exists bool) {
	v := m.goalsForMinute31To45Total
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsForMinute31To45Total returns the old "goalsForMinute31To45Total" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsForMinute31To45Total(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsForMinute31To45Total is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsForMinute31To45Total requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsForMinute31To45Total: %w", err)
	}
	return oldValue.GoalsForMinute31To45Total, nil
}

// AddGoalsForMinute31To45Total adds i to the "goalsForMinute31To45Total" field.
func (m *TSGoalsMutation) AddGoalsForMinute31To45Total(i int) {
	if m.addgoalsForMinute31To45Total != nil {
		*m.addgoalsForMinute31To45Total += i
	} else {
		m.addgoalsForMinute31To45Total = &i
	}
}

// AddedGoalsForMinute31To45Total returns the value that was added to the "goalsForMinute31To45Total" field in this mutation.
func (m *TSGoalsMutation) AddedGoalsForMinute31To45Total() (r int, exists bool) {
	v := m.addgoalsForMinute31To45Total
	if v == nil {
		return
	}
	return *v, true
}

// ClearGoalsForMinute31To45Total clears the value of the "goalsForMinute31To45Total" field.
func (m *TSGoalsMutation) ClearGoalsForMinute31To45Total() {
	m.goalsForMinute31To45Total = nil
	m.addgoalsForMinute31To45Total = nil
	m.clearedFields[tsgoals.FieldGoalsForMinute31To45Total] = struct{}{}
}

// GoalsForMinute31To45TotalCleared returns if the "goalsForMinute31To45Total" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsForMinute31To45TotalCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsForMinute31To45Total]
	return ok
}

// ResetGoalsForMinute31To45Total resets all changes to the "goalsForMinute31To45Total" field.
func (m *TSGoalsMutation) ResetGoalsForMinute31To45Total() {
	m.goalsForMinute31To45Total = nil
	m.addgoalsForMinute31To45Total = nil
	delete(m.clearedFields, tsgoals.FieldGoalsForMinute31To45Total)
}

// SetGoalsForMinute31To45Percentage sets the "goalsForMinute31To45Percentage" field.
func (m *TSGoalsMutation) SetGoalsForMinute31To45Percentage(s string) {
	m.goalsForMinute31To45Percentage = &s
}

// GoalsForMinute31To45Percentage returns the value of the "goalsForMinute31To45Percentage" field in the mutation.
func (m *TSGoalsMutation) GoalsForMinute31To45Percentage() (r string, exists bool) {
	v := m.goalsForMinute31To45Percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsForMinute31To45Percentage returns the old "goalsForMinute31To45Percentage" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsForMinute31To45Percentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsForMinute31To45Percentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsForMinute31To45Percentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsForMinute31To45Percentage: %w", err)
	}
	return oldValue.GoalsForMinute31To45Percentage, nil
}

// ClearGoalsForMinute31To45Percentage clears the value of the "goalsForMinute31To45Percentage" field.
func (m *TSGoalsMutation) ClearGoalsForMinute31To45Percentage() {
	m.goalsForMinute31To45Percentage = nil
	m.clearedFields[tsgoals.FieldGoalsForMinute31To45Percentage] = struct{}{}
}

// GoalsForMinute31To45PercentageCleared returns if the "goalsForMinute31To45Percentage" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsForMinute31To45PercentageCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsForMinute31To45Percentage]
	return ok
}

// ResetGoalsForMinute31To45Percentage resets all changes to the "goalsForMinute31To45Percentage" field.
func (m *TSGoalsMutation) ResetGoalsForMinute31To45Percentage() {
	m.goalsForMinute31To45Percentage = nil
	delete(m.clearedFields, tsgoals.FieldGoalsForMinute31To45Percentage)
}

// SetGoalsForMinute46To60Total sets the "goalsForMinute46To60Total" field.
func (m *TSGoalsMutation) SetGoalsForMinute46To60Total(i int) {
	m.goalsForMinute46To60Total = &i
	m.addgoalsForMinute46To60Total = nil
}

// GoalsForMinute46To60Total returns the value of the "goalsForMinute46To60Total" field in the mutation.
func (m *TSGoalsMutation) GoalsForMinute46To60Total() (r int, exists bool) {
	v := m.goalsForMinute46To60Total
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsForMinute46To60Total returns the old "goalsForMinute46To60Total" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsForMinute46To60Total(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsForMinute46To60Total is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsForMinute46To60Total requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsForMinute46To60Total: %w", err)
	}
	return oldValue.GoalsForMinute46To60Total, nil
}

// AddGoalsForMinute46To60Total adds i to the "goalsForMinute46To60Total" field.
func (m *TSGoalsMutation) AddGoalsForMinute46To60Total(i int) {
	if m.addgoalsForMinute46To60Total != nil {
		*m.addgoalsForMinute46To60Total += i
	} else {
		m.addgoalsForMinute46To60Total = &i
	}
}

// AddedGoalsForMinute46To60Total returns the value that was added to the "goalsForMinute46To60Total" field in this mutation.
func (m *TSGoalsMutation) AddedGoalsForMinute46To60Total() (r int, exists bool) {
	v := m.addgoalsForMinute46To60Total
	if v == nil {
		return
	}
	return *v, true
}

// ClearGoalsForMinute46To60Total clears the value of the "goalsForMinute46To60Total" field.
func (m *TSGoalsMutation) ClearGoalsForMinute46To60Total() {
	m.goalsForMinute46To60Total = nil
	m.addgoalsForMinute46To60Total = nil
	m.clearedFields[tsgoals.FieldGoalsForMinute46To60Total] = struct{}{}
}

// GoalsForMinute46To60TotalCleared returns if the "goalsForMinute46To60Total" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsForMinute46To60TotalCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsForMinute46To60Total]
	return ok
}

// ResetGoalsForMinute46To60Total resets all changes to the "goalsForMinute46To60Total" field.
func (m *TSGoalsMutation) ResetGoalsForMinute46To60Total() {
	m.goalsForMinute46To60Total = nil
	m.addgoalsForMinute46To60Total = nil
	delete(m.clearedFields, tsgoals.FieldGoalsForMinute46To60Total)
}

// SetGoalsForMinute46To60Percentage sets the "goalsForMinute46To60Percentage" field.
func (m *TSGoalsMutation) SetGoalsForMinute46To60Percentage(s string) {
	m.goalsForMinute46To60Percentage = &s
}

// GoalsForMinute46To60Percentage returns the value of the "goalsForMinute46To60Percentage" field in the mutation.
func (m *TSGoalsMutation) GoalsForMinute46To60Percentage() (r string, exists bool) {
	v := m.goalsForMinute46To60Percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsForMinute46To60Percentage returns the old "goalsForMinute46To60Percentage" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsForMinute46To60Percentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsForMinute46To60Percentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsForMinute46To60Percentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsForMinute46To60Percentage: %w", err)
	}
	return oldValue.GoalsForMinute46To60Percentage, nil
}

// ClearGoalsForMinute46To60Percentage clears the value of the "goalsForMinute46To60Percentage" field.
func (m *TSGoalsMutation) ClearGoalsForMinute46To60Percentage() {
	m.goalsForMinute46To60Percentage = nil
	m.clearedFields[tsgoals.FieldGoalsForMinute46To60Percentage] = struct{}{}
}

// GoalsForMinute46To60PercentageCleared returns if the "goalsForMinute46To60Percentage" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsForMinute46To60PercentageCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsForMinute46To60Percentage]
	return ok
}

// ResetGoalsForMinute46To60Percentage resets all changes to the "goalsForMinute46To60Percentage" field.
func (m *TSGoalsMutation) ResetGoalsForMinute46To60Percentage() {
	m.goalsForMinute46To60Percentage = nil
	delete(m.clearedFields, tsgoals.FieldGoalsForMinute46To60Percentage)
}

// SetGoalsForMinute61To75Total sets the "goalsForMinute61To75Total" field.
func (m *TSGoalsMutation) SetGoalsForMinute61To75Total(i int) {
	m.goalsForMinute61To75Total = &i
	m.addgoalsForMinute61To75Total = nil
}

// GoalsForMinute61To75Total returns the value of the "goalsForMinute61To75Total" field in the mutation.
func (m *TSGoalsMutation) GoalsForMinute61To75Total() (r int, exists bool) {
	v := m.goalsForMinute61To75Total
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsForMinute61To75Total returns the old "goalsForMinute61To75Total" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsForMinute61To75Total(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsForMinute61To75Total is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsForMinute61To75Total requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsForMinute61To75Total: %w", err)
	}
	return oldValue.GoalsForMinute61To75Total, nil
}

// AddGoalsForMinute61To75Total adds i to the "goalsForMinute61To75Total" field.
func (m *TSGoalsMutation) AddGoalsForMinute61To75Total(i int) {
	if m.addgoalsForMinute61To75Total != nil {
		*m.addgoalsForMinute61To75Total += i
	} else {
		m.addgoalsForMinute61To75Total = &i
	}
}

// AddedGoalsForMinute61To75Total returns the value that was added to the "goalsForMinute61To75Total" field in this mutation.
func (m *TSGoalsMutation) AddedGoalsForMinute61To75Total() (r int, exists bool) {
	v := m.addgoalsForMinute61To75Total
	if v == nil {
		return
	}
	return *v, true
}

// ClearGoalsForMinute61To75Total clears the value of the "goalsForMinute61To75Total" field.
func (m *TSGoalsMutation) ClearGoalsForMinute61To75Total() {
	m.goalsForMinute61To75Total = nil
	m.addgoalsForMinute61To75Total = nil
	m.clearedFields[tsgoals.FieldGoalsForMinute61To75Total] = struct{}{}
}

// GoalsForMinute61To75TotalCleared returns if the "goalsForMinute61To75Total" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsForMinute61To75TotalCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsForMinute61To75Total]
	return ok
}

// ResetGoalsForMinute61To75Total resets all changes to the "goalsForMinute61To75Total" field.
func (m *TSGoalsMutation) ResetGoalsForMinute61To75Total() {
	m.goalsForMinute61To75Total = nil
	m.addgoalsForMinute61To75Total = nil
	delete(m.clearedFields, tsgoals.FieldGoalsForMinute61To75Total)
}

// SetGoalsForMinute61To75Percentage sets the "goalsForMinute61To75Percentage" field.
func (m *TSGoalsMutation) SetGoalsForMinute61To75Percentage(s string) {
	m.goalsForMinute61To75Percentage = &s
}

// GoalsForMinute61To75Percentage returns the value of the "goalsForMinute61To75Percentage" field in the mutation.
func (m *TSGoalsMutation) GoalsForMinute61To75Percentage() (r string, exists bool) {
	v := m.goalsForMinute61To75Percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsForMinute61To75Percentage returns the old "goalsForMinute61To75Percentage" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsForMinute61To75Percentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsForMinute61To75Percentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsForMinute61To75Percentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsForMinute61To75Percentage: %w", err)
	}
	return oldValue.GoalsForMinute61To75Percentage, nil
}

// ClearGoalsForMinute61To75Percentage clears the value of the "goalsForMinute61To75Percentage" field.
func (m *TSGoalsMutation) ClearGoalsForMinute61To75Percentage() {
	m.goalsForMinute61To75Percentage = nil
	m.clearedFields[tsgoals.FieldGoalsForMinute61To75Percentage] = struct{}{}
}

// GoalsForMinute61To75PercentageCleared returns if the "goalsForMinute61To75Percentage" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsForMinute61To75PercentageCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsForMinute61To75Percentage]
	return ok
}

// ResetGoalsForMinute61To75Percentage resets all changes to the "goalsForMinute61To75Percentage" field.
func (m *TSGoalsMutation) ResetGoalsForMinute61To75Percentage() {
	m.goalsForMinute61To75Percentage = nil
	delete(m.clearedFields, tsgoals.FieldGoalsForMinute61To75Percentage)
}

// SetGoalsForMinute76To90Total sets the "goalsForMinute76To90Total" field.
func (m *TSGoalsMutation) SetGoalsForMinute76To90Total(i int) {
	m.goalsForMinute76To90Total = &i
	m.addgoalsForMinute76To90Total = nil
}

// GoalsForMinute76To90Total returns the value of the "goalsForMinute76To90Total" field in the mutation.
func (m *TSGoalsMutation) GoalsForMinute76To90Total() (r int, exists bool) {
	v := m.goalsForMinute76To90Total
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsForMinute76To90Total returns the old "goalsForMinute76To90Total" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsForMinute76To90Total(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsForMinute76To90Total is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsForMinute76To90Total requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsForMinute76To90Total: %w", err)
	}
	return oldValue.GoalsForMinute76To90Total, nil
}

// AddGoalsForMinute76To90Total adds i to the "goalsForMinute76To90Total" field.
func (m *TSGoalsMutation) AddGoalsForMinute76To90Total(i int) {
	if m.addgoalsForMinute76To90Total != nil {
		*m.addgoalsForMinute76To90Total += i
	} else {
		m.addgoalsForMinute76To90Total = &i
	}
}

// AddedGoalsForMinute76To90Total returns the value that was added to the "goalsForMinute76To90Total" field in this mutation.
func (m *TSGoalsMutation) AddedGoalsForMinute76To90Total() (r int, exists bool) {
	v := m.addgoalsForMinute76To90Total
	if v == nil {
		return
	}
	return *v, true
}

// ClearGoalsForMinute76To90Total clears the value of the "goalsForMinute76To90Total" field.
func (m *TSGoalsMutation) ClearGoalsForMinute76To90Total() {
	m.goalsForMinute76To90Total = nil
	m.addgoalsForMinute76To90Total = nil
	m.clearedFields[tsgoals.FieldGoalsForMinute76To90Total] = struct{}{}
}

// GoalsForMinute76To90TotalCleared returns if the "goalsForMinute76To90Total" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsForMinute76To90TotalCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsForMinute76To90Total]
	return ok
}

// ResetGoalsForMinute76To90Total resets all changes to the "goalsForMinute76To90Total" field.
func (m *TSGoalsMutation) ResetGoalsForMinute76To90Total() {
	m.goalsForMinute76To90Total = nil
	m.addgoalsForMinute76To90Total = nil
	delete(m.clearedFields, tsgoals.FieldGoalsForMinute76To90Total)
}

// SetGoalsForMinute76To90Percentage sets the "goalsForMinute76To90Percentage" field.
func (m *TSGoalsMutation) SetGoalsForMinute76To90Percentage(s string) {
	m.goalsForMinute76To90Percentage = &s
}

// GoalsForMinute76To90Percentage returns the value of the "goalsForMinute76To90Percentage" field in the mutation.
func (m *TSGoalsMutation) GoalsForMinute76To90Percentage() (r string, exists bool) {
	v := m.goalsForMinute76To90Percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsForMinute76To90Percentage returns the old "goalsForMinute76To90Percentage" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsForMinute76To90Percentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsForMinute76To90Percentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsForMinute76To90Percentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsForMinute76To90Percentage: %w", err)
	}
	return oldValue.GoalsForMinute76To90Percentage, nil
}

// ClearGoalsForMinute76To90Percentage clears the value of the "goalsForMinute76To90Percentage" field.
func (m *TSGoalsMutation) ClearGoalsForMinute76To90Percentage() {
	m.goalsForMinute76To90Percentage = nil
	m.clearedFields[tsgoals.FieldGoalsForMinute76To90Percentage] = struct{}{}
}

// GoalsForMinute76To90PercentageCleared returns if the "goalsForMinute76To90Percentage" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsForMinute76To90PercentageCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsForMinute76To90Percentage]
	return ok
}

// ResetGoalsForMinute76To90Percentage resets all changes to the "goalsForMinute76To90Percentage" field.
func (m *TSGoalsMutation) ResetGoalsForMinute76To90Percentage() {
	m.goalsForMinute76To90Percentage = nil
	delete(m.clearedFields, tsgoals.FieldGoalsForMinute76To90Percentage)
}

// SetGoalsForMinute91To105Total sets the "goalsForMinute91To105Total" field.
func (m *TSGoalsMutation) SetGoalsForMinute91To105Total(i int) {
	m.goalsForMinute91To105Total = &i
	m.addgoalsForMinute91To105Total = nil
}

// GoalsForMinute91To105Total returns the value of the "goalsForMinute91To105Total" field in the mutation.
func (m *TSGoalsMutation) GoalsForMinute91To105Total() (r int, exists bool) {
	v := m.goalsForMinute91To105Total
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsForMinute91To105Total returns the old "goalsForMinute91To105Total" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsForMinute91To105Total(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsForMinute91To105Total is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsForMinute91To105Total requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsForMinute91To105Total: %w", err)
	}
	return oldValue.GoalsForMinute91To105Total, nil
}

// AddGoalsForMinute91To105Total adds i to the "goalsForMinute91To105Total" field.
func (m *TSGoalsMutation) AddGoalsForMinute91To105Total(i int) {
	if m.addgoalsForMinute91To105Total != nil {
		*m.addgoalsForMinute91To105Total += i
	} else {
		m.addgoalsForMinute91To105Total = &i
	}
}

// AddedGoalsForMinute91To105Total returns the value that was added to the "goalsForMinute91To105Total" field in this mutation.
func (m *TSGoalsMutation) AddedGoalsForMinute91To105Total() (r int, exists bool) {
	v := m.addgoalsForMinute91To105Total
	if v == nil {
		return
	}
	return *v, true
}

// ClearGoalsForMinute91To105Total clears the value of the "goalsForMinute91To105Total" field.
func (m *TSGoalsMutation) ClearGoalsForMinute91To105Total() {
	m.goalsForMinute91To105Total = nil
	m.addgoalsForMinute91To105Total = nil
	m.clearedFields[tsgoals.FieldGoalsForMinute91To105Total] = struct{}{}
}

// GoalsForMinute91To105TotalCleared returns if the "goalsForMinute91To105Total" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsForMinute91To105TotalCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsForMinute91To105Total]
	return ok
}

// ResetGoalsForMinute91To105Total resets all changes to the "goalsForMinute91To105Total" field.
func (m *TSGoalsMutation) ResetGoalsForMinute91To105Total() {
	m.goalsForMinute91To105Total = nil
	m.addgoalsForMinute91To105Total = nil
	delete(m.clearedFields, tsgoals.FieldGoalsForMinute91To105Total)
}

// SetGoalsForMinute91To105Percentage sets the "goalsForMinute91To105Percentage" field.
func (m *TSGoalsMutation) SetGoalsForMinute91To105Percentage(s string) {
	m.goalsForMinute91To105Percentage = &s
}

// GoalsForMinute91To105Percentage returns the value of the "goalsForMinute91To105Percentage" field in the mutation.
func (m *TSGoalsMutation) GoalsForMinute91To105Percentage() (r string, exists bool) {
	v := m.goalsForMinute91To105Percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsForMinute91To105Percentage returns the old "goalsForMinute91To105Percentage" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsForMinute91To105Percentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsForMinute91To105Percentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsForMinute91To105Percentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsForMinute91To105Percentage: %w", err)
	}
	return oldValue.GoalsForMinute91To105Percentage, nil
}

// ClearGoalsForMinute91To105Percentage clears the value of the "goalsForMinute91To105Percentage" field.
func (m *TSGoalsMutation) ClearGoalsForMinute91To105Percentage() {
	m.goalsForMinute91To105Percentage = nil
	m.clearedFields[tsgoals.FieldGoalsForMinute91To105Percentage] = struct{}{}
}

// GoalsForMinute91To105PercentageCleared returns if the "goalsForMinute91To105Percentage" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsForMinute91To105PercentageCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsForMinute91To105Percentage]
	return ok
}

// ResetGoalsForMinute91To105Percentage resets all changes to the "goalsForMinute91To105Percentage" field.
func (m *TSGoalsMutation) ResetGoalsForMinute91To105Percentage() {
	m.goalsForMinute91To105Percentage = nil
	delete(m.clearedFields, tsgoals.FieldGoalsForMinute91To105Percentage)
}

// SetGoalsForMinute106To120Total sets the "goalsForMinute106To120Total" field.
func (m *TSGoalsMutation) SetGoalsForMinute106To120Total(i int) {
	m.goalsForMinute106To120Total = &i
	m.addgoalsForMinute106To120Total = nil
}

// GoalsForMinute106To120Total returns the value of the "goalsForMinute106To120Total" field in the mutation.
func (m *TSGoalsMutation) GoalsForMinute106To120Total() (r int, exists bool) {
	v := m.goalsForMinute106To120Total
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsForMinute106To120Total returns the old "goalsForMinute106To120Total" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsForMinute106To120Total(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsForMinute106To120Total is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsForMinute106To120Total requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsForMinute106To120Total: %w", err)
	}
	return oldValue.GoalsForMinute106To120Total, nil
}

// AddGoalsForMinute106To120Total adds i to the "goalsForMinute106To120Total" field.
func (m *TSGoalsMutation) AddGoalsForMinute106To120Total(i int) {
	if m.addgoalsForMinute106To120Total != nil {
		*m.addgoalsForMinute106To120Total += i
	} else {
		m.addgoalsForMinute106To120Total = &i
	}
}

// AddedGoalsForMinute106To120Total returns the value that was added to the "goalsForMinute106To120Total" field in this mutation.
func (m *TSGoalsMutation) AddedGoalsForMinute106To120Total() (r int, exists bool) {
	v := m.addgoalsForMinute106To120Total
	if v == nil {
		return
	}
	return *v, true
}

// ClearGoalsForMinute106To120Total clears the value of the "goalsForMinute106To120Total" field.
func (m *TSGoalsMutation) ClearGoalsForMinute106To120Total() {
	m.goalsForMinute106To120Total = nil
	m.addgoalsForMinute106To120Total = nil
	m.clearedFields[tsgoals.FieldGoalsForMinute106To120Total] = struct{}{}
}

// GoalsForMinute106To120TotalCleared returns if the "goalsForMinute106To120Total" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsForMinute106To120TotalCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsForMinute106To120Total]
	return ok
}

// ResetGoalsForMinute106To120Total resets all changes to the "goalsForMinute106To120Total" field.
func (m *TSGoalsMutation) ResetGoalsForMinute106To120Total() {
	m.goalsForMinute106To120Total = nil
	m.addgoalsForMinute106To120Total = nil
	delete(m.clearedFields, tsgoals.FieldGoalsForMinute106To120Total)
}

// SetGoalsForMinute106To120Percentage sets the "goalsForMinute106To120Percentage" field.
func (m *TSGoalsMutation) SetGoalsForMinute106To120Percentage(s string) {
	m.goalsForMinute106To120Percentage = &s
}

// GoalsForMinute106To120Percentage returns the value of the "goalsForMinute106To120Percentage" field in the mutation.
func (m *TSGoalsMutation) GoalsForMinute106To120Percentage() (r string, exists bool) {
	v := m.goalsForMinute106To120Percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsForMinute106To120Percentage returns the old "goalsForMinute106To120Percentage" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsForMinute106To120Percentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsForMinute106To120Percentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsForMinute106To120Percentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsForMinute106To120Percentage: %w", err)
	}
	return oldValue.GoalsForMinute106To120Percentage, nil
}

// ClearGoalsForMinute106To120Percentage clears the value of the "goalsForMinute106To120Percentage" field.
func (m *TSGoalsMutation) ClearGoalsForMinute106To120Percentage() {
	m.goalsForMinute106To120Percentage = nil
	m.clearedFields[tsgoals.FieldGoalsForMinute106To120Percentage] = struct{}{}
}

// GoalsForMinute106To120PercentageCleared returns if the "goalsForMinute106To120Percentage" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsForMinute106To120PercentageCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsForMinute106To120Percentage]
	return ok
}

// ResetGoalsForMinute106To120Percentage resets all changes to the "goalsForMinute106To120Percentage" field.
func (m *TSGoalsMutation) ResetGoalsForMinute106To120Percentage() {
	m.goalsForMinute106To120Percentage = nil
	delete(m.clearedFields, tsgoals.FieldGoalsForMinute106To120Percentage)
}

// SetGoalsAgainstTotalHome sets the "goalsAgainstTotalHome" field.
func (m *TSGoalsMutation) SetGoalsAgainstTotalHome(i int) {
	m.goalsAgainstTotalHome = &i
	m.addgoalsAgainstTotalHome = nil
}

// GoalsAgainstTotalHome returns the value of the "goalsAgainstTotalHome" field in the mutation.
func (m *TSGoalsMutation) GoalsAgainstTotalHome() (r int, exists bool) {
	v := m.goalsAgainstTotalHome
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsAgainstTotalHome returns the old "goalsAgainstTotalHome" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsAgainstTotalHome(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsAgainstTotalHome is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsAgainstTotalHome requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsAgainstTotalHome: %w", err)
	}
	return oldValue.GoalsAgainstTotalHome, nil
}

// AddGoalsAgainstTotalHome adds i to the "goalsAgainstTotalHome" field.
func (m *TSGoalsMutation) AddGoalsAgainstTotalHome(i int) {
	if m.addgoalsAgainstTotalHome != nil {
		*m.addgoalsAgainstTotalHome += i
	} else {
		m.addgoalsAgainstTotalHome = &i
	}
}

// AddedGoalsAgainstTotalHome returns the value that was added to the "goalsAgainstTotalHome" field in this mutation.
func (m *TSGoalsMutation) AddedGoalsAgainstTotalHome() (r int, exists bool) {
	v := m.addgoalsAgainstTotalHome
	if v == nil {
		return
	}
	return *v, true
}

// ClearGoalsAgainstTotalHome clears the value of the "goalsAgainstTotalHome" field.
func (m *TSGoalsMutation) ClearGoalsAgainstTotalHome() {
	m.goalsAgainstTotalHome = nil
	m.addgoalsAgainstTotalHome = nil
	m.clearedFields[tsgoals.FieldGoalsAgainstTotalHome] = struct{}{}
}

// GoalsAgainstTotalHomeCleared returns if the "goalsAgainstTotalHome" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsAgainstTotalHomeCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsAgainstTotalHome]
	return ok
}

// ResetGoalsAgainstTotalHome resets all changes to the "goalsAgainstTotalHome" field.
func (m *TSGoalsMutation) ResetGoalsAgainstTotalHome() {
	m.goalsAgainstTotalHome = nil
	m.addgoalsAgainstTotalHome = nil
	delete(m.clearedFields, tsgoals.FieldGoalsAgainstTotalHome)
}

// SetGoalsAgainstTotalAway sets the "goalsAgainstTotalAway" field.
func (m *TSGoalsMutation) SetGoalsAgainstTotalAway(i int) {
	m.goalsAgainstTotalAway = &i
	m.addgoalsAgainstTotalAway = nil
}

// GoalsAgainstTotalAway returns the value of the "goalsAgainstTotalAway" field in the mutation.
func (m *TSGoalsMutation) GoalsAgainstTotalAway() (r int, exists bool) {
	v := m.goalsAgainstTotalAway
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsAgainstTotalAway returns the old "goalsAgainstTotalAway" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsAgainstTotalAway(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsAgainstTotalAway is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsAgainstTotalAway requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsAgainstTotalAway: %w", err)
	}
	return oldValue.GoalsAgainstTotalAway, nil
}

// AddGoalsAgainstTotalAway adds i to the "goalsAgainstTotalAway" field.
func (m *TSGoalsMutation) AddGoalsAgainstTotalAway(i int) {
	if m.addgoalsAgainstTotalAway != nil {
		*m.addgoalsAgainstTotalAway += i
	} else {
		m.addgoalsAgainstTotalAway = &i
	}
}

// AddedGoalsAgainstTotalAway returns the value that was added to the "goalsAgainstTotalAway" field in this mutation.
func (m *TSGoalsMutation) AddedGoalsAgainstTotalAway() (r int, exists bool) {
	v := m.addgoalsAgainstTotalAway
	if v == nil {
		return
	}
	return *v, true
}

// ClearGoalsAgainstTotalAway clears the value of the "goalsAgainstTotalAway" field.
func (m *TSGoalsMutation) ClearGoalsAgainstTotalAway() {
	m.goalsAgainstTotalAway = nil
	m.addgoalsAgainstTotalAway = nil
	m.clearedFields[tsgoals.FieldGoalsAgainstTotalAway] = struct{}{}
}

// GoalsAgainstTotalAwayCleared returns if the "goalsAgainstTotalAway" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsAgainstTotalAwayCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsAgainstTotalAway]
	return ok
}

// ResetGoalsAgainstTotalAway resets all changes to the "goalsAgainstTotalAway" field.
func (m *TSGoalsMutation) ResetGoalsAgainstTotalAway() {
	m.goalsAgainstTotalAway = nil
	m.addgoalsAgainstTotalAway = nil
	delete(m.clearedFields, tsgoals.FieldGoalsAgainstTotalAway)
}

// SetGoalsAgainstTotal sets the "goalsAgainstTotal" field.
func (m *TSGoalsMutation) SetGoalsAgainstTotal(i int) {
	m.goalsAgainstTotal = &i
	m.addgoalsAgainstTotal = nil
}

// GoalsAgainstTotal returns the value of the "goalsAgainstTotal" field in the mutation.
func (m *TSGoalsMutation) GoalsAgainstTotal() (r int, exists bool) {
	v := m.goalsAgainstTotal
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsAgainstTotal returns the old "goalsAgainstTotal" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsAgainstTotal(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsAgainstTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsAgainstTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsAgainstTotal: %w", err)
	}
	return oldValue.GoalsAgainstTotal, nil
}

// AddGoalsAgainstTotal adds i to the "goalsAgainstTotal" field.
func (m *TSGoalsMutation) AddGoalsAgainstTotal(i int) {
	if m.addgoalsAgainstTotal != nil {
		*m.addgoalsAgainstTotal += i
	} else {
		m.addgoalsAgainstTotal = &i
	}
}

// AddedGoalsAgainstTotal returns the value that was added to the "goalsAgainstTotal" field in this mutation.
func (m *TSGoalsMutation) AddedGoalsAgainstTotal() (r int, exists bool) {
	v := m.addgoalsAgainstTotal
	if v == nil {
		return
	}
	return *v, true
}

// ClearGoalsAgainstTotal clears the value of the "goalsAgainstTotal" field.
func (m *TSGoalsMutation) ClearGoalsAgainstTotal() {
	m.goalsAgainstTotal = nil
	m.addgoalsAgainstTotal = nil
	m.clearedFields[tsgoals.FieldGoalsAgainstTotal] = struct{}{}
}

// GoalsAgainstTotalCleared returns if the "goalsAgainstTotal" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsAgainstTotalCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsAgainstTotal]
	return ok
}

// ResetGoalsAgainstTotal resets all changes to the "goalsAgainstTotal" field.
func (m *TSGoalsMutation) ResetGoalsAgainstTotal() {
	m.goalsAgainstTotal = nil
	m.addgoalsAgainstTotal = nil
	delete(m.clearedFields, tsgoals.FieldGoalsAgainstTotal)
}

// SetGoalsAgainstAverageHome sets the "goalsAgainstAverageHome" field.
func (m *TSGoalsMutation) SetGoalsAgainstAverageHome(s string) {
	m.goalsAgainstAverageHome = &s
}

// GoalsAgainstAverageHome returns the value of the "goalsAgainstAverageHome" field in the mutation.
func (m *TSGoalsMutation) GoalsAgainstAverageHome() (r string, exists bool) {
	v := m.goalsAgainstAverageHome
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsAgainstAverageHome returns the old "goalsAgainstAverageHome" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsAgainstAverageHome(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsAgainstAverageHome is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsAgainstAverageHome requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsAgainstAverageHome: %w", err)
	}
	return oldValue.GoalsAgainstAverageHome, nil
}

// ClearGoalsAgainstAverageHome clears the value of the "goalsAgainstAverageHome" field.
func (m *TSGoalsMutation) ClearGoalsAgainstAverageHome() {
	m.goalsAgainstAverageHome = nil
	m.clearedFields[tsgoals.FieldGoalsAgainstAverageHome] = struct{}{}
}

// GoalsAgainstAverageHomeCleared returns if the "goalsAgainstAverageHome" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsAgainstAverageHomeCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsAgainstAverageHome]
	return ok
}

// ResetGoalsAgainstAverageHome resets all changes to the "goalsAgainstAverageHome" field.
func (m *TSGoalsMutation) ResetGoalsAgainstAverageHome() {
	m.goalsAgainstAverageHome = nil
	delete(m.clearedFields, tsgoals.FieldGoalsAgainstAverageHome)
}

// SetGoalsAgainstAverageAway sets the "goalsAgainstAverageAway" field.
func (m *TSGoalsMutation) SetGoalsAgainstAverageAway(s string) {
	m.goalsAgainstAverageAway = &s
}

// GoalsAgainstAverageAway returns the value of the "goalsAgainstAverageAway" field in the mutation.
func (m *TSGoalsMutation) GoalsAgainstAverageAway() (r string, exists bool) {
	v := m.goalsAgainstAverageAway
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsAgainstAverageAway returns the old "goalsAgainstAverageAway" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsAgainstAverageAway(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsAgainstAverageAway is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsAgainstAverageAway requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsAgainstAverageAway: %w", err)
	}
	return oldValue.GoalsAgainstAverageAway, nil
}

// ClearGoalsAgainstAverageAway clears the value of the "goalsAgainstAverageAway" field.
func (m *TSGoalsMutation) ClearGoalsAgainstAverageAway() {
	m.goalsAgainstAverageAway = nil
	m.clearedFields[tsgoals.FieldGoalsAgainstAverageAway] = struct{}{}
}

// GoalsAgainstAverageAwayCleared returns if the "goalsAgainstAverageAway" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsAgainstAverageAwayCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsAgainstAverageAway]
	return ok
}

// ResetGoalsAgainstAverageAway resets all changes to the "goalsAgainstAverageAway" field.
func (m *TSGoalsMutation) ResetGoalsAgainstAverageAway() {
	m.goalsAgainstAverageAway = nil
	delete(m.clearedFields, tsgoals.FieldGoalsAgainstAverageAway)
}

// SetGoalsAgainstAverageTotal sets the "goalsAgainstAverageTotal" field.
func (m *TSGoalsMutation) SetGoalsAgainstAverageTotal(s string) {
	m.goalsAgainstAverageTotal = &s
}

// GoalsAgainstAverageTotal returns the value of the "goalsAgainstAverageTotal" field in the mutation.
func (m *TSGoalsMutation) GoalsAgainstAverageTotal() (r string, exists bool) {
	v := m.goalsAgainstAverageTotal
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsAgainstAverageTotal returns the old "goalsAgainstAverageTotal" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsAgainstAverageTotal(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsAgainstAverageTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsAgainstAverageTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsAgainstAverageTotal: %w", err)
	}
	return oldValue.GoalsAgainstAverageTotal, nil
}

// ClearGoalsAgainstAverageTotal clears the value of the "goalsAgainstAverageTotal" field.
func (m *TSGoalsMutation) ClearGoalsAgainstAverageTotal() {
	m.goalsAgainstAverageTotal = nil
	m.clearedFields[tsgoals.FieldGoalsAgainstAverageTotal] = struct{}{}
}

// GoalsAgainstAverageTotalCleared returns if the "goalsAgainstAverageTotal" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsAgainstAverageTotalCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsAgainstAverageTotal]
	return ok
}

// ResetGoalsAgainstAverageTotal resets all changes to the "goalsAgainstAverageTotal" field.
func (m *TSGoalsMutation) ResetGoalsAgainstAverageTotal() {
	m.goalsAgainstAverageTotal = nil
	delete(m.clearedFields, tsgoals.FieldGoalsAgainstAverageTotal)
}

// SetGoalsAgainstMinute0To15Total sets the "goalsAgainstMinute0To15Total" field.
func (m *TSGoalsMutation) SetGoalsAgainstMinute0To15Total(i int) {
	m.goalsAgainstMinute0To15Total = &i
	m.addgoalsAgainstMinute0To15Total = nil
}

// GoalsAgainstMinute0To15Total returns the value of the "goalsAgainstMinute0To15Total" field in the mutation.
func (m *TSGoalsMutation) GoalsAgainstMinute0To15Total() (r int, exists bool) {
	v := m.goalsAgainstMinute0To15Total
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsAgainstMinute0To15Total returns the old "goalsAgainstMinute0To15Total" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsAgainstMinute0To15Total(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsAgainstMinute0To15Total is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsAgainstMinute0To15Total requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsAgainstMinute0To15Total: %w", err)
	}
	return oldValue.GoalsAgainstMinute0To15Total, nil
}

// AddGoalsAgainstMinute0To15Total adds i to the "goalsAgainstMinute0To15Total" field.
func (m *TSGoalsMutation) AddGoalsAgainstMinute0To15Total(i int) {
	if m.addgoalsAgainstMinute0To15Total != nil {
		*m.addgoalsAgainstMinute0To15Total += i
	} else {
		m.addgoalsAgainstMinute0To15Total = &i
	}
}

// AddedGoalsAgainstMinute0To15Total returns the value that was added to the "goalsAgainstMinute0To15Total" field in this mutation.
func (m *TSGoalsMutation) AddedGoalsAgainstMinute0To15Total() (r int, exists bool) {
	v := m.addgoalsAgainstMinute0To15Total
	if v == nil {
		return
	}
	return *v, true
}

// ClearGoalsAgainstMinute0To15Total clears the value of the "goalsAgainstMinute0To15Total" field.
func (m *TSGoalsMutation) ClearGoalsAgainstMinute0To15Total() {
	m.goalsAgainstMinute0To15Total = nil
	m.addgoalsAgainstMinute0To15Total = nil
	m.clearedFields[tsgoals.FieldGoalsAgainstMinute0To15Total] = struct{}{}
}

// GoalsAgainstMinute0To15TotalCleared returns if the "goalsAgainstMinute0To15Total" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsAgainstMinute0To15TotalCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsAgainstMinute0To15Total]
	return ok
}

// ResetGoalsAgainstMinute0To15Total resets all changes to the "goalsAgainstMinute0To15Total" field.
func (m *TSGoalsMutation) ResetGoalsAgainstMinute0To15Total() {
	m.goalsAgainstMinute0To15Total = nil
	m.addgoalsAgainstMinute0To15Total = nil
	delete(m.clearedFields, tsgoals.FieldGoalsAgainstMinute0To15Total)
}

// SetGoalsAgainstMinute0To15Percentage sets the "goalsAgainstMinute0To15Percentage" field.
func (m *TSGoalsMutation) SetGoalsAgainstMinute0To15Percentage(s string) {
	m.goalsAgainstMinute0To15Percentage = &s
}

// GoalsAgainstMinute0To15Percentage returns the value of the "goalsAgainstMinute0To15Percentage" field in the mutation.
func (m *TSGoalsMutation) GoalsAgainstMinute0To15Percentage() (r string, exists bool) {
	v := m.goalsAgainstMinute0To15Percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsAgainstMinute0To15Percentage returns the old "goalsAgainstMinute0To15Percentage" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsAgainstMinute0To15Percentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsAgainstMinute0To15Percentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsAgainstMinute0To15Percentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsAgainstMinute0To15Percentage: %w", err)
	}
	return oldValue.GoalsAgainstMinute0To15Percentage, nil
}

// ClearGoalsAgainstMinute0To15Percentage clears the value of the "goalsAgainstMinute0To15Percentage" field.
func (m *TSGoalsMutation) ClearGoalsAgainstMinute0To15Percentage() {
	m.goalsAgainstMinute0To15Percentage = nil
	m.clearedFields[tsgoals.FieldGoalsAgainstMinute0To15Percentage] = struct{}{}
}

// GoalsAgainstMinute0To15PercentageCleared returns if the "goalsAgainstMinute0To15Percentage" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsAgainstMinute0To15PercentageCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsAgainstMinute0To15Percentage]
	return ok
}

// ResetGoalsAgainstMinute0To15Percentage resets all changes to the "goalsAgainstMinute0To15Percentage" field.
func (m *TSGoalsMutation) ResetGoalsAgainstMinute0To15Percentage() {
	m.goalsAgainstMinute0To15Percentage = nil
	delete(m.clearedFields, tsgoals.FieldGoalsAgainstMinute0To15Percentage)
}

// SetGoalsAgainstMinute16To30Total sets the "goalsAgainstMinute16To30Total" field.
func (m *TSGoalsMutation) SetGoalsAgainstMinute16To30Total(i int) {
	m.goalsAgainstMinute16To30Total = &i
	m.addgoalsAgainstMinute16To30Total = nil
}

// GoalsAgainstMinute16To30Total returns the value of the "goalsAgainstMinute16To30Total" field in the mutation.
func (m *TSGoalsMutation) GoalsAgainstMinute16To30Total() (r int, exists bool) {
	v := m.goalsAgainstMinute16To30Total
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsAgainstMinute16To30Total returns the old "goalsAgainstMinute16To30Total" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsAgainstMinute16To30Total(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsAgainstMinute16To30Total is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsAgainstMinute16To30Total requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsAgainstMinute16To30Total: %w", err)
	}
	return oldValue.GoalsAgainstMinute16To30Total, nil
}

// AddGoalsAgainstMinute16To30Total adds i to the "goalsAgainstMinute16To30Total" field.
func (m *TSGoalsMutation) AddGoalsAgainstMinute16To30Total(i int) {
	if m.addgoalsAgainstMinute16To30Total != nil {
		*m.addgoalsAgainstMinute16To30Total += i
	} else {
		m.addgoalsAgainstMinute16To30Total = &i
	}
}

// AddedGoalsAgainstMinute16To30Total returns the value that was added to the "goalsAgainstMinute16To30Total" field in this mutation.
func (m *TSGoalsMutation) AddedGoalsAgainstMinute16To30Total() (r int, exists bool) {
	v := m.addgoalsAgainstMinute16To30Total
	if v == nil {
		return
	}
	return *v, true
}

// ClearGoalsAgainstMinute16To30Total clears the value of the "goalsAgainstMinute16To30Total" field.
func (m *TSGoalsMutation) ClearGoalsAgainstMinute16To30Total() {
	m.goalsAgainstMinute16To30Total = nil
	m.addgoalsAgainstMinute16To30Total = nil
	m.clearedFields[tsgoals.FieldGoalsAgainstMinute16To30Total] = struct{}{}
}

// GoalsAgainstMinute16To30TotalCleared returns if the "goalsAgainstMinute16To30Total" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsAgainstMinute16To30TotalCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsAgainstMinute16To30Total]
	return ok
}

// ResetGoalsAgainstMinute16To30Total resets all changes to the "goalsAgainstMinute16To30Total" field.
func (m *TSGoalsMutation) ResetGoalsAgainstMinute16To30Total() {
	m.goalsAgainstMinute16To30Total = nil
	m.addgoalsAgainstMinute16To30Total = nil
	delete(m.clearedFields, tsgoals.FieldGoalsAgainstMinute16To30Total)
}

// SetGoalsAgainstMinute16To30Percentage sets the "goalsAgainstMinute16To30Percentage" field.
func (m *TSGoalsMutation) SetGoalsAgainstMinute16To30Percentage(s string) {
	m.goalsAgainstMinute16To30Percentage = &s
}

// GoalsAgainstMinute16To30Percentage returns the value of the "goalsAgainstMinute16To30Percentage" field in the mutation.
func (m *TSGoalsMutation) GoalsAgainstMinute16To30Percentage() (r string, exists bool) {
	v := m.goalsAgainstMinute16To30Percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsAgainstMinute16To30Percentage returns the old "goalsAgainstMinute16To30Percentage" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsAgainstMinute16To30Percentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsAgainstMinute16To30Percentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsAgainstMinute16To30Percentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsAgainstMinute16To30Percentage: %w", err)
	}
	return oldValue.GoalsAgainstMinute16To30Percentage, nil
}

// ClearGoalsAgainstMinute16To30Percentage clears the value of the "goalsAgainstMinute16To30Percentage" field.
func (m *TSGoalsMutation) ClearGoalsAgainstMinute16To30Percentage() {
	m.goalsAgainstMinute16To30Percentage = nil
	m.clearedFields[tsgoals.FieldGoalsAgainstMinute16To30Percentage] = struct{}{}
}

// GoalsAgainstMinute16To30PercentageCleared returns if the "goalsAgainstMinute16To30Percentage" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsAgainstMinute16To30PercentageCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsAgainstMinute16To30Percentage]
	return ok
}

// ResetGoalsAgainstMinute16To30Percentage resets all changes to the "goalsAgainstMinute16To30Percentage" field.
func (m *TSGoalsMutation) ResetGoalsAgainstMinute16To30Percentage() {
	m.goalsAgainstMinute16To30Percentage = nil
	delete(m.clearedFields, tsgoals.FieldGoalsAgainstMinute16To30Percentage)
}

// SetGoalsAgainstMinute31To45Total sets the "goalsAgainstMinute31To45Total" field.
func (m *TSGoalsMutation) SetGoalsAgainstMinute31To45Total(i int) {
	m.goalsAgainstMinute31To45Total = &i
	m.addgoalsAgainstMinute31To45Total = nil
}

// GoalsAgainstMinute31To45Total returns the value of the "goalsAgainstMinute31To45Total" field in the mutation.
func (m *TSGoalsMutation) GoalsAgainstMinute31To45Total() (r int, exists bool) {
	v := m.goalsAgainstMinute31To45Total
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsAgainstMinute31To45Total returns the old "goalsAgainstMinute31To45Total" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsAgainstMinute31To45Total(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsAgainstMinute31To45Total is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsAgainstMinute31To45Total requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsAgainstMinute31To45Total: %w", err)
	}
	return oldValue.GoalsAgainstMinute31To45Total, nil
}

// AddGoalsAgainstMinute31To45Total adds i to the "goalsAgainstMinute31To45Total" field.
func (m *TSGoalsMutation) AddGoalsAgainstMinute31To45Total(i int) {
	if m.addgoalsAgainstMinute31To45Total != nil {
		*m.addgoalsAgainstMinute31To45Total += i
	} else {
		m.addgoalsAgainstMinute31To45Total = &i
	}
}

// AddedGoalsAgainstMinute31To45Total returns the value that was added to the "goalsAgainstMinute31To45Total" field in this mutation.
func (m *TSGoalsMutation) AddedGoalsAgainstMinute31To45Total() (r int, exists bool) {
	v := m.addgoalsAgainstMinute31To45Total
	if v == nil {
		return
	}
	return *v, true
}

// ClearGoalsAgainstMinute31To45Total clears the value of the "goalsAgainstMinute31To45Total" field.
func (m *TSGoalsMutation) ClearGoalsAgainstMinute31To45Total() {
	m.goalsAgainstMinute31To45Total = nil
	m.addgoalsAgainstMinute31To45Total = nil
	m.clearedFields[tsgoals.FieldGoalsAgainstMinute31To45Total] = struct{}{}
}

// GoalsAgainstMinute31To45TotalCleared returns if the "goalsAgainstMinute31To45Total" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsAgainstMinute31To45TotalCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsAgainstMinute31To45Total]
	return ok
}

// ResetGoalsAgainstMinute31To45Total resets all changes to the "goalsAgainstMinute31To45Total" field.
func (m *TSGoalsMutation) ResetGoalsAgainstMinute31To45Total() {
	m.goalsAgainstMinute31To45Total = nil
	m.addgoalsAgainstMinute31To45Total = nil
	delete(m.clearedFields, tsgoals.FieldGoalsAgainstMinute31To45Total)
}

// SetGoalsAgainstMinute31To45Percentage sets the "goalsAgainstMinute31To45Percentage" field.
func (m *TSGoalsMutation) SetGoalsAgainstMinute31To45Percentage(s string) {
	m.goalsAgainstMinute31To45Percentage = &s
}

// GoalsAgainstMinute31To45Percentage returns the value of the "goalsAgainstMinute31To45Percentage" field in the mutation.
func (m *TSGoalsMutation) GoalsAgainstMinute31To45Percentage() (r string, exists bool) {
	v := m.goalsAgainstMinute31To45Percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsAgainstMinute31To45Percentage returns the old "goalsAgainstMinute31To45Percentage" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsAgainstMinute31To45Percentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsAgainstMinute31To45Percentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsAgainstMinute31To45Percentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsAgainstMinute31To45Percentage: %w", err)
	}
	return oldValue.GoalsAgainstMinute31To45Percentage, nil
}

// ClearGoalsAgainstMinute31To45Percentage clears the value of the "goalsAgainstMinute31To45Percentage" field.
func (m *TSGoalsMutation) ClearGoalsAgainstMinute31To45Percentage() {
	m.goalsAgainstMinute31To45Percentage = nil
	m.clearedFields[tsgoals.FieldGoalsAgainstMinute31To45Percentage] = struct{}{}
}

// GoalsAgainstMinute31To45PercentageCleared returns if the "goalsAgainstMinute31To45Percentage" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsAgainstMinute31To45PercentageCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsAgainstMinute31To45Percentage]
	return ok
}

// ResetGoalsAgainstMinute31To45Percentage resets all changes to the "goalsAgainstMinute31To45Percentage" field.
func (m *TSGoalsMutation) ResetGoalsAgainstMinute31To45Percentage() {
	m.goalsAgainstMinute31To45Percentage = nil
	delete(m.clearedFields, tsgoals.FieldGoalsAgainstMinute31To45Percentage)
}

// SetGoalsAgainstMinute46To60Total sets the "goalsAgainstMinute46To60Total" field.
func (m *TSGoalsMutation) SetGoalsAgainstMinute46To60Total(i int) {
	m.goalsAgainstMinute46To60Total = &i
	m.addgoalsAgainstMinute46To60Total = nil
}

// GoalsAgainstMinute46To60Total returns the value of the "goalsAgainstMinute46To60Total" field in the mutation.
func (m *TSGoalsMutation) GoalsAgainstMinute46To60Total() (r int, exists bool) {
	v := m.goalsAgainstMinute46To60Total
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsAgainstMinute46To60Total returns the old "goalsAgainstMinute46To60Total" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsAgainstMinute46To60Total(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsAgainstMinute46To60Total is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsAgainstMinute46To60Total requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsAgainstMinute46To60Total: %w", err)
	}
	return oldValue.GoalsAgainstMinute46To60Total, nil
}

// AddGoalsAgainstMinute46To60Total adds i to the "goalsAgainstMinute46To60Total" field.
func (m *TSGoalsMutation) AddGoalsAgainstMinute46To60Total(i int) {
	if m.addgoalsAgainstMinute46To60Total != nil {
		*m.addgoalsAgainstMinute46To60Total += i
	} else {
		m.addgoalsAgainstMinute46To60Total = &i
	}
}

// AddedGoalsAgainstMinute46To60Total returns the value that was added to the "goalsAgainstMinute46To60Total" field in this mutation.
func (m *TSGoalsMutation) AddedGoalsAgainstMinute46To60Total() (r int, exists bool) {
	v := m.addgoalsAgainstMinute46To60Total
	if v == nil {
		return
	}
	return *v, true
}

// ClearGoalsAgainstMinute46To60Total clears the value of the "goalsAgainstMinute46To60Total" field.
func (m *TSGoalsMutation) ClearGoalsAgainstMinute46To60Total() {
	m.goalsAgainstMinute46To60Total = nil
	m.addgoalsAgainstMinute46To60Total = nil
	m.clearedFields[tsgoals.FieldGoalsAgainstMinute46To60Total] = struct{}{}
}

// GoalsAgainstMinute46To60TotalCleared returns if the "goalsAgainstMinute46To60Total" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsAgainstMinute46To60TotalCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsAgainstMinute46To60Total]
	return ok
}

// ResetGoalsAgainstMinute46To60Total resets all changes to the "goalsAgainstMinute46To60Total" field.
func (m *TSGoalsMutation) ResetGoalsAgainstMinute46To60Total() {
	m.goalsAgainstMinute46To60Total = nil
	m.addgoalsAgainstMinute46To60Total = nil
	delete(m.clearedFields, tsgoals.FieldGoalsAgainstMinute46To60Total)
}

// SetGoalsAgainstMinute46To60Percentage sets the "goalsAgainstMinute46To60Percentage" field.
func (m *TSGoalsMutation) SetGoalsAgainstMinute46To60Percentage(s string) {
	m.goalsAgainstMinute46To60Percentage = &s
}

// GoalsAgainstMinute46To60Percentage returns the value of the "goalsAgainstMinute46To60Percentage" field in the mutation.
func (m *TSGoalsMutation) GoalsAgainstMinute46To60Percentage() (r string, exists bool) {
	v := m.goalsAgainstMinute46To60Percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsAgainstMinute46To60Percentage returns the old "goalsAgainstMinute46To60Percentage" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsAgainstMinute46To60Percentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsAgainstMinute46To60Percentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsAgainstMinute46To60Percentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsAgainstMinute46To60Percentage: %w", err)
	}
	return oldValue.GoalsAgainstMinute46To60Percentage, nil
}

// ClearGoalsAgainstMinute46To60Percentage clears the value of the "goalsAgainstMinute46To60Percentage" field.
func (m *TSGoalsMutation) ClearGoalsAgainstMinute46To60Percentage() {
	m.goalsAgainstMinute46To60Percentage = nil
	m.clearedFields[tsgoals.FieldGoalsAgainstMinute46To60Percentage] = struct{}{}
}

// GoalsAgainstMinute46To60PercentageCleared returns if the "goalsAgainstMinute46To60Percentage" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsAgainstMinute46To60PercentageCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsAgainstMinute46To60Percentage]
	return ok
}

// ResetGoalsAgainstMinute46To60Percentage resets all changes to the "goalsAgainstMinute46To60Percentage" field.
func (m *TSGoalsMutation) ResetGoalsAgainstMinute46To60Percentage() {
	m.goalsAgainstMinute46To60Percentage = nil
	delete(m.clearedFields, tsgoals.FieldGoalsAgainstMinute46To60Percentage)
}

// SetGoalsAgainstMinute61To75Total sets the "goalsAgainstMinute61To75Total" field.
func (m *TSGoalsMutation) SetGoalsAgainstMinute61To75Total(i int) {
	m.goalsAgainstMinute61To75Total = &i
	m.addgoalsAgainstMinute61To75Total = nil
}

// GoalsAgainstMinute61To75Total returns the value of the "goalsAgainstMinute61To75Total" field in the mutation.
func (m *TSGoalsMutation) GoalsAgainstMinute61To75Total() (r int, exists bool) {
	v := m.goalsAgainstMinute61To75Total
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsAgainstMinute61To75Total returns the old "goalsAgainstMinute61To75Total" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsAgainstMinute61To75Total(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsAgainstMinute61To75Total is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsAgainstMinute61To75Total requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsAgainstMinute61To75Total: %w", err)
	}
	return oldValue.GoalsAgainstMinute61To75Total, nil
}

// AddGoalsAgainstMinute61To75Total adds i to the "goalsAgainstMinute61To75Total" field.
func (m *TSGoalsMutation) AddGoalsAgainstMinute61To75Total(i int) {
	if m.addgoalsAgainstMinute61To75Total != nil {
		*m.addgoalsAgainstMinute61To75Total += i
	} else {
		m.addgoalsAgainstMinute61To75Total = &i
	}
}

// AddedGoalsAgainstMinute61To75Total returns the value that was added to the "goalsAgainstMinute61To75Total" field in this mutation.
func (m *TSGoalsMutation) AddedGoalsAgainstMinute61To75Total() (r int, exists bool) {
	v := m.addgoalsAgainstMinute61To75Total
	if v == nil {
		return
	}
	return *v, true
}

// ClearGoalsAgainstMinute61To75Total clears the value of the "goalsAgainstMinute61To75Total" field.
func (m *TSGoalsMutation) ClearGoalsAgainstMinute61To75Total() {
	m.goalsAgainstMinute61To75Total = nil
	m.addgoalsAgainstMinute61To75Total = nil
	m.clearedFields[tsgoals.FieldGoalsAgainstMinute61To75Total] = struct{}{}
}

// GoalsAgainstMinute61To75TotalCleared returns if the "goalsAgainstMinute61To75Total" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsAgainstMinute61To75TotalCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsAgainstMinute61To75Total]
	return ok
}

// ResetGoalsAgainstMinute61To75Total resets all changes to the "goalsAgainstMinute61To75Total" field.
func (m *TSGoalsMutation) ResetGoalsAgainstMinute61To75Total() {
	m.goalsAgainstMinute61To75Total = nil
	m.addgoalsAgainstMinute61To75Total = nil
	delete(m.clearedFields, tsgoals.FieldGoalsAgainstMinute61To75Total)
}

// SetGoalsAgainstMinute61To75Percentage sets the "goalsAgainstMinute61To75Percentage" field.
func (m *TSGoalsMutation) SetGoalsAgainstMinute61To75Percentage(s string) {
	m.goalsAgainstMinute61To75Percentage = &s
}

// GoalsAgainstMinute61To75Percentage returns the value of the "goalsAgainstMinute61To75Percentage" field in the mutation.
func (m *TSGoalsMutation) GoalsAgainstMinute61To75Percentage() (r string, exists bool) {
	v := m.goalsAgainstMinute61To75Percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsAgainstMinute61To75Percentage returns the old "goalsAgainstMinute61To75Percentage" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsAgainstMinute61To75Percentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsAgainstMinute61To75Percentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsAgainstMinute61To75Percentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsAgainstMinute61To75Percentage: %w", err)
	}
	return oldValue.GoalsAgainstMinute61To75Percentage, nil
}

// ClearGoalsAgainstMinute61To75Percentage clears the value of the "goalsAgainstMinute61To75Percentage" field.
func (m *TSGoalsMutation) ClearGoalsAgainstMinute61To75Percentage() {
	m.goalsAgainstMinute61To75Percentage = nil
	m.clearedFields[tsgoals.FieldGoalsAgainstMinute61To75Percentage] = struct{}{}
}

// GoalsAgainstMinute61To75PercentageCleared returns if the "goalsAgainstMinute61To75Percentage" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsAgainstMinute61To75PercentageCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsAgainstMinute61To75Percentage]
	return ok
}

// ResetGoalsAgainstMinute61To75Percentage resets all changes to the "goalsAgainstMinute61To75Percentage" field.
func (m *TSGoalsMutation) ResetGoalsAgainstMinute61To75Percentage() {
	m.goalsAgainstMinute61To75Percentage = nil
	delete(m.clearedFields, tsgoals.FieldGoalsAgainstMinute61To75Percentage)
}

// SetGoalsAgainstMinute76To90Total sets the "goalsAgainstMinute76To90Total" field.
func (m *TSGoalsMutation) SetGoalsAgainstMinute76To90Total(i int) {
	m.goalsAgainstMinute76To90Total = &i
	m.addgoalsAgainstMinute76To90Total = nil
}

// GoalsAgainstMinute76To90Total returns the value of the "goalsAgainstMinute76To90Total" field in the mutation.
func (m *TSGoalsMutation) GoalsAgainstMinute76To90Total() (r int, exists bool) {
	v := m.goalsAgainstMinute76To90Total
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsAgainstMinute76To90Total returns the old "goalsAgainstMinute76To90Total" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsAgainstMinute76To90Total(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsAgainstMinute76To90Total is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsAgainstMinute76To90Total requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsAgainstMinute76To90Total: %w", err)
	}
	return oldValue.GoalsAgainstMinute76To90Total, nil
}

// AddGoalsAgainstMinute76To90Total adds i to the "goalsAgainstMinute76To90Total" field.
func (m *TSGoalsMutation) AddGoalsAgainstMinute76To90Total(i int) {
	if m.addgoalsAgainstMinute76To90Total != nil {
		*m.addgoalsAgainstMinute76To90Total += i
	} else {
		m.addgoalsAgainstMinute76To90Total = &i
	}
}

// AddedGoalsAgainstMinute76To90Total returns the value that was added to the "goalsAgainstMinute76To90Total" field in this mutation.
func (m *TSGoalsMutation) AddedGoalsAgainstMinute76To90Total() (r int, exists bool) {
	v := m.addgoalsAgainstMinute76To90Total
	if v == nil {
		return
	}
	return *v, true
}

// ClearGoalsAgainstMinute76To90Total clears the value of the "goalsAgainstMinute76To90Total" field.
func (m *TSGoalsMutation) ClearGoalsAgainstMinute76To90Total() {
	m.goalsAgainstMinute76To90Total = nil
	m.addgoalsAgainstMinute76To90Total = nil
	m.clearedFields[tsgoals.FieldGoalsAgainstMinute76To90Total] = struct{}{}
}

// GoalsAgainstMinute76To90TotalCleared returns if the "goalsAgainstMinute76To90Total" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsAgainstMinute76To90TotalCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsAgainstMinute76To90Total]
	return ok
}

// ResetGoalsAgainstMinute76To90Total resets all changes to the "goalsAgainstMinute76To90Total" field.
func (m *TSGoalsMutation) ResetGoalsAgainstMinute76To90Total() {
	m.goalsAgainstMinute76To90Total = nil
	m.addgoalsAgainstMinute76To90Total = nil
	delete(m.clearedFields, tsgoals.FieldGoalsAgainstMinute76To90Total)
}

// SetGoalsAgainstMinute76To90Percentage sets the "goalsAgainstMinute76To90Percentage" field.
func (m *TSGoalsMutation) SetGoalsAgainstMinute76To90Percentage(s string) {
	m.goalsAgainstMinute76To90Percentage = &s
}

// GoalsAgainstMinute76To90Percentage returns the value of the "goalsAgainstMinute76To90Percentage" field in the mutation.
func (m *TSGoalsMutation) GoalsAgainstMinute76To90Percentage() (r string, exists bool) {
	v := m.goalsAgainstMinute76To90Percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsAgainstMinute76To90Percentage returns the old "goalsAgainstMinute76To90Percentage" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsAgainstMinute76To90Percentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsAgainstMinute76To90Percentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsAgainstMinute76To90Percentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsAgainstMinute76To90Percentage: %w", err)
	}
	return oldValue.GoalsAgainstMinute76To90Percentage, nil
}

// ClearGoalsAgainstMinute76To90Percentage clears the value of the "goalsAgainstMinute76To90Percentage" field.
func (m *TSGoalsMutation) ClearGoalsAgainstMinute76To90Percentage() {
	m.goalsAgainstMinute76To90Percentage = nil
	m.clearedFields[tsgoals.FieldGoalsAgainstMinute76To90Percentage] = struct{}{}
}

// GoalsAgainstMinute76To90PercentageCleared returns if the "goalsAgainstMinute76To90Percentage" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsAgainstMinute76To90PercentageCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsAgainstMinute76To90Percentage]
	return ok
}

// ResetGoalsAgainstMinute76To90Percentage resets all changes to the "goalsAgainstMinute76To90Percentage" field.
func (m *TSGoalsMutation) ResetGoalsAgainstMinute76To90Percentage() {
	m.goalsAgainstMinute76To90Percentage = nil
	delete(m.clearedFields, tsgoals.FieldGoalsAgainstMinute76To90Percentage)
}

// SetGoalsAgainstMinute91To105Total sets the "goalsAgainstMinute91To105Total" field.
func (m *TSGoalsMutation) SetGoalsAgainstMinute91To105Total(i int) {
	m.goalsAgainstMinute91To105Total = &i
	m.addgoalsAgainstMinute91To105Total = nil
}

// GoalsAgainstMinute91To105Total returns the value of the "goalsAgainstMinute91To105Total" field in the mutation.
func (m *TSGoalsMutation) GoalsAgainstMinute91To105Total() (r int, exists bool) {
	v := m.goalsAgainstMinute91To105Total
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsAgainstMinute91To105Total returns the old "goalsAgainstMinute91To105Total" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsAgainstMinute91To105Total(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsAgainstMinute91To105Total is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsAgainstMinute91To105Total requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsAgainstMinute91To105Total: %w", err)
	}
	return oldValue.GoalsAgainstMinute91To105Total, nil
}

// AddGoalsAgainstMinute91To105Total adds i to the "goalsAgainstMinute91To105Total" field.
func (m *TSGoalsMutation) AddGoalsAgainstMinute91To105Total(i int) {
	if m.addgoalsAgainstMinute91To105Total != nil {
		*m.addgoalsAgainstMinute91To105Total += i
	} else {
		m.addgoalsAgainstMinute91To105Total = &i
	}
}

// AddedGoalsAgainstMinute91To105Total returns the value that was added to the "goalsAgainstMinute91To105Total" field in this mutation.
func (m *TSGoalsMutation) AddedGoalsAgainstMinute91To105Total() (r int, exists bool) {
	v := m.addgoalsAgainstMinute91To105Total
	if v == nil {
		return
	}
	return *v, true
}

// ClearGoalsAgainstMinute91To105Total clears the value of the "goalsAgainstMinute91To105Total" field.
func (m *TSGoalsMutation) ClearGoalsAgainstMinute91To105Total() {
	m.goalsAgainstMinute91To105Total = nil
	m.addgoalsAgainstMinute91To105Total = nil
	m.clearedFields[tsgoals.FieldGoalsAgainstMinute91To105Total] = struct{}{}
}

// GoalsAgainstMinute91To105TotalCleared returns if the "goalsAgainstMinute91To105Total" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsAgainstMinute91To105TotalCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsAgainstMinute91To105Total]
	return ok
}

// ResetGoalsAgainstMinute91To105Total resets all changes to the "goalsAgainstMinute91To105Total" field.
func (m *TSGoalsMutation) ResetGoalsAgainstMinute91To105Total() {
	m.goalsAgainstMinute91To105Total = nil
	m.addgoalsAgainstMinute91To105Total = nil
	delete(m.clearedFields, tsgoals.FieldGoalsAgainstMinute91To105Total)
}

// SetGoalsAgainstMinute91To105Percentage sets the "goalsAgainstMinute91To105Percentage" field.
func (m *TSGoalsMutation) SetGoalsAgainstMinute91To105Percentage(s string) {
	m.goalsAgainstMinute91To105Percentage = &s
}

// GoalsAgainstMinute91To105Percentage returns the value of the "goalsAgainstMinute91To105Percentage" field in the mutation.
func (m *TSGoalsMutation) GoalsAgainstMinute91To105Percentage() (r string, exists bool) {
	v := m.goalsAgainstMinute91To105Percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsAgainstMinute91To105Percentage returns the old "goalsAgainstMinute91To105Percentage" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsAgainstMinute91To105Percentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsAgainstMinute91To105Percentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsAgainstMinute91To105Percentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsAgainstMinute91To105Percentage: %w", err)
	}
	return oldValue.GoalsAgainstMinute91To105Percentage, nil
}

// ClearGoalsAgainstMinute91To105Percentage clears the value of the "goalsAgainstMinute91To105Percentage" field.
func (m *TSGoalsMutation) ClearGoalsAgainstMinute91To105Percentage() {
	m.goalsAgainstMinute91To105Percentage = nil
	m.clearedFields[tsgoals.FieldGoalsAgainstMinute91To105Percentage] = struct{}{}
}

// GoalsAgainstMinute91To105PercentageCleared returns if the "goalsAgainstMinute91To105Percentage" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsAgainstMinute91To105PercentageCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsAgainstMinute91To105Percentage]
	return ok
}

// ResetGoalsAgainstMinute91To105Percentage resets all changes to the "goalsAgainstMinute91To105Percentage" field.
func (m *TSGoalsMutation) ResetGoalsAgainstMinute91To105Percentage() {
	m.goalsAgainstMinute91To105Percentage = nil
	delete(m.clearedFields, tsgoals.FieldGoalsAgainstMinute91To105Percentage)
}

// SetGoalsAgainstMinute106To120Total sets the "goalsAgainstMinute106To120Total" field.
func (m *TSGoalsMutation) SetGoalsAgainstMinute106To120Total(i int) {
	m.goalsAgainstMinute106To120Total = &i
	m.addgoalsAgainstMinute106To120Total = nil
}

// GoalsAgainstMinute106To120Total returns the value of the "goalsAgainstMinute106To120Total" field in the mutation.
func (m *TSGoalsMutation) GoalsAgainstMinute106To120Total() (r int, exists bool) {
	v := m.goalsAgainstMinute106To120Total
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsAgainstMinute106To120Total returns the old "goalsAgainstMinute106To120Total" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsAgainstMinute106To120Total(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsAgainstMinute106To120Total is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsAgainstMinute106To120Total requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsAgainstMinute106To120Total: %w", err)
	}
	return oldValue.GoalsAgainstMinute106To120Total, nil
}

// AddGoalsAgainstMinute106To120Total adds i to the "goalsAgainstMinute106To120Total" field.
func (m *TSGoalsMutation) AddGoalsAgainstMinute106To120Total(i int) {
	if m.addgoalsAgainstMinute106To120Total != nil {
		*m.addgoalsAgainstMinute106To120Total += i
	} else {
		m.addgoalsAgainstMinute106To120Total = &i
	}
}

// AddedGoalsAgainstMinute106To120Total returns the value that was added to the "goalsAgainstMinute106To120Total" field in this mutation.
func (m *TSGoalsMutation) AddedGoalsAgainstMinute106To120Total() (r int, exists bool) {
	v := m.addgoalsAgainstMinute106To120Total
	if v == nil {
		return
	}
	return *v, true
}

// ClearGoalsAgainstMinute106To120Total clears the value of the "goalsAgainstMinute106To120Total" field.
func (m *TSGoalsMutation) ClearGoalsAgainstMinute106To120Total() {
	m.goalsAgainstMinute106To120Total = nil
	m.addgoalsAgainstMinute106To120Total = nil
	m.clearedFields[tsgoals.FieldGoalsAgainstMinute106To120Total] = struct{}{}
}

// GoalsAgainstMinute106To120TotalCleared returns if the "goalsAgainstMinute106To120Total" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsAgainstMinute106To120TotalCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsAgainstMinute106To120Total]
	return ok
}

// ResetGoalsAgainstMinute106To120Total resets all changes to the "goalsAgainstMinute106To120Total" field.
func (m *TSGoalsMutation) ResetGoalsAgainstMinute106To120Total() {
	m.goalsAgainstMinute106To120Total = nil
	m.addgoalsAgainstMinute106To120Total = nil
	delete(m.clearedFields, tsgoals.FieldGoalsAgainstMinute106To120Total)
}

// SetGoalsAgainstMinute106To120Percentage sets the "goalsAgainstMinute106To120Percentage" field.
func (m *TSGoalsMutation) SetGoalsAgainstMinute106To120Percentage(s string) {
	m.goalsAgainstMinute106To120Percentage = &s
}

// GoalsAgainstMinute106To120Percentage returns the value of the "goalsAgainstMinute106To120Percentage" field in the mutation.
func (m *TSGoalsMutation) GoalsAgainstMinute106To120Percentage() (r string, exists bool) {
	v := m.goalsAgainstMinute106To120Percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsAgainstMinute106To120Percentage returns the old "goalsAgainstMinute106To120Percentage" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldGoalsAgainstMinute106To120Percentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsAgainstMinute106To120Percentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsAgainstMinute106To120Percentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsAgainstMinute106To120Percentage: %w", err)
	}
	return oldValue.GoalsAgainstMinute106To120Percentage, nil
}

// ClearGoalsAgainstMinute106To120Percentage clears the value of the "goalsAgainstMinute106To120Percentage" field.
func (m *TSGoalsMutation) ClearGoalsAgainstMinute106To120Percentage() {
	m.goalsAgainstMinute106To120Percentage = nil
	m.clearedFields[tsgoals.FieldGoalsAgainstMinute106To120Percentage] = struct{}{}
}

// GoalsAgainstMinute106To120PercentageCleared returns if the "goalsAgainstMinute106To120Percentage" field was cleared in this mutation.
func (m *TSGoalsMutation) GoalsAgainstMinute106To120PercentageCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldGoalsAgainstMinute106To120Percentage]
	return ok
}

// ResetGoalsAgainstMinute106To120Percentage resets all changes to the "goalsAgainstMinute106To120Percentage" field.
func (m *TSGoalsMutation) ResetGoalsAgainstMinute106To120Percentage() {
	m.goalsAgainstMinute106To120Percentage = nil
	delete(m.clearedFields, tsgoals.FieldGoalsAgainstMinute106To120Percentage)
}

// SetLastUpdated sets the "lastUpdated" field.
func (m *TSGoalsMutation) SetLastUpdated(t time.Time) {
	m.lastUpdated = &t
}

// LastUpdated returns the value of the "lastUpdated" field in the mutation.
func (m *TSGoalsMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.lastUpdated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "lastUpdated" field's value of the TSGoals entity.
// If the TSGoals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSGoalsMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ClearLastUpdated clears the value of the "lastUpdated" field.
func (m *TSGoalsMutation) ClearLastUpdated() {
	m.lastUpdated = nil
	m.clearedFields[tsgoals.FieldLastUpdated] = struct{}{}
}

// LastUpdatedCleared returns if the "lastUpdated" field was cleared in this mutation.
func (m *TSGoalsMutation) LastUpdatedCleared() bool {
	_, ok := m.clearedFields[tsgoals.FieldLastUpdated]
	return ok
}

// ResetLastUpdated resets all changes to the "lastUpdated" field.
func (m *TSGoalsMutation) ResetLastUpdated() {
	m.lastUpdated = nil
	delete(m.clearedFields, tsgoals.FieldLastUpdated)
}

// SetTeamID sets the "team" edge to the Team entity by id.
func (m *TSGoalsMutation) SetTeamID(id int) {
	m.team = &id
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *TSGoalsMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *TSGoalsMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamID returns the "team" edge ID in the mutation.
func (m *TSGoalsMutation) TeamID() (id int, exists bool) {
	if m.team != nil {
		return *m.team, true
	}
	return
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *TSGoalsMutation) TeamIDs() (ids []int) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *TSGoalsMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// Where appends a list predicates to the TSGoalsMutation builder.
func (m *TSGoalsMutation) Where(ps ...predicate.TSGoals) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TSGoalsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TSGoalsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TSGoals, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TSGoalsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TSGoalsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TSGoals).
func (m *TSGoalsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TSGoalsMutation) Fields() []string {
	fields := make([]string, 0, 45)
	if m.goalsForTotalHome != nil {
		fields = append(fields, tsgoals.FieldGoalsForTotalHome)
	}
	if m.goalsForTotalAway != nil {
		fields = append(fields, tsgoals.FieldGoalsForTotalAway)
	}
	if m.goalsForTotal != nil {
		fields = append(fields, tsgoals.FieldGoalsForTotal)
	}
	if m.goalsForAverageHome != nil {
		fields = append(fields, tsgoals.FieldGoalsForAverageHome)
	}
	if m.goalsForAverageAway != nil {
		fields = append(fields, tsgoals.FieldGoalsForAverageAway)
	}
	if m.goalsForAverageTotal != nil {
		fields = append(fields, tsgoals.FieldGoalsForAverageTotal)
	}
	if m.goalsForMinute0To15Total != nil {
		fields = append(fields, tsgoals.FieldGoalsForMinute0To15Total)
	}
	if m.goalsForMinute0To15Percentage != nil {
		fields = append(fields, tsgoals.FieldGoalsForMinute0To15Percentage)
	}
	if m.goalsForMinute16To30Total != nil {
		fields = append(fields, tsgoals.FieldGoalsForMinute16To30Total)
	}
	if m.goalsForMinute16To30Percentage != nil {
		fields = append(fields, tsgoals.FieldGoalsForMinute16To30Percentage)
	}
	if m.goalsForMinute31To45Total != nil {
		fields = append(fields, tsgoals.FieldGoalsForMinute31To45Total)
	}
	if m.goalsForMinute31To45Percentage != nil {
		fields = append(fields, tsgoals.FieldGoalsForMinute31To45Percentage)
	}
	if m.goalsForMinute46To60Total != nil {
		fields = append(fields, tsgoals.FieldGoalsForMinute46To60Total)
	}
	if m.goalsForMinute46To60Percentage != nil {
		fields = append(fields, tsgoals.FieldGoalsForMinute46To60Percentage)
	}
	if m.goalsForMinute61To75Total != nil {
		fields = append(fields, tsgoals.FieldGoalsForMinute61To75Total)
	}
	if m.goalsForMinute61To75Percentage != nil {
		fields = append(fields, tsgoals.FieldGoalsForMinute61To75Percentage)
	}
	if m.goalsForMinute76To90Total != nil {
		fields = append(fields, tsgoals.FieldGoalsForMinute76To90Total)
	}
	if m.goalsForMinute76To90Percentage != nil {
		fields = append(fields, tsgoals.FieldGoalsForMinute76To90Percentage)
	}
	if m.goalsForMinute91To105Total != nil {
		fields = append(fields, tsgoals.FieldGoalsForMinute91To105Total)
	}
	if m.goalsForMinute91To105Percentage != nil {
		fields = append(fields, tsgoals.FieldGoalsForMinute91To105Percentage)
	}
	if m.goalsForMinute106To120Total != nil {
		fields = append(fields, tsgoals.FieldGoalsForMinute106To120Total)
	}
	if m.goalsForMinute106To120Percentage != nil {
		fields = append(fields, tsgoals.FieldGoalsForMinute106To120Percentage)
	}
	if m.goalsAgainstTotalHome != nil {
		fields = append(fields, tsgoals.FieldGoalsAgainstTotalHome)
	}
	if m.goalsAgainstTotalAway != nil {
		fields = append(fields, tsgoals.FieldGoalsAgainstTotalAway)
	}
	if m.goalsAgainstTotal != nil {
		fields = append(fields, tsgoals.FieldGoalsAgainstTotal)
	}
	if m.goalsAgainstAverageHome != nil {
		fields = append(fields, tsgoals.FieldGoalsAgainstAverageHome)
	}
	if m.goalsAgainstAverageAway != nil {
		fields = append(fields, tsgoals.FieldGoalsAgainstAverageAway)
	}
	if m.goalsAgainstAverageTotal != nil {
		fields = append(fields, tsgoals.FieldGoalsAgainstAverageTotal)
	}
	if m.goalsAgainstMinute0To15Total != nil {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute0To15Total)
	}
	if m.goalsAgainstMinute0To15Percentage != nil {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute0To15Percentage)
	}
	if m.goalsAgainstMinute16To30Total != nil {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute16To30Total)
	}
	if m.goalsAgainstMinute16To30Percentage != nil {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute16To30Percentage)
	}
	if m.goalsAgainstMinute31To45Total != nil {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute31To45Total)
	}
	if m.goalsAgainstMinute31To45Percentage != nil {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute31To45Percentage)
	}
	if m.goalsAgainstMinute46To60Total != nil {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute46To60Total)
	}
	if m.goalsAgainstMinute46To60Percentage != nil {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute46To60Percentage)
	}
	if m.goalsAgainstMinute61To75Total != nil {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute61To75Total)
	}
	if m.goalsAgainstMinute61To75Percentage != nil {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute61To75Percentage)
	}
	if m.goalsAgainstMinute76To90Total != nil {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute76To90Total)
	}
	if m.goalsAgainstMinute76To90Percentage != nil {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute76To90Percentage)
	}
	if m.goalsAgainstMinute91To105Total != nil {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute91To105Total)
	}
	if m.goalsAgainstMinute91To105Percentage != nil {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute91To105Percentage)
	}
	if m.goalsAgainstMinute106To120Total != nil {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute106To120Total)
	}
	if m.goalsAgainstMinute106To120Percentage != nil {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute106To120Percentage)
	}
	if m.lastUpdated != nil {
		fields = append(fields, tsgoals.FieldLastUpdated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TSGoalsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tsgoals.FieldGoalsForTotalHome:
		return m.GoalsForTotalHome()
	case tsgoals.FieldGoalsForTotalAway:
		return m.GoalsForTotalAway()
	case tsgoals.FieldGoalsForTotal:
		return m.GoalsForTotal()
	case tsgoals.FieldGoalsForAverageHome:
		return m.GoalsForAverageHome()
	case tsgoals.FieldGoalsForAverageAway:
		return m.GoalsForAverageAway()
	case tsgoals.FieldGoalsForAverageTotal:
		return m.GoalsForAverageTotal()
	case tsgoals.FieldGoalsForMinute0To15Total:
		return m.GoalsForMinute0To15Total()
	case tsgoals.FieldGoalsForMinute0To15Percentage:
		return m.GoalsForMinute0To15Percentage()
	case tsgoals.FieldGoalsForMinute16To30Total:
		return m.GoalsForMinute16To30Total()
	case tsgoals.FieldGoalsForMinute16To30Percentage:
		return m.GoalsForMinute16To30Percentage()
	case tsgoals.FieldGoalsForMinute31To45Total:
		return m.GoalsForMinute31To45Total()
	case tsgoals.FieldGoalsForMinute31To45Percentage:
		return m.GoalsForMinute31To45Percentage()
	case tsgoals.FieldGoalsForMinute46To60Total:
		return m.GoalsForMinute46To60Total()
	case tsgoals.FieldGoalsForMinute46To60Percentage:
		return m.GoalsForMinute46To60Percentage()
	case tsgoals.FieldGoalsForMinute61To75Total:
		return m.GoalsForMinute61To75Total()
	case tsgoals.FieldGoalsForMinute61To75Percentage:
		return m.GoalsForMinute61To75Percentage()
	case tsgoals.FieldGoalsForMinute76To90Total:
		return m.GoalsForMinute76To90Total()
	case tsgoals.FieldGoalsForMinute76To90Percentage:
		return m.GoalsForMinute76To90Percentage()
	case tsgoals.FieldGoalsForMinute91To105Total:
		return m.GoalsForMinute91To105Total()
	case tsgoals.FieldGoalsForMinute91To105Percentage:
		return m.GoalsForMinute91To105Percentage()
	case tsgoals.FieldGoalsForMinute106To120Total:
		return m.GoalsForMinute106To120Total()
	case tsgoals.FieldGoalsForMinute106To120Percentage:
		return m.GoalsForMinute106To120Percentage()
	case tsgoals.FieldGoalsAgainstTotalHome:
		return m.GoalsAgainstTotalHome()
	case tsgoals.FieldGoalsAgainstTotalAway:
		return m.GoalsAgainstTotalAway()
	case tsgoals.FieldGoalsAgainstTotal:
		return m.GoalsAgainstTotal()
	case tsgoals.FieldGoalsAgainstAverageHome:
		return m.GoalsAgainstAverageHome()
	case tsgoals.FieldGoalsAgainstAverageAway:
		return m.GoalsAgainstAverageAway()
	case tsgoals.FieldGoalsAgainstAverageTotal:
		return m.GoalsAgainstAverageTotal()
	case tsgoals.FieldGoalsAgainstMinute0To15Total:
		return m.GoalsAgainstMinute0To15Total()
	case tsgoals.FieldGoalsAgainstMinute0To15Percentage:
		return m.GoalsAgainstMinute0To15Percentage()
	case tsgoals.FieldGoalsAgainstMinute16To30Total:
		return m.GoalsAgainstMinute16To30Total()
	case tsgoals.FieldGoalsAgainstMinute16To30Percentage:
		return m.GoalsAgainstMinute16To30Percentage()
	case tsgoals.FieldGoalsAgainstMinute31To45Total:
		return m.GoalsAgainstMinute31To45Total()
	case tsgoals.FieldGoalsAgainstMinute31To45Percentage:
		return m.GoalsAgainstMinute31To45Percentage()
	case tsgoals.FieldGoalsAgainstMinute46To60Total:
		return m.GoalsAgainstMinute46To60Total()
	case tsgoals.FieldGoalsAgainstMinute46To60Percentage:
		return m.GoalsAgainstMinute46To60Percentage()
	case tsgoals.FieldGoalsAgainstMinute61To75Total:
		return m.GoalsAgainstMinute61To75Total()
	case tsgoals.FieldGoalsAgainstMinute61To75Percentage:
		return m.GoalsAgainstMinute61To75Percentage()
	case tsgoals.FieldGoalsAgainstMinute76To90Total:
		return m.GoalsAgainstMinute76To90Total()
	case tsgoals.FieldGoalsAgainstMinute76To90Percentage:
		return m.GoalsAgainstMinute76To90Percentage()
	case tsgoals.FieldGoalsAgainstMinute91To105Total:
		return m.GoalsAgainstMinute91To105Total()
	case tsgoals.FieldGoalsAgainstMinute91To105Percentage:
		return m.GoalsAgainstMinute91To105Percentage()
	case tsgoals.FieldGoalsAgainstMinute106To120Total:
		return m.GoalsAgainstMinute106To120Total()
	case tsgoals.FieldGoalsAgainstMinute106To120Percentage:
		return m.GoalsAgainstMinute106To120Percentage()
	case tsgoals.FieldLastUpdated:
		return m.LastUpdated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TSGoalsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tsgoals.FieldGoalsForTotalHome:
		return m.OldGoalsForTotalHome(ctx)
	case tsgoals.FieldGoalsForTotalAway:
		return m.OldGoalsForTotalAway(ctx)
	case tsgoals.FieldGoalsForTotal:
		return m.OldGoalsForTotal(ctx)
	case tsgoals.FieldGoalsForAverageHome:
		return m.OldGoalsForAverageHome(ctx)
	case tsgoals.FieldGoalsForAverageAway:
		return m.OldGoalsForAverageAway(ctx)
	case tsgoals.FieldGoalsForAverageTotal:
		return m.OldGoalsForAverageTotal(ctx)
	case tsgoals.FieldGoalsForMinute0To15Total:
		return m.OldGoalsForMinute0To15Total(ctx)
	case tsgoals.FieldGoalsForMinute0To15Percentage:
		return m.OldGoalsForMinute0To15Percentage(ctx)
	case tsgoals.FieldGoalsForMinute16To30Total:
		return m.OldGoalsForMinute16To30Total(ctx)
	case tsgoals.FieldGoalsForMinute16To30Percentage:
		return m.OldGoalsForMinute16To30Percentage(ctx)
	case tsgoals.FieldGoalsForMinute31To45Total:
		return m.OldGoalsForMinute31To45Total(ctx)
	case tsgoals.FieldGoalsForMinute31To45Percentage:
		return m.OldGoalsForMinute31To45Percentage(ctx)
	case tsgoals.FieldGoalsForMinute46To60Total:
		return m.OldGoalsForMinute46To60Total(ctx)
	case tsgoals.FieldGoalsForMinute46To60Percentage:
		return m.OldGoalsForMinute46To60Percentage(ctx)
	case tsgoals.FieldGoalsForMinute61To75Total:
		return m.OldGoalsForMinute61To75Total(ctx)
	case tsgoals.FieldGoalsForMinute61To75Percentage:
		return m.OldGoalsForMinute61To75Percentage(ctx)
	case tsgoals.FieldGoalsForMinute76To90Total:
		return m.OldGoalsForMinute76To90Total(ctx)
	case tsgoals.FieldGoalsForMinute76To90Percentage:
		return m.OldGoalsForMinute76To90Percentage(ctx)
	case tsgoals.FieldGoalsForMinute91To105Total:
		return m.OldGoalsForMinute91To105Total(ctx)
	case tsgoals.FieldGoalsForMinute91To105Percentage:
		return m.OldGoalsForMinute91To105Percentage(ctx)
	case tsgoals.FieldGoalsForMinute106To120Total:
		return m.OldGoalsForMinute106To120Total(ctx)
	case tsgoals.FieldGoalsForMinute106To120Percentage:
		return m.OldGoalsForMinute106To120Percentage(ctx)
	case tsgoals.FieldGoalsAgainstTotalHome:
		return m.OldGoalsAgainstTotalHome(ctx)
	case tsgoals.FieldGoalsAgainstTotalAway:
		return m.OldGoalsAgainstTotalAway(ctx)
	case tsgoals.FieldGoalsAgainstTotal:
		return m.OldGoalsAgainstTotal(ctx)
	case tsgoals.FieldGoalsAgainstAverageHome:
		return m.OldGoalsAgainstAverageHome(ctx)
	case tsgoals.FieldGoalsAgainstAverageAway:
		return m.OldGoalsAgainstAverageAway(ctx)
	case tsgoals.FieldGoalsAgainstAverageTotal:
		return m.OldGoalsAgainstAverageTotal(ctx)
	case tsgoals.FieldGoalsAgainstMinute0To15Total:
		return m.OldGoalsAgainstMinute0To15Total(ctx)
	case tsgoals.FieldGoalsAgainstMinute0To15Percentage:
		return m.OldGoalsAgainstMinute0To15Percentage(ctx)
	case tsgoals.FieldGoalsAgainstMinute16To30Total:
		return m.OldGoalsAgainstMinute16To30Total(ctx)
	case tsgoals.FieldGoalsAgainstMinute16To30Percentage:
		return m.OldGoalsAgainstMinute16To30Percentage(ctx)
	case tsgoals.FieldGoalsAgainstMinute31To45Total:
		return m.OldGoalsAgainstMinute31To45Total(ctx)
	case tsgoals.FieldGoalsAgainstMinute31To45Percentage:
		return m.OldGoalsAgainstMinute31To45Percentage(ctx)
	case tsgoals.FieldGoalsAgainstMinute46To60Total:
		return m.OldGoalsAgainstMinute46To60Total(ctx)
	case tsgoals.FieldGoalsAgainstMinute46To60Percentage:
		return m.OldGoalsAgainstMinute46To60Percentage(ctx)
	case tsgoals.FieldGoalsAgainstMinute61To75Total:
		return m.OldGoalsAgainstMinute61To75Total(ctx)
	case tsgoals.FieldGoalsAgainstMinute61To75Percentage:
		return m.OldGoalsAgainstMinute61To75Percentage(ctx)
	case tsgoals.FieldGoalsAgainstMinute76To90Total:
		return m.OldGoalsAgainstMinute76To90Total(ctx)
	case tsgoals.FieldGoalsAgainstMinute76To90Percentage:
		return m.OldGoalsAgainstMinute76To90Percentage(ctx)
	case tsgoals.FieldGoalsAgainstMinute91To105Total:
		return m.OldGoalsAgainstMinute91To105Total(ctx)
	case tsgoals.FieldGoalsAgainstMinute91To105Percentage:
		return m.OldGoalsAgainstMinute91To105Percentage(ctx)
	case tsgoals.FieldGoalsAgainstMinute106To120Total:
		return m.OldGoalsAgainstMinute106To120Total(ctx)
	case tsgoals.FieldGoalsAgainstMinute106To120Percentage:
		return m.OldGoalsAgainstMinute106To120Percentage(ctx)
	case tsgoals.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	}
	return nil, fmt.Errorf("unknown TSGoals field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TSGoalsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tsgoals.FieldGoalsForTotalHome:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsForTotalHome(v)
		return nil
	case tsgoals.FieldGoalsForTotalAway:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsForTotalAway(v)
		return nil
	case tsgoals.FieldGoalsForTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsForTotal(v)
		return nil
	case tsgoals.FieldGoalsForAverageHome:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsForAverageHome(v)
		return nil
	case tsgoals.FieldGoalsForAverageAway:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsForAverageAway(v)
		return nil
	case tsgoals.FieldGoalsForAverageTotal:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsForAverageTotal(v)
		return nil
	case tsgoals.FieldGoalsForMinute0To15Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsForMinute0To15Total(v)
		return nil
	case tsgoals.FieldGoalsForMinute0To15Percentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsForMinute0To15Percentage(v)
		return nil
	case tsgoals.FieldGoalsForMinute16To30Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsForMinute16To30Total(v)
		return nil
	case tsgoals.FieldGoalsForMinute16To30Percentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsForMinute16To30Percentage(v)
		return nil
	case tsgoals.FieldGoalsForMinute31To45Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsForMinute31To45Total(v)
		return nil
	case tsgoals.FieldGoalsForMinute31To45Percentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsForMinute31To45Percentage(v)
		return nil
	case tsgoals.FieldGoalsForMinute46To60Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsForMinute46To60Total(v)
		return nil
	case tsgoals.FieldGoalsForMinute46To60Percentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsForMinute46To60Percentage(v)
		return nil
	case tsgoals.FieldGoalsForMinute61To75Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsForMinute61To75Total(v)
		return nil
	case tsgoals.FieldGoalsForMinute61To75Percentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsForMinute61To75Percentage(v)
		return nil
	case tsgoals.FieldGoalsForMinute76To90Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsForMinute76To90Total(v)
		return nil
	case tsgoals.FieldGoalsForMinute76To90Percentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsForMinute76To90Percentage(v)
		return nil
	case tsgoals.FieldGoalsForMinute91To105Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsForMinute91To105Total(v)
		return nil
	case tsgoals.FieldGoalsForMinute91To105Percentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsForMinute91To105Percentage(v)
		return nil
	case tsgoals.FieldGoalsForMinute106To120Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsForMinute106To120Total(v)
		return nil
	case tsgoals.FieldGoalsForMinute106To120Percentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsForMinute106To120Percentage(v)
		return nil
	case tsgoals.FieldGoalsAgainstTotalHome:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsAgainstTotalHome(v)
		return nil
	case tsgoals.FieldGoalsAgainstTotalAway:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsAgainstTotalAway(v)
		return nil
	case tsgoals.FieldGoalsAgainstTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsAgainstTotal(v)
		return nil
	case tsgoals.FieldGoalsAgainstAverageHome:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsAgainstAverageHome(v)
		return nil
	case tsgoals.FieldGoalsAgainstAverageAway:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsAgainstAverageAway(v)
		return nil
	case tsgoals.FieldGoalsAgainstAverageTotal:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsAgainstAverageTotal(v)
		return nil
	case tsgoals.FieldGoalsAgainstMinute0To15Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsAgainstMinute0To15Total(v)
		return nil
	case tsgoals.FieldGoalsAgainstMinute0To15Percentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsAgainstMinute0To15Percentage(v)
		return nil
	case tsgoals.FieldGoalsAgainstMinute16To30Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsAgainstMinute16To30Total(v)
		return nil
	case tsgoals.FieldGoalsAgainstMinute16To30Percentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsAgainstMinute16To30Percentage(v)
		return nil
	case tsgoals.FieldGoalsAgainstMinute31To45Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsAgainstMinute31To45Total(v)
		return nil
	case tsgoals.FieldGoalsAgainstMinute31To45Percentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsAgainstMinute31To45Percentage(v)
		return nil
	case tsgoals.FieldGoalsAgainstMinute46To60Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsAgainstMinute46To60Total(v)
		return nil
	case tsgoals.FieldGoalsAgainstMinute46To60Percentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsAgainstMinute46To60Percentage(v)
		return nil
	case tsgoals.FieldGoalsAgainstMinute61To75Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsAgainstMinute61To75Total(v)
		return nil
	case tsgoals.FieldGoalsAgainstMinute61To75Percentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsAgainstMinute61To75Percentage(v)
		return nil
	case tsgoals.FieldGoalsAgainstMinute76To90Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsAgainstMinute76To90Total(v)
		return nil
	case tsgoals.FieldGoalsAgainstMinute76To90Percentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsAgainstMinute76To90Percentage(v)
		return nil
	case tsgoals.FieldGoalsAgainstMinute91To105Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsAgainstMinute91To105Total(v)
		return nil
	case tsgoals.FieldGoalsAgainstMinute91To105Percentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsAgainstMinute91To105Percentage(v)
		return nil
	case tsgoals.FieldGoalsAgainstMinute106To120Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsAgainstMinute106To120Total(v)
		return nil
	case tsgoals.FieldGoalsAgainstMinute106To120Percentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsAgainstMinute106To120Percentage(v)
		return nil
	case tsgoals.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	}
	return fmt.Errorf("unknown TSGoals field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TSGoalsMutation) AddedFields() []string {
	var fields []string
	if m.addgoalsForTotalHome != nil {
		fields = append(fields, tsgoals.FieldGoalsForTotalHome)
	}
	if m.addgoalsForTotalAway != nil {
		fields = append(fields, tsgoals.FieldGoalsForTotalAway)
	}
	if m.addgoalsForTotal != nil {
		fields = append(fields, tsgoals.FieldGoalsForTotal)
	}
	if m.addgoalsForMinute0To15Total != nil {
		fields = append(fields, tsgoals.FieldGoalsForMinute0To15Total)
	}
	if m.addgoalsForMinute16To30Total != nil {
		fields = append(fields, tsgoals.FieldGoalsForMinute16To30Total)
	}
	if m.addgoalsForMinute31To45Total != nil {
		fields = append(fields, tsgoals.FieldGoalsForMinute31To45Total)
	}
	if m.addgoalsForMinute46To60Total != nil {
		fields = append(fields, tsgoals.FieldGoalsForMinute46To60Total)
	}
	if m.addgoalsForMinute61To75Total != nil {
		fields = append(fields, tsgoals.FieldGoalsForMinute61To75Total)
	}
	if m.addgoalsForMinute76To90Total != nil {
		fields = append(fields, tsgoals.FieldGoalsForMinute76To90Total)
	}
	if m.addgoalsForMinute91To105Total != nil {
		fields = append(fields, tsgoals.FieldGoalsForMinute91To105Total)
	}
	if m.addgoalsForMinute106To120Total != nil {
		fields = append(fields, tsgoals.FieldGoalsForMinute106To120Total)
	}
	if m.addgoalsAgainstTotalHome != nil {
		fields = append(fields, tsgoals.FieldGoalsAgainstTotalHome)
	}
	if m.addgoalsAgainstTotalAway != nil {
		fields = append(fields, tsgoals.FieldGoalsAgainstTotalAway)
	}
	if m.addgoalsAgainstTotal != nil {
		fields = append(fields, tsgoals.FieldGoalsAgainstTotal)
	}
	if m.addgoalsAgainstMinute0To15Total != nil {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute0To15Total)
	}
	if m.addgoalsAgainstMinute16To30Total != nil {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute16To30Total)
	}
	if m.addgoalsAgainstMinute31To45Total != nil {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute31To45Total)
	}
	if m.addgoalsAgainstMinute46To60Total != nil {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute46To60Total)
	}
	if m.addgoalsAgainstMinute61To75Total != nil {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute61To75Total)
	}
	if m.addgoalsAgainstMinute76To90Total != nil {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute76To90Total)
	}
	if m.addgoalsAgainstMinute91To105Total != nil {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute91To105Total)
	}
	if m.addgoalsAgainstMinute106To120Total != nil {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute106To120Total)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TSGoalsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tsgoals.FieldGoalsForTotalHome:
		return m.AddedGoalsForTotalHome()
	case tsgoals.FieldGoalsForTotalAway:
		return m.AddedGoalsForTotalAway()
	case tsgoals.FieldGoalsForTotal:
		return m.AddedGoalsForTotal()
	case tsgoals.FieldGoalsForMinute0To15Total:
		return m.AddedGoalsForMinute0To15Total()
	case tsgoals.FieldGoalsForMinute16To30Total:
		return m.AddedGoalsForMinute16To30Total()
	case tsgoals.FieldGoalsForMinute31To45Total:
		return m.AddedGoalsForMinute31To45Total()
	case tsgoals.FieldGoalsForMinute46To60Total:
		return m.AddedGoalsForMinute46To60Total()
	case tsgoals.FieldGoalsForMinute61To75Total:
		return m.AddedGoalsForMinute61To75Total()
	case tsgoals.FieldGoalsForMinute76To90Total:
		return m.AddedGoalsForMinute76To90Total()
	case tsgoals.FieldGoalsForMinute91To105Total:
		return m.AddedGoalsForMinute91To105Total()
	case tsgoals.FieldGoalsForMinute106To120Total:
		return m.AddedGoalsForMinute106To120Total()
	case tsgoals.FieldGoalsAgainstTotalHome:
		return m.AddedGoalsAgainstTotalHome()
	case tsgoals.FieldGoalsAgainstTotalAway:
		return m.AddedGoalsAgainstTotalAway()
	case tsgoals.FieldGoalsAgainstTotal:
		return m.AddedGoalsAgainstTotal()
	case tsgoals.FieldGoalsAgainstMinute0To15Total:
		return m.AddedGoalsAgainstMinute0To15Total()
	case tsgoals.FieldGoalsAgainstMinute16To30Total:
		return m.AddedGoalsAgainstMinute16To30Total()
	case tsgoals.FieldGoalsAgainstMinute31To45Total:
		return m.AddedGoalsAgainstMinute31To45Total()
	case tsgoals.FieldGoalsAgainstMinute46To60Total:
		return m.AddedGoalsAgainstMinute46To60Total()
	case tsgoals.FieldGoalsAgainstMinute61To75Total:
		return m.AddedGoalsAgainstMinute61To75Total()
	case tsgoals.FieldGoalsAgainstMinute76To90Total:
		return m.AddedGoalsAgainstMinute76To90Total()
	case tsgoals.FieldGoalsAgainstMinute91To105Total:
		return m.AddedGoalsAgainstMinute91To105Total()
	case tsgoals.FieldGoalsAgainstMinute106To120Total:
		return m.AddedGoalsAgainstMinute106To120Total()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TSGoalsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tsgoals.FieldGoalsForTotalHome:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGoalsForTotalHome(v)
		return nil
	case tsgoals.FieldGoalsForTotalAway:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGoalsForTotalAway(v)
		return nil
	case tsgoals.FieldGoalsForTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGoalsForTotal(v)
		return nil
	case tsgoals.FieldGoalsForMinute0To15Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGoalsForMinute0To15Total(v)
		return nil
	case tsgoals.FieldGoalsForMinute16To30Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGoalsForMinute16To30Total(v)
		return nil
	case tsgoals.FieldGoalsForMinute31To45Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGoalsForMinute31To45Total(v)
		return nil
	case tsgoals.FieldGoalsForMinute46To60Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGoalsForMinute46To60Total(v)
		return nil
	case tsgoals.FieldGoalsForMinute61To75Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGoalsForMinute61To75Total(v)
		return nil
	case tsgoals.FieldGoalsForMinute76To90Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGoalsForMinute76To90Total(v)
		return nil
	case tsgoals.FieldGoalsForMinute91To105Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGoalsForMinute91To105Total(v)
		return nil
	case tsgoals.FieldGoalsForMinute106To120Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGoalsForMinute106To120Total(v)
		return nil
	case tsgoals.FieldGoalsAgainstTotalHome:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGoalsAgainstTotalHome(v)
		return nil
	case tsgoals.FieldGoalsAgainstTotalAway:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGoalsAgainstTotalAway(v)
		return nil
	case tsgoals.FieldGoalsAgainstTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGoalsAgainstTotal(v)
		return nil
	case tsgoals.FieldGoalsAgainstMinute0To15Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGoalsAgainstMinute0To15Total(v)
		return nil
	case tsgoals.FieldGoalsAgainstMinute16To30Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGoalsAgainstMinute16To30Total(v)
		return nil
	case tsgoals.FieldGoalsAgainstMinute31To45Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGoalsAgainstMinute31To45Total(v)
		return nil
	case tsgoals.FieldGoalsAgainstMinute46To60Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGoalsAgainstMinute46To60Total(v)
		return nil
	case tsgoals.FieldGoalsAgainstMinute61To75Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGoalsAgainstMinute61To75Total(v)
		return nil
	case tsgoals.FieldGoalsAgainstMinute76To90Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGoalsAgainstMinute76To90Total(v)
		return nil
	case tsgoals.FieldGoalsAgainstMinute91To105Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGoalsAgainstMinute91To105Total(v)
		return nil
	case tsgoals.FieldGoalsAgainstMinute106To120Total:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGoalsAgainstMinute106To120Total(v)
		return nil
	}
	return fmt.Errorf("unknown TSGoals numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TSGoalsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tsgoals.FieldGoalsForTotalHome) {
		fields = append(fields, tsgoals.FieldGoalsForTotalHome)
	}
	if m.FieldCleared(tsgoals.FieldGoalsForTotalAway) {
		fields = append(fields, tsgoals.FieldGoalsForTotalAway)
	}
	if m.FieldCleared(tsgoals.FieldGoalsForTotal) {
		fields = append(fields, tsgoals.FieldGoalsForTotal)
	}
	if m.FieldCleared(tsgoals.FieldGoalsForAverageHome) {
		fields = append(fields, tsgoals.FieldGoalsForAverageHome)
	}
	if m.FieldCleared(tsgoals.FieldGoalsForAverageAway) {
		fields = append(fields, tsgoals.FieldGoalsForAverageAway)
	}
	if m.FieldCleared(tsgoals.FieldGoalsForAverageTotal) {
		fields = append(fields, tsgoals.FieldGoalsForAverageTotal)
	}
	if m.FieldCleared(tsgoals.FieldGoalsForMinute0To15Total) {
		fields = append(fields, tsgoals.FieldGoalsForMinute0To15Total)
	}
	if m.FieldCleared(tsgoals.FieldGoalsForMinute0To15Percentage) {
		fields = append(fields, tsgoals.FieldGoalsForMinute0To15Percentage)
	}
	if m.FieldCleared(tsgoals.FieldGoalsForMinute16To30Total) {
		fields = append(fields, tsgoals.FieldGoalsForMinute16To30Total)
	}
	if m.FieldCleared(tsgoals.FieldGoalsForMinute16To30Percentage) {
		fields = append(fields, tsgoals.FieldGoalsForMinute16To30Percentage)
	}
	if m.FieldCleared(tsgoals.FieldGoalsForMinute31To45Total) {
		fields = append(fields, tsgoals.FieldGoalsForMinute31To45Total)
	}
	if m.FieldCleared(tsgoals.FieldGoalsForMinute31To45Percentage) {
		fields = append(fields, tsgoals.FieldGoalsForMinute31To45Percentage)
	}
	if m.FieldCleared(tsgoals.FieldGoalsForMinute46To60Total) {
		fields = append(fields, tsgoals.FieldGoalsForMinute46To60Total)
	}
	if m.FieldCleared(tsgoals.FieldGoalsForMinute46To60Percentage) {
		fields = append(fields, tsgoals.FieldGoalsForMinute46To60Percentage)
	}
	if m.FieldCleared(tsgoals.FieldGoalsForMinute61To75Total) {
		fields = append(fields, tsgoals.FieldGoalsForMinute61To75Total)
	}
	if m.FieldCleared(tsgoals.FieldGoalsForMinute61To75Percentage) {
		fields = append(fields, tsgoals.FieldGoalsForMinute61To75Percentage)
	}
	if m.FieldCleared(tsgoals.FieldGoalsForMinute76To90Total) {
		fields = append(fields, tsgoals.FieldGoalsForMinute76To90Total)
	}
	if m.FieldCleared(tsgoals.FieldGoalsForMinute76To90Percentage) {
		fields = append(fields, tsgoals.FieldGoalsForMinute76To90Percentage)
	}
	if m.FieldCleared(tsgoals.FieldGoalsForMinute91To105Total) {
		fields = append(fields, tsgoals.FieldGoalsForMinute91To105Total)
	}
	if m.FieldCleared(tsgoals.FieldGoalsForMinute91To105Percentage) {
		fields = append(fields, tsgoals.FieldGoalsForMinute91To105Percentage)
	}
	if m.FieldCleared(tsgoals.FieldGoalsForMinute106To120Total) {
		fields = append(fields, tsgoals.FieldGoalsForMinute106To120Total)
	}
	if m.FieldCleared(tsgoals.FieldGoalsForMinute106To120Percentage) {
		fields = append(fields, tsgoals.FieldGoalsForMinute106To120Percentage)
	}
	if m.FieldCleared(tsgoals.FieldGoalsAgainstTotalHome) {
		fields = append(fields, tsgoals.FieldGoalsAgainstTotalHome)
	}
	if m.FieldCleared(tsgoals.FieldGoalsAgainstTotalAway) {
		fields = append(fields, tsgoals.FieldGoalsAgainstTotalAway)
	}
	if m.FieldCleared(tsgoals.FieldGoalsAgainstTotal) {
		fields = append(fields, tsgoals.FieldGoalsAgainstTotal)
	}
	if m.FieldCleared(tsgoals.FieldGoalsAgainstAverageHome) {
		fields = append(fields, tsgoals.FieldGoalsAgainstAverageHome)
	}
	if m.FieldCleared(tsgoals.FieldGoalsAgainstAverageAway) {
		fields = append(fields, tsgoals.FieldGoalsAgainstAverageAway)
	}
	if m.FieldCleared(tsgoals.FieldGoalsAgainstAverageTotal) {
		fields = append(fields, tsgoals.FieldGoalsAgainstAverageTotal)
	}
	if m.FieldCleared(tsgoals.FieldGoalsAgainstMinute0To15Total) {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute0To15Total)
	}
	if m.FieldCleared(tsgoals.FieldGoalsAgainstMinute0To15Percentage) {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute0To15Percentage)
	}
	if m.FieldCleared(tsgoals.FieldGoalsAgainstMinute16To30Total) {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute16To30Total)
	}
	if m.FieldCleared(tsgoals.FieldGoalsAgainstMinute16To30Percentage) {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute16To30Percentage)
	}
	if m.FieldCleared(tsgoals.FieldGoalsAgainstMinute31To45Total) {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute31To45Total)
	}
	if m.FieldCleared(tsgoals.FieldGoalsAgainstMinute31To45Percentage) {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute31To45Percentage)
	}
	if m.FieldCleared(tsgoals.FieldGoalsAgainstMinute46To60Total) {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute46To60Total)
	}
	if m.FieldCleared(tsgoals.FieldGoalsAgainstMinute46To60Percentage) {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute46To60Percentage)
	}
	if m.FieldCleared(tsgoals.FieldGoalsAgainstMinute61To75Total) {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute61To75Total)
	}
	if m.FieldCleared(tsgoals.FieldGoalsAgainstMinute61To75Percentage) {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute61To75Percentage)
	}
	if m.FieldCleared(tsgoals.FieldGoalsAgainstMinute76To90Total) {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute76To90Total)
	}
	if m.FieldCleared(tsgoals.FieldGoalsAgainstMinute76To90Percentage) {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute76To90Percentage)
	}
	if m.FieldCleared(tsgoals.FieldGoalsAgainstMinute91To105Total) {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute91To105Total)
	}
	if m.FieldCleared(tsgoals.FieldGoalsAgainstMinute91To105Percentage) {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute91To105Percentage)
	}
	if m.FieldCleared(tsgoals.FieldGoalsAgainstMinute106To120Total) {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute106To120Total)
	}
	if m.FieldCleared(tsgoals.FieldGoalsAgainstMinute106To120Percentage) {
		fields = append(fields, tsgoals.FieldGoalsAgainstMinute106To120Percentage)
	}
	if m.FieldCleared(tsgoals.FieldLastUpdated) {
		fields = append(fields, tsgoals.FieldLastUpdated)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TSGoalsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TSGoalsMutation) ClearField(name string) error {
	switch name {
	case tsgoals.FieldGoalsForTotalHome:
		m.ClearGoalsForTotalHome()
		return nil
	case tsgoals.FieldGoalsForTotalAway:
		m.ClearGoalsForTotalAway()
		return nil
	case tsgoals.FieldGoalsForTotal:
		m.ClearGoalsForTotal()
		return nil
	case tsgoals.FieldGoalsForAverageHome:
		m.ClearGoalsForAverageHome()
		return nil
	case tsgoals.FieldGoalsForAverageAway:
		m.ClearGoalsForAverageAway()
		return nil
	case tsgoals.FieldGoalsForAverageTotal:
		m.ClearGoalsForAverageTotal()
		return nil
	case tsgoals.FieldGoalsForMinute0To15Total:
		m.ClearGoalsForMinute0To15Total()
		return nil
	case tsgoals.FieldGoalsForMinute0To15Percentage:
		m.ClearGoalsForMinute0To15Percentage()
		return nil
	case tsgoals.FieldGoalsForMinute16To30Total:
		m.ClearGoalsForMinute16To30Total()
		return nil
	case tsgoals.FieldGoalsForMinute16To30Percentage:
		m.ClearGoalsForMinute16To30Percentage()
		return nil
	case tsgoals.FieldGoalsForMinute31To45Total:
		m.ClearGoalsForMinute31To45Total()
		return nil
	case tsgoals.FieldGoalsForMinute31To45Percentage:
		m.ClearGoalsForMinute31To45Percentage()
		return nil
	case tsgoals.FieldGoalsForMinute46To60Total:
		m.ClearGoalsForMinute46To60Total()
		return nil
	case tsgoals.FieldGoalsForMinute46To60Percentage:
		m.ClearGoalsForMinute46To60Percentage()
		return nil
	case tsgoals.FieldGoalsForMinute61To75Total:
		m.ClearGoalsForMinute61To75Total()
		return nil
	case tsgoals.FieldGoalsForMinute61To75Percentage:
		m.ClearGoalsForMinute61To75Percentage()
		return nil
	case tsgoals.FieldGoalsForMinute76To90Total:
		m.ClearGoalsForMinute76To90Total()
		return nil
	case tsgoals.FieldGoalsForMinute76To90Percentage:
		m.ClearGoalsForMinute76To90Percentage()
		return nil
	case tsgoals.FieldGoalsForMinute91To105Total:
		m.ClearGoalsForMinute91To105Total()
		return nil
	case tsgoals.FieldGoalsForMinute91To105Percentage:
		m.ClearGoalsForMinute91To105Percentage()
		return nil
	case tsgoals.FieldGoalsForMinute106To120Total:
		m.ClearGoalsForMinute106To120Total()
		return nil
	case tsgoals.FieldGoalsForMinute106To120Percentage:
		m.ClearGoalsForMinute106To120Percentage()
		return nil
	case tsgoals.FieldGoalsAgainstTotalHome:
		m.ClearGoalsAgainstTotalHome()
		return nil
	case tsgoals.FieldGoalsAgainstTotalAway:
		m.ClearGoalsAgainstTotalAway()
		return nil
	case tsgoals.FieldGoalsAgainstTotal:
		m.ClearGoalsAgainstTotal()
		return nil
	case tsgoals.FieldGoalsAgainstAverageHome:
		m.ClearGoalsAgainstAverageHome()
		return nil
	case tsgoals.FieldGoalsAgainstAverageAway:
		m.ClearGoalsAgainstAverageAway()
		return nil
	case tsgoals.FieldGoalsAgainstAverageTotal:
		m.ClearGoalsAgainstAverageTotal()
		return nil
	case tsgoals.FieldGoalsAgainstMinute0To15Total:
		m.ClearGoalsAgainstMinute0To15Total()
		return nil
	case tsgoals.FieldGoalsAgainstMinute0To15Percentage:
		m.ClearGoalsAgainstMinute0To15Percentage()
		return nil
	case tsgoals.FieldGoalsAgainstMinute16To30Total:
		m.ClearGoalsAgainstMinute16To30Total()
		return nil
	case tsgoals.FieldGoalsAgainstMinute16To30Percentage:
		m.ClearGoalsAgainstMinute16To30Percentage()
		return nil
	case tsgoals.FieldGoalsAgainstMinute31To45Total:
		m.ClearGoalsAgainstMinute31To45Total()
		return nil
	case tsgoals.FieldGoalsAgainstMinute31To45Percentage:
		m.ClearGoalsAgainstMinute31To45Percentage()
		return nil
	case tsgoals.FieldGoalsAgainstMinute46To60Total:
		m.ClearGoalsAgainstMinute46To60Total()
		return nil
	case tsgoals.FieldGoalsAgainstMinute46To60Percentage:
		m.ClearGoalsAgainstMinute46To60Percentage()
		return nil
	case tsgoals.FieldGoalsAgainstMinute61To75Total:
		m.ClearGoalsAgainstMinute61To75Total()
		return nil
	case tsgoals.FieldGoalsAgainstMinute61To75Percentage:
		m.ClearGoalsAgainstMinute61To75Percentage()
		return nil
	case tsgoals.FieldGoalsAgainstMinute76To90Total:
		m.ClearGoalsAgainstMinute76To90Total()
		return nil
	case tsgoals.FieldGoalsAgainstMinute76To90Percentage:
		m.ClearGoalsAgainstMinute76To90Percentage()
		return nil
	case tsgoals.FieldGoalsAgainstMinute91To105Total:
		m.ClearGoalsAgainstMinute91To105Total()
		return nil
	case tsgoals.FieldGoalsAgainstMinute91To105Percentage:
		m.ClearGoalsAgainstMinute91To105Percentage()
		return nil
	case tsgoals.FieldGoalsAgainstMinute106To120Total:
		m.ClearGoalsAgainstMinute106To120Total()
		return nil
	case tsgoals.FieldGoalsAgainstMinute106To120Percentage:
		m.ClearGoalsAgainstMinute106To120Percentage()
		return nil
	case tsgoals.FieldLastUpdated:
		m.ClearLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown TSGoals nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TSGoalsMutation) ResetField(name string) error {
	switch name {
	case tsgoals.FieldGoalsForTotalHome:
		m.ResetGoalsForTotalHome()
		return nil
	case tsgoals.FieldGoalsForTotalAway:
		m.ResetGoalsForTotalAway()
		return nil
	case tsgoals.FieldGoalsForTotal:
		m.ResetGoalsForTotal()
		return nil
	case tsgoals.FieldGoalsForAverageHome:
		m.ResetGoalsForAverageHome()
		return nil
	case tsgoals.FieldGoalsForAverageAway:
		m.ResetGoalsForAverageAway()
		return nil
	case tsgoals.FieldGoalsForAverageTotal:
		m.ResetGoalsForAverageTotal()
		return nil
	case tsgoals.FieldGoalsForMinute0To15Total:
		m.ResetGoalsForMinute0To15Total()
		return nil
	case tsgoals.FieldGoalsForMinute0To15Percentage:
		m.ResetGoalsForMinute0To15Percentage()
		return nil
	case tsgoals.FieldGoalsForMinute16To30Total:
		m.ResetGoalsForMinute16To30Total()
		return nil
	case tsgoals.FieldGoalsForMinute16To30Percentage:
		m.ResetGoalsForMinute16To30Percentage()
		return nil
	case tsgoals.FieldGoalsForMinute31To45Total:
		m.ResetGoalsForMinute31To45Total()
		return nil
	case tsgoals.FieldGoalsForMinute31To45Percentage:
		m.ResetGoalsForMinute31To45Percentage()
		return nil
	case tsgoals.FieldGoalsForMinute46To60Total:
		m.ResetGoalsForMinute46To60Total()
		return nil
	case tsgoals.FieldGoalsForMinute46To60Percentage:
		m.ResetGoalsForMinute46To60Percentage()
		return nil
	case tsgoals.FieldGoalsForMinute61To75Total:
		m.ResetGoalsForMinute61To75Total()
		return nil
	case tsgoals.FieldGoalsForMinute61To75Percentage:
		m.ResetGoalsForMinute61To75Percentage()
		return nil
	case tsgoals.FieldGoalsForMinute76To90Total:
		m.ResetGoalsForMinute76To90Total()
		return nil
	case tsgoals.FieldGoalsForMinute76To90Percentage:
		m.ResetGoalsForMinute76To90Percentage()
		return nil
	case tsgoals.FieldGoalsForMinute91To105Total:
		m.ResetGoalsForMinute91To105Total()
		return nil
	case tsgoals.FieldGoalsForMinute91To105Percentage:
		m.ResetGoalsForMinute91To105Percentage()
		return nil
	case tsgoals.FieldGoalsForMinute106To120Total:
		m.ResetGoalsForMinute106To120Total()
		return nil
	case tsgoals.FieldGoalsForMinute106To120Percentage:
		m.ResetGoalsForMinute106To120Percentage()
		return nil
	case tsgoals.FieldGoalsAgainstTotalHome:
		m.ResetGoalsAgainstTotalHome()
		return nil
	case tsgoals.FieldGoalsAgainstTotalAway:
		m.ResetGoalsAgainstTotalAway()
		return nil
	case tsgoals.FieldGoalsAgainstTotal:
		m.ResetGoalsAgainstTotal()
		return nil
	case tsgoals.FieldGoalsAgainstAverageHome:
		m.ResetGoalsAgainstAverageHome()
		return nil
	case tsgoals.FieldGoalsAgainstAverageAway:
		m.ResetGoalsAgainstAverageAway()
		return nil
	case tsgoals.FieldGoalsAgainstAverageTotal:
		m.ResetGoalsAgainstAverageTotal()
		return nil
	case tsgoals.FieldGoalsAgainstMinute0To15Total:
		m.ResetGoalsAgainstMinute0To15Total()
		return nil
	case tsgoals.FieldGoalsAgainstMinute0To15Percentage:
		m.ResetGoalsAgainstMinute0To15Percentage()
		return nil
	case tsgoals.FieldGoalsAgainstMinute16To30Total:
		m.ResetGoalsAgainstMinute16To30Total()
		return nil
	case tsgoals.FieldGoalsAgainstMinute16To30Percentage:
		m.ResetGoalsAgainstMinute16To30Percentage()
		return nil
	case tsgoals.FieldGoalsAgainstMinute31To45Total:
		m.ResetGoalsAgainstMinute31To45Total()
		return nil
	case tsgoals.FieldGoalsAgainstMinute31To45Percentage:
		m.ResetGoalsAgainstMinute31To45Percentage()
		return nil
	case tsgoals.FieldGoalsAgainstMinute46To60Total:
		m.ResetGoalsAgainstMinute46To60Total()
		return nil
	case tsgoals.FieldGoalsAgainstMinute46To60Percentage:
		m.ResetGoalsAgainstMinute46To60Percentage()
		return nil
	case tsgoals.FieldGoalsAgainstMinute61To75Total:
		m.ResetGoalsAgainstMinute61To75Total()
		return nil
	case tsgoals.FieldGoalsAgainstMinute61To75Percentage:
		m.ResetGoalsAgainstMinute61To75Percentage()
		return nil
	case tsgoals.FieldGoalsAgainstMinute76To90Total:
		m.ResetGoalsAgainstMinute76To90Total()
		return nil
	case tsgoals.FieldGoalsAgainstMinute76To90Percentage:
		m.ResetGoalsAgainstMinute76To90Percentage()
		return nil
	case tsgoals.FieldGoalsAgainstMinute91To105Total:
		m.ResetGoalsAgainstMinute91To105Total()
		return nil
	case tsgoals.FieldGoalsAgainstMinute91To105Percentage:
		m.ResetGoalsAgainstMinute91To105Percentage()
		return nil
	case tsgoals.FieldGoalsAgainstMinute106To120Total:
		m.ResetGoalsAgainstMinute106To120Total()
		return nil
	case tsgoals.FieldGoalsAgainstMinute106To120Percentage:
		m.ResetGoalsAgainstMinute106To120Percentage()
		return nil
	case tsgoals.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown TSGoals field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TSGoalsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.team != nil {
		edges = append(edges, tsgoals.EdgeTeam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TSGoalsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tsgoals.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TSGoalsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TSGoalsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TSGoalsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedteam {
		edges = append(edges, tsgoals.EdgeTeam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TSGoalsMutation) EdgeCleared(name string) bool {
	switch name {
	case tsgoals.EdgeTeam:
		return m.clearedteam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TSGoalsMutation) ClearEdge(name string) error {
	switch name {
	case tsgoals.EdgeTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown TSGoals unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TSGoalsMutation) ResetEdge(name string) error {
	switch name {
	case tsgoals.EdgeTeam:
		m.ResetTeam()
		return nil
	}
	return fmt.Errorf("unknown TSGoals edge %s", name)
}

// TSLineupsMutation represents an operation that mutates the TSLineups nodes in the graph.
type TSLineupsMutation struct {
	config
	op            Op
	typ           string
	id            *int
	formation     *string
	played        *int
	addplayed     *int
	lastUpdated   *time.Time
	clearedFields map[string]struct{}
	team          *int
	clearedteam   bool
	done          bool
	oldValue      func(context.Context) (*TSLineups, error)
	predicates    []predicate.TSLineups
}

var _ ent.Mutation = (*TSLineupsMutation)(nil)

// tslineupsOption allows management of the mutation configuration using functional options.
type tslineupsOption func(*TSLineupsMutation)

// newTSLineupsMutation creates new mutation for the TSLineups entity.
func newTSLineupsMutation(c config, op Op, opts ...tslineupsOption) *TSLineupsMutation {
	m := &TSLineupsMutation{
		config:        c,
		op:            op,
		typ:           TypeTSLineups,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTSLineupsID sets the ID field of the mutation.
func withTSLineupsID(id int) tslineupsOption {
	return func(m *TSLineupsMutation) {
		var (
			err   error
			once  sync.Once
			value *TSLineups
		)
		m.oldValue = func(ctx context.Context) (*TSLineups, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TSLineups.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTSLineups sets the old TSLineups of the mutation.
func withTSLineups(node *TSLineups) tslineupsOption {
	return func(m *TSLineupsMutation) {
		m.oldValue = func(context.Context) (*TSLineups, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TSLineupsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TSLineupsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TSLineupsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TSLineupsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TSLineups.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFormation sets the "formation" field.
func (m *TSLineupsMutation) SetFormation(s string) {
	m.formation = &s
}

// Formation returns the value of the "formation" field in the mutation.
func (m *TSLineupsMutation) Formation() (r string, exists bool) {
	v := m.formation
	if v == nil {
		return
	}
	return *v, true
}

// OldFormation returns the old "formation" field's value of the TSLineups entity.
// If the TSLineups object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSLineupsMutation) OldFormation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormation: %w", err)
	}
	return oldValue.Formation, nil
}

// ResetFormation resets all changes to the "formation" field.
func (m *TSLineupsMutation) ResetFormation() {
	m.formation = nil
}

// SetPlayed sets the "played" field.
func (m *TSLineupsMutation) SetPlayed(i int) {
	m.played = &i
	m.addplayed = nil
}

// Played returns the value of the "played" field in the mutation.
func (m *TSLineupsMutation) Played() (r int, exists bool) {
	v := m.played
	if v == nil {
		return
	}
	return *v, true
}

// OldPlayed returns the old "played" field's value of the TSLineups entity.
// If the TSLineups object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSLineupsMutation) OldPlayed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlayed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlayed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlayed: %w", err)
	}
	return oldValue.Played, nil
}

// AddPlayed adds i to the "played" field.
func (m *TSLineupsMutation) AddPlayed(i int) {
	if m.addplayed != nil {
		*m.addplayed += i
	} else {
		m.addplayed = &i
	}
}

// AddedPlayed returns the value that was added to the "played" field in this mutation.
func (m *TSLineupsMutation) AddedPlayed() (r int, exists bool) {
	v := m.addplayed
	if v == nil {
		return
	}
	return *v, true
}

// ResetPlayed resets all changes to the "played" field.
func (m *TSLineupsMutation) ResetPlayed() {
	m.played = nil
	m.addplayed = nil
}

// SetTeamID sets the "team_id" field.
func (m *TSLineupsMutation) SetTeamID(i int) {
	m.team = &i
}

// TeamID returns the value of the "team_id" field in the mutation.
func (m *TSLineupsMutation) TeamID() (r int, exists bool) {
	v := m.team
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamID returns the old "team_id" field's value of the TSLineups entity.
// If the TSLineups object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSLineupsMutation) OldTeamID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamID: %w", err)
	}
	return oldValue.TeamID, nil
}

// ResetTeamID resets all changes to the "team_id" field.
func (m *TSLineupsMutation) ResetTeamID() {
	m.team = nil
}

// SetLastUpdated sets the "lastUpdated" field.
func (m *TSLineupsMutation) SetLastUpdated(t time.Time) {
	m.lastUpdated = &t
}

// LastUpdated returns the value of the "lastUpdated" field in the mutation.
func (m *TSLineupsMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.lastUpdated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "lastUpdated" field's value of the TSLineups entity.
// If the TSLineups object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSLineupsMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ClearLastUpdated clears the value of the "lastUpdated" field.
func (m *TSLineupsMutation) ClearLastUpdated() {
	m.lastUpdated = nil
	m.clearedFields[tslineups.FieldLastUpdated] = struct{}{}
}

// LastUpdatedCleared returns if the "lastUpdated" field was cleared in this mutation.
func (m *TSLineupsMutation) LastUpdatedCleared() bool {
	_, ok := m.clearedFields[tslineups.FieldLastUpdated]
	return ok
}

// ResetLastUpdated resets all changes to the "lastUpdated" field.
func (m *TSLineupsMutation) ResetLastUpdated() {
	m.lastUpdated = nil
	delete(m.clearedFields, tslineups.FieldLastUpdated)
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *TSLineupsMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *TSLineupsMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *TSLineupsMutation) TeamIDs() (ids []int) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *TSLineupsMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// Where appends a list predicates to the TSLineupsMutation builder.
func (m *TSLineupsMutation) Where(ps ...predicate.TSLineups) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TSLineupsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TSLineupsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TSLineups, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TSLineupsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TSLineupsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TSLineups).
func (m *TSLineupsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TSLineupsMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.formation != nil {
		fields = append(fields, tslineups.FieldFormation)
	}
	if m.played != nil {
		fields = append(fields, tslineups.FieldPlayed)
	}
	if m.team != nil {
		fields = append(fields, tslineups.FieldTeamID)
	}
	if m.lastUpdated != nil {
		fields = append(fields, tslineups.FieldLastUpdated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TSLineupsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tslineups.FieldFormation:
		return m.Formation()
	case tslineups.FieldPlayed:
		return m.Played()
	case tslineups.FieldTeamID:
		return m.TeamID()
	case tslineups.FieldLastUpdated:
		return m.LastUpdated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TSLineupsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tslineups.FieldFormation:
		return m.OldFormation(ctx)
	case tslineups.FieldPlayed:
		return m.OldPlayed(ctx)
	case tslineups.FieldTeamID:
		return m.OldTeamID(ctx)
	case tslineups.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	}
	return nil, fmt.Errorf("unknown TSLineups field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TSLineupsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tslineups.FieldFormation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormation(v)
		return nil
	case tslineups.FieldPlayed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlayed(v)
		return nil
	case tslineups.FieldTeamID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamID(v)
		return nil
	case tslineups.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	}
	return fmt.Errorf("unknown TSLineups field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TSLineupsMutation) AddedFields() []string {
	var fields []string
	if m.addplayed != nil {
		fields = append(fields, tslineups.FieldPlayed)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TSLineupsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tslineups.FieldPlayed:
		return m.AddedPlayed()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TSLineupsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tslineups.FieldPlayed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlayed(v)
		return nil
	}
	return fmt.Errorf("unknown TSLineups numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TSLineupsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tslineups.FieldLastUpdated) {
		fields = append(fields, tslineups.FieldLastUpdated)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TSLineupsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TSLineupsMutation) ClearField(name string) error {
	switch name {
	case tslineups.FieldLastUpdated:
		m.ClearLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown TSLineups nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TSLineupsMutation) ResetField(name string) error {
	switch name {
	case tslineups.FieldFormation:
		m.ResetFormation()
		return nil
	case tslineups.FieldPlayed:
		m.ResetPlayed()
		return nil
	case tslineups.FieldTeamID:
		m.ResetTeamID()
		return nil
	case tslineups.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown TSLineups field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TSLineupsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.team != nil {
		edges = append(edges, tslineups.EdgeTeam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TSLineupsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tslineups.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TSLineupsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TSLineupsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TSLineupsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedteam {
		edges = append(edges, tslineups.EdgeTeam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TSLineupsMutation) EdgeCleared(name string) bool {
	switch name {
	case tslineups.EdgeTeam:
		return m.clearedteam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TSLineupsMutation) ClearEdge(name string) error {
	switch name {
	case tslineups.EdgeTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown TSLineups unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TSLineupsMutation) ResetEdge(name string) error {
	switch name {
	case tslineups.EdgeTeam:
		m.ResetTeam()
		return nil
	}
	return fmt.Errorf("unknown TSLineups edge %s", name)
}

// TSPenaltyMutation represents an operation that mutates the TSPenalty nodes in the graph.
type TSPenaltyMutation struct {
	config
	op               Op
	typ              string
	id               *int
	total            *int
	addtotal         *int
	scoredTotal      *int
	addscoredTotal   *int
	missedTotal      *int
	addmissedTotal   *int
	scoredPercentage *string
	missedPercentage *string
	lastUpdated      *time.Time
	clearedFields    map[string]struct{}
	team             *int
	clearedteam      bool
	done             bool
	oldValue         func(context.Context) (*TSPenalty, error)
	predicates       []predicate.TSPenalty
}

var _ ent.Mutation = (*TSPenaltyMutation)(nil)

// tspenaltyOption allows management of the mutation configuration using functional options.
type tspenaltyOption func(*TSPenaltyMutation)

// newTSPenaltyMutation creates new mutation for the TSPenalty entity.
func newTSPenaltyMutation(c config, op Op, opts ...tspenaltyOption) *TSPenaltyMutation {
	m := &TSPenaltyMutation{
		config:        c,
		op:            op,
		typ:           TypeTSPenalty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTSPenaltyID sets the ID field of the mutation.
func withTSPenaltyID(id int) tspenaltyOption {
	return func(m *TSPenaltyMutation) {
		var (
			err   error
			once  sync.Once
			value *TSPenalty
		)
		m.oldValue = func(ctx context.Context) (*TSPenalty, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TSPenalty.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTSPenalty sets the old TSPenalty of the mutation.
func withTSPenalty(node *TSPenalty) tspenaltyOption {
	return func(m *TSPenaltyMutation) {
		m.oldValue = func(context.Context) (*TSPenalty, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TSPenaltyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TSPenaltyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TSPenaltyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TSPenaltyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TSPenalty.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTotal sets the "total" field.
func (m *TSPenaltyMutation) SetTotal(i int) {
	m.total = &i
	m.addtotal = nil
}

// Total returns the value of the "total" field in the mutation.
func (m *TSPenaltyMutation) Total() (r int, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old "total" field's value of the TSPenalty entity.
// If the TSPenalty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSPenaltyMutation) OldTotal(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// AddTotal adds i to the "total" field.
func (m *TSPenaltyMutation) AddTotal(i int) {
	if m.addtotal != nil {
		*m.addtotal += i
	} else {
		m.addtotal = &i
	}
}

// AddedTotal returns the value that was added to the "total" field in this mutation.
func (m *TSPenaltyMutation) AddedTotal() (r int, exists bool) {
	v := m.addtotal
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotal clears the value of the "total" field.
func (m *TSPenaltyMutation) ClearTotal() {
	m.total = nil
	m.addtotal = nil
	m.clearedFields[tspenalty.FieldTotal] = struct{}{}
}

// TotalCleared returns if the "total" field was cleared in this mutation.
func (m *TSPenaltyMutation) TotalCleared() bool {
	_, ok := m.clearedFields[tspenalty.FieldTotal]
	return ok
}

// ResetTotal resets all changes to the "total" field.
func (m *TSPenaltyMutation) ResetTotal() {
	m.total = nil
	m.addtotal = nil
	delete(m.clearedFields, tspenalty.FieldTotal)
}

// SetScoredTotal sets the "scoredTotal" field.
func (m *TSPenaltyMutation) SetScoredTotal(i int) {
	m.scoredTotal = &i
	m.addscoredTotal = nil
}

// ScoredTotal returns the value of the "scoredTotal" field in the mutation.
func (m *TSPenaltyMutation) ScoredTotal() (r int, exists bool) {
	v := m.scoredTotal
	if v == nil {
		return
	}
	return *v, true
}

// OldScoredTotal returns the old "scoredTotal" field's value of the TSPenalty entity.
// If the TSPenalty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSPenaltyMutation) OldScoredTotal(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScoredTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScoredTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScoredTotal: %w", err)
	}
	return oldValue.ScoredTotal, nil
}

// AddScoredTotal adds i to the "scoredTotal" field.
func (m *TSPenaltyMutation) AddScoredTotal(i int) {
	if m.addscoredTotal != nil {
		*m.addscoredTotal += i
	} else {
		m.addscoredTotal = &i
	}
}

// AddedScoredTotal returns the value that was added to the "scoredTotal" field in this mutation.
func (m *TSPenaltyMutation) AddedScoredTotal() (r int, exists bool) {
	v := m.addscoredTotal
	if v == nil {
		return
	}
	return *v, true
}

// ClearScoredTotal clears the value of the "scoredTotal" field.
func (m *TSPenaltyMutation) ClearScoredTotal() {
	m.scoredTotal = nil
	m.addscoredTotal = nil
	m.clearedFields[tspenalty.FieldScoredTotal] = struct{}{}
}

// ScoredTotalCleared returns if the "scoredTotal" field was cleared in this mutation.
func (m *TSPenaltyMutation) ScoredTotalCleared() bool {
	_, ok := m.clearedFields[tspenalty.FieldScoredTotal]
	return ok
}

// ResetScoredTotal resets all changes to the "scoredTotal" field.
func (m *TSPenaltyMutation) ResetScoredTotal() {
	m.scoredTotal = nil
	m.addscoredTotal = nil
	delete(m.clearedFields, tspenalty.FieldScoredTotal)
}

// SetMissedTotal sets the "missedTotal" field.
func (m *TSPenaltyMutation) SetMissedTotal(i int) {
	m.missedTotal = &i
	m.addmissedTotal = nil
}

// MissedTotal returns the value of the "missedTotal" field in the mutation.
func (m *TSPenaltyMutation) MissedTotal() (r int, exists bool) {
	v := m.missedTotal
	if v == nil {
		return
	}
	return *v, true
}

// OldMissedTotal returns the old "missedTotal" field's value of the TSPenalty entity.
// If the TSPenalty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSPenaltyMutation) OldMissedTotal(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissedTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissedTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissedTotal: %w", err)
	}
	return oldValue.MissedTotal, nil
}

// AddMissedTotal adds i to the "missedTotal" field.
func (m *TSPenaltyMutation) AddMissedTotal(i int) {
	if m.addmissedTotal != nil {
		*m.addmissedTotal += i
	} else {
		m.addmissedTotal = &i
	}
}

// AddedMissedTotal returns the value that was added to the "missedTotal" field in this mutation.
func (m *TSPenaltyMutation) AddedMissedTotal() (r int, exists bool) {
	v := m.addmissedTotal
	if v == nil {
		return
	}
	return *v, true
}

// ClearMissedTotal clears the value of the "missedTotal" field.
func (m *TSPenaltyMutation) ClearMissedTotal() {
	m.missedTotal = nil
	m.addmissedTotal = nil
	m.clearedFields[tspenalty.FieldMissedTotal] = struct{}{}
}

// MissedTotalCleared returns if the "missedTotal" field was cleared in this mutation.
func (m *TSPenaltyMutation) MissedTotalCleared() bool {
	_, ok := m.clearedFields[tspenalty.FieldMissedTotal]
	return ok
}

// ResetMissedTotal resets all changes to the "missedTotal" field.
func (m *TSPenaltyMutation) ResetMissedTotal() {
	m.missedTotal = nil
	m.addmissedTotal = nil
	delete(m.clearedFields, tspenalty.FieldMissedTotal)
}

// SetScoredPercentage sets the "scoredPercentage" field.
func (m *TSPenaltyMutation) SetScoredPercentage(s string) {
	m.scoredPercentage = &s
}

// ScoredPercentage returns the value of the "scoredPercentage" field in the mutation.
func (m *TSPenaltyMutation) ScoredPercentage() (r string, exists bool) {
	v := m.scoredPercentage
	if v == nil {
		return
	}
	return *v, true
}

// OldScoredPercentage returns the old "scoredPercentage" field's value of the TSPenalty entity.
// If the TSPenalty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSPenaltyMutation) OldScoredPercentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScoredPercentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScoredPercentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScoredPercentage: %w", err)
	}
	return oldValue.ScoredPercentage, nil
}

// ClearScoredPercentage clears the value of the "scoredPercentage" field.
func (m *TSPenaltyMutation) ClearScoredPercentage() {
	m.scoredPercentage = nil
	m.clearedFields[tspenalty.FieldScoredPercentage] = struct{}{}
}

// ScoredPercentageCleared returns if the "scoredPercentage" field was cleared in this mutation.
func (m *TSPenaltyMutation) ScoredPercentageCleared() bool {
	_, ok := m.clearedFields[tspenalty.FieldScoredPercentage]
	return ok
}

// ResetScoredPercentage resets all changes to the "scoredPercentage" field.
func (m *TSPenaltyMutation) ResetScoredPercentage() {
	m.scoredPercentage = nil
	delete(m.clearedFields, tspenalty.FieldScoredPercentage)
}

// SetMissedPercentage sets the "missedPercentage" field.
func (m *TSPenaltyMutation) SetMissedPercentage(s string) {
	m.missedPercentage = &s
}

// MissedPercentage returns the value of the "missedPercentage" field in the mutation.
func (m *TSPenaltyMutation) MissedPercentage() (r string, exists bool) {
	v := m.missedPercentage
	if v == nil {
		return
	}
	return *v, true
}

// OldMissedPercentage returns the old "missedPercentage" field's value of the TSPenalty entity.
// If the TSPenalty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSPenaltyMutation) OldMissedPercentage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMissedPercentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMissedPercentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMissedPercentage: %w", err)
	}
	return oldValue.MissedPercentage, nil
}

// ClearMissedPercentage clears the value of the "missedPercentage" field.
func (m *TSPenaltyMutation) ClearMissedPercentage() {
	m.missedPercentage = nil
	m.clearedFields[tspenalty.FieldMissedPercentage] = struct{}{}
}

// MissedPercentageCleared returns if the "missedPercentage" field was cleared in this mutation.
func (m *TSPenaltyMutation) MissedPercentageCleared() bool {
	_, ok := m.clearedFields[tspenalty.FieldMissedPercentage]
	return ok
}

// ResetMissedPercentage resets all changes to the "missedPercentage" field.
func (m *TSPenaltyMutation) ResetMissedPercentage() {
	m.missedPercentage = nil
	delete(m.clearedFields, tspenalty.FieldMissedPercentage)
}

// SetLastUpdated sets the "lastUpdated" field.
func (m *TSPenaltyMutation) SetLastUpdated(t time.Time) {
	m.lastUpdated = &t
}

// LastUpdated returns the value of the "lastUpdated" field in the mutation.
func (m *TSPenaltyMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.lastUpdated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "lastUpdated" field's value of the TSPenalty entity.
// If the TSPenalty object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TSPenaltyMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ClearLastUpdated clears the value of the "lastUpdated" field.
func (m *TSPenaltyMutation) ClearLastUpdated() {
	m.lastUpdated = nil
	m.clearedFields[tspenalty.FieldLastUpdated] = struct{}{}
}

// LastUpdatedCleared returns if the "lastUpdated" field was cleared in this mutation.
func (m *TSPenaltyMutation) LastUpdatedCleared() bool {
	_, ok := m.clearedFields[tspenalty.FieldLastUpdated]
	return ok
}

// ResetLastUpdated resets all changes to the "lastUpdated" field.
func (m *TSPenaltyMutation) ResetLastUpdated() {
	m.lastUpdated = nil
	delete(m.clearedFields, tspenalty.FieldLastUpdated)
}

// SetTeamID sets the "team" edge to the Team entity by id.
func (m *TSPenaltyMutation) SetTeamID(id int) {
	m.team = &id
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *TSPenaltyMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *TSPenaltyMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamID returns the "team" edge ID in the mutation.
func (m *TSPenaltyMutation) TeamID() (id int, exists bool) {
	if m.team != nil {
		return *m.team, true
	}
	return
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *TSPenaltyMutation) TeamIDs() (ids []int) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *TSPenaltyMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// Where appends a list predicates to the TSPenaltyMutation builder.
func (m *TSPenaltyMutation) Where(ps ...predicate.TSPenalty) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TSPenaltyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TSPenaltyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TSPenalty, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TSPenaltyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TSPenaltyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TSPenalty).
func (m *TSPenaltyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TSPenaltyMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.total != nil {
		fields = append(fields, tspenalty.FieldTotal)
	}
	if m.scoredTotal != nil {
		fields = append(fields, tspenalty.FieldScoredTotal)
	}
	if m.missedTotal != nil {
		fields = append(fields, tspenalty.FieldMissedTotal)
	}
	if m.scoredPercentage != nil {
		fields = append(fields, tspenalty.FieldScoredPercentage)
	}
	if m.missedPercentage != nil {
		fields = append(fields, tspenalty.FieldMissedPercentage)
	}
	if m.lastUpdated != nil {
		fields = append(fields, tspenalty.FieldLastUpdated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TSPenaltyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tspenalty.FieldTotal:
		return m.Total()
	case tspenalty.FieldScoredTotal:
		return m.ScoredTotal()
	case tspenalty.FieldMissedTotal:
		return m.MissedTotal()
	case tspenalty.FieldScoredPercentage:
		return m.ScoredPercentage()
	case tspenalty.FieldMissedPercentage:
		return m.MissedPercentage()
	case tspenalty.FieldLastUpdated:
		return m.LastUpdated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TSPenaltyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tspenalty.FieldTotal:
		return m.OldTotal(ctx)
	case tspenalty.FieldScoredTotal:
		return m.OldScoredTotal(ctx)
	case tspenalty.FieldMissedTotal:
		return m.OldMissedTotal(ctx)
	case tspenalty.FieldScoredPercentage:
		return m.OldScoredPercentage(ctx)
	case tspenalty.FieldMissedPercentage:
		return m.OldMissedPercentage(ctx)
	case tspenalty.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	}
	return nil, fmt.Errorf("unknown TSPenalty field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TSPenaltyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tspenalty.FieldTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	case tspenalty.FieldScoredTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScoredTotal(v)
		return nil
	case tspenalty.FieldMissedTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissedTotal(v)
		return nil
	case tspenalty.FieldScoredPercentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScoredPercentage(v)
		return nil
	case tspenalty.FieldMissedPercentage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMissedPercentage(v)
		return nil
	case tspenalty.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	}
	return fmt.Errorf("unknown TSPenalty field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TSPenaltyMutation) AddedFields() []string {
	var fields []string
	if m.addtotal != nil {
		fields = append(fields, tspenalty.FieldTotal)
	}
	if m.addscoredTotal != nil {
		fields = append(fields, tspenalty.FieldScoredTotal)
	}
	if m.addmissedTotal != nil {
		fields = append(fields, tspenalty.FieldMissedTotal)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TSPenaltyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tspenalty.FieldTotal:
		return m.AddedTotal()
	case tspenalty.FieldScoredTotal:
		return m.AddedScoredTotal()
	case tspenalty.FieldMissedTotal:
		return m.AddedMissedTotal()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TSPenaltyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tspenalty.FieldTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotal(v)
		return nil
	case tspenalty.FieldScoredTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScoredTotal(v)
		return nil
	case tspenalty.FieldMissedTotal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMissedTotal(v)
		return nil
	}
	return fmt.Errorf("unknown TSPenalty numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TSPenaltyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tspenalty.FieldTotal) {
		fields = append(fields, tspenalty.FieldTotal)
	}
	if m.FieldCleared(tspenalty.FieldScoredTotal) {
		fields = append(fields, tspenalty.FieldScoredTotal)
	}
	if m.FieldCleared(tspenalty.FieldMissedTotal) {
		fields = append(fields, tspenalty.FieldMissedTotal)
	}
	if m.FieldCleared(tspenalty.FieldScoredPercentage) {
		fields = append(fields, tspenalty.FieldScoredPercentage)
	}
	if m.FieldCleared(tspenalty.FieldMissedPercentage) {
		fields = append(fields, tspenalty.FieldMissedPercentage)
	}
	if m.FieldCleared(tspenalty.FieldLastUpdated) {
		fields = append(fields, tspenalty.FieldLastUpdated)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TSPenaltyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TSPenaltyMutation) ClearField(name string) error {
	switch name {
	case tspenalty.FieldTotal:
		m.ClearTotal()
		return nil
	case tspenalty.FieldScoredTotal:
		m.ClearScoredTotal()
		return nil
	case tspenalty.FieldMissedTotal:
		m.ClearMissedTotal()
		return nil
	case tspenalty.FieldScoredPercentage:
		m.ClearScoredPercentage()
		return nil
	case tspenalty.FieldMissedPercentage:
		m.ClearMissedPercentage()
		return nil
	case tspenalty.FieldLastUpdated:
		m.ClearLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown TSPenalty nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TSPenaltyMutation) ResetField(name string) error {
	switch name {
	case tspenalty.FieldTotal:
		m.ResetTotal()
		return nil
	case tspenalty.FieldScoredTotal:
		m.ResetScoredTotal()
		return nil
	case tspenalty.FieldMissedTotal:
		m.ResetMissedTotal()
		return nil
	case tspenalty.FieldScoredPercentage:
		m.ResetScoredPercentage()
		return nil
	case tspenalty.FieldMissedPercentage:
		m.ResetMissedPercentage()
		return nil
	case tspenalty.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown TSPenalty field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TSPenaltyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.team != nil {
		edges = append(edges, tspenalty.EdgeTeam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TSPenaltyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tspenalty.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TSPenaltyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TSPenaltyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TSPenaltyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedteam {
		edges = append(edges, tspenalty.EdgeTeam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TSPenaltyMutation) EdgeCleared(name string) bool {
	switch name {
	case tspenalty.EdgeTeam:
		return m.clearedteam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TSPenaltyMutation) ClearEdge(name string) error {
	switch name {
	case tspenalty.EdgeTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown TSPenalty unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TSPenaltyMutation) ResetEdge(name string) error {
	switch name {
	case tspenalty.EdgeTeam:
		m.ResetTeam()
		return nil
	}
	return fmt.Errorf("unknown TSPenalty edge %s", name)
}

// TeamMutation represents an operation that mutates the Team nodes in the graph.
type TeamMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	form                         *string
	lastUpdated                  *time.Time
	clearedFields                map[string]struct{}
	season                       *int
	clearedseason                bool
	club                         *int
	clearedclub                  bool
	standings                    map[int]struct{}
	removedstandings             map[int]struct{}
	clearedstandings             bool
	homeFixtures                 map[int]struct{}
	removedhomeFixtures          map[int]struct{}
	clearedhomeFixtures          bool
	awayFixtures                 map[int]struct{}
	removedawayFixtures          map[int]struct{}
	clearedawayFixtures          bool
	fixtureEvents                map[int]struct{}
	removedfixtureEvents         map[int]struct{}
	clearedfixtureEvents         bool
	fixtureLineups               map[int]struct{}
	removedfixtureLineups        map[int]struct{}
	clearedfixtureLineups        bool
	players                      map[int]struct{}
	removedplayers               map[int]struct{}
	clearedplayers               bool
	squad                        map[int]struct{}
	removedsquad                 map[int]struct{}
	clearedsquad                 bool
	biggest_stats                *int
	clearedbiggest_stats         bool
	cards_stats                  *int
	clearedcards_stats           bool
	clean_sheet_stats            *int
	clearedclean_sheet_stats     bool
	failed_to_score_stats        *int
	clearedfailed_to_score_stats bool
	fixtures_stats               *int
	clearedfixtures_stats        bool
	goals_stats                  *int
	clearedgoals_stats           bool
	lineups                      map[int]struct{}
	removedlineups               map[int]struct{}
	clearedlineups               bool
	penalty_stats                *int
	clearedpenalty_stats         bool
	done                         bool
	oldValue                     func(context.Context) (*Team, error)
	predicates                   []predicate.Team
}

var _ ent.Mutation = (*TeamMutation)(nil)

// teamOption allows management of the mutation configuration using functional options.
type teamOption func(*TeamMutation)

// newTeamMutation creates new mutation for the Team entity.
func newTeamMutation(c config, op Op, opts ...teamOption) *TeamMutation {
	m := &TeamMutation{
		config:        c,
		op:            op,
		typ:           TypeTeam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamID sets the ID field of the mutation.
func withTeamID(id int) teamOption {
	return func(m *TeamMutation) {
		var (
			err   error
			once  sync.Once
			value *Team
		)
		m.oldValue = func(ctx context.Context) (*Team, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Team.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeam sets the old Team of the mutation.
func withTeam(node *Team) teamOption {
	return func(m *TeamMutation) {
		m.oldValue = func(context.Context) (*Team, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Team.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetForm sets the "form" field.
func (m *TeamMutation) SetForm(s string) {
	m.form = &s
}

// Form returns the value of the "form" field in the mutation.
func (m *TeamMutation) Form() (r string, exists bool) {
	v := m.form
	if v == nil {
		return
	}
	return *v, true
}

// OldForm returns the old "form" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldForm(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForm: %w", err)
	}
	return oldValue.Form, nil
}

// ClearForm clears the value of the "form" field.
func (m *TeamMutation) ClearForm() {
	m.form = nil
	m.clearedFields[team.FieldForm] = struct{}{}
}

// FormCleared returns if the "form" field was cleared in this mutation.
func (m *TeamMutation) FormCleared() bool {
	_, ok := m.clearedFields[team.FieldForm]
	return ok
}

// ResetForm resets all changes to the "form" field.
func (m *TeamMutation) ResetForm() {
	m.form = nil
	delete(m.clearedFields, team.FieldForm)
}

// SetLastUpdated sets the "lastUpdated" field.
func (m *TeamMutation) SetLastUpdated(t time.Time) {
	m.lastUpdated = &t
}

// LastUpdated returns the value of the "lastUpdated" field in the mutation.
func (m *TeamMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.lastUpdated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "lastUpdated" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ClearLastUpdated clears the value of the "lastUpdated" field.
func (m *TeamMutation) ClearLastUpdated() {
	m.lastUpdated = nil
	m.clearedFields[team.FieldLastUpdated] = struct{}{}
}

// LastUpdatedCleared returns if the "lastUpdated" field was cleared in this mutation.
func (m *TeamMutation) LastUpdatedCleared() bool {
	_, ok := m.clearedFields[team.FieldLastUpdated]
	return ok
}

// ResetLastUpdated resets all changes to the "lastUpdated" field.
func (m *TeamMutation) ResetLastUpdated() {
	m.lastUpdated = nil
	delete(m.clearedFields, team.FieldLastUpdated)
}

// SetSeasonID sets the "season" edge to the Season entity by id.
func (m *TeamMutation) SetSeasonID(id int) {
	m.season = &id
}

// ClearSeason clears the "season" edge to the Season entity.
func (m *TeamMutation) ClearSeason() {
	m.clearedseason = true
}

// SeasonCleared reports if the "season" edge to the Season entity was cleared.
func (m *TeamMutation) SeasonCleared() bool {
	return m.clearedseason
}

// SeasonID returns the "season" edge ID in the mutation.
func (m *TeamMutation) SeasonID() (id int, exists bool) {
	if m.season != nil {
		return *m.season, true
	}
	return
}

// SeasonIDs returns the "season" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SeasonID instead. It exists only for internal usage by the builders.
func (m *TeamMutation) SeasonIDs() (ids []int) {
	if id := m.season; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSeason resets all changes to the "season" edge.
func (m *TeamMutation) ResetSeason() {
	m.season = nil
	m.clearedseason = false
}

// SetClubID sets the "club" edge to the Club entity by id.
func (m *TeamMutation) SetClubID(id int) {
	m.club = &id
}

// ClearClub clears the "club" edge to the Club entity.
func (m *TeamMutation) ClearClub() {
	m.clearedclub = true
}

// ClubCleared reports if the "club" edge to the Club entity was cleared.
func (m *TeamMutation) ClubCleared() bool {
	return m.clearedclub
}

// ClubID returns the "club" edge ID in the mutation.
func (m *TeamMutation) ClubID() (id int, exists bool) {
	if m.club != nil {
		return *m.club, true
	}
	return
}

// ClubIDs returns the "club" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClubID instead. It exists only for internal usage by the builders.
func (m *TeamMutation) ClubIDs() (ids []int) {
	if id := m.club; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClub resets all changes to the "club" edge.
func (m *TeamMutation) ResetClub() {
	m.club = nil
	m.clearedclub = false
}

// AddStandingIDs adds the "standings" edge to the Standings entity by ids.
func (m *TeamMutation) AddStandingIDs(ids ...int) {
	if m.standings == nil {
		m.standings = make(map[int]struct{})
	}
	for i := range ids {
		m.standings[ids[i]] = struct{}{}
	}
}

// ClearStandings clears the "standings" edge to the Standings entity.
func (m *TeamMutation) ClearStandings() {
	m.clearedstandings = true
}

// StandingsCleared reports if the "standings" edge to the Standings entity was cleared.
func (m *TeamMutation) StandingsCleared() bool {
	return m.clearedstandings
}

// RemoveStandingIDs removes the "standings" edge to the Standings entity by IDs.
func (m *TeamMutation) RemoveStandingIDs(ids ...int) {
	if m.removedstandings == nil {
		m.removedstandings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.standings, ids[i])
		m.removedstandings[ids[i]] = struct{}{}
	}
}

// RemovedStandings returns the removed IDs of the "standings" edge to the Standings entity.
func (m *TeamMutation) RemovedStandingsIDs() (ids []int) {
	for id := range m.removedstandings {
		ids = append(ids, id)
	}
	return
}

// StandingsIDs returns the "standings" edge IDs in the mutation.
func (m *TeamMutation) StandingsIDs() (ids []int) {
	for id := range m.standings {
		ids = append(ids, id)
	}
	return
}

// ResetStandings resets all changes to the "standings" edge.
func (m *TeamMutation) ResetStandings() {
	m.standings = nil
	m.clearedstandings = false
	m.removedstandings = nil
}

// AddHomeFixtureIDs adds the "homeFixtures" edge to the Fixture entity by ids.
func (m *TeamMutation) AddHomeFixtureIDs(ids ...int) {
	if m.homeFixtures == nil {
		m.homeFixtures = make(map[int]struct{})
	}
	for i := range ids {
		m.homeFixtures[ids[i]] = struct{}{}
	}
}

// ClearHomeFixtures clears the "homeFixtures" edge to the Fixture entity.
func (m *TeamMutation) ClearHomeFixtures() {
	m.clearedhomeFixtures = true
}

// HomeFixturesCleared reports if the "homeFixtures" edge to the Fixture entity was cleared.
func (m *TeamMutation) HomeFixturesCleared() bool {
	return m.clearedhomeFixtures
}

// RemoveHomeFixtureIDs removes the "homeFixtures" edge to the Fixture entity by IDs.
func (m *TeamMutation) RemoveHomeFixtureIDs(ids ...int) {
	if m.removedhomeFixtures == nil {
		m.removedhomeFixtures = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.homeFixtures, ids[i])
		m.removedhomeFixtures[ids[i]] = struct{}{}
	}
}

// RemovedHomeFixtures returns the removed IDs of the "homeFixtures" edge to the Fixture entity.
func (m *TeamMutation) RemovedHomeFixturesIDs() (ids []int) {
	for id := range m.removedhomeFixtures {
		ids = append(ids, id)
	}
	return
}

// HomeFixturesIDs returns the "homeFixtures" edge IDs in the mutation.
func (m *TeamMutation) HomeFixturesIDs() (ids []int) {
	for id := range m.homeFixtures {
		ids = append(ids, id)
	}
	return
}

// ResetHomeFixtures resets all changes to the "homeFixtures" edge.
func (m *TeamMutation) ResetHomeFixtures() {
	m.homeFixtures = nil
	m.clearedhomeFixtures = false
	m.removedhomeFixtures = nil
}

// AddAwayFixtureIDs adds the "awayFixtures" edge to the Fixture entity by ids.
func (m *TeamMutation) AddAwayFixtureIDs(ids ...int) {
	if m.awayFixtures == nil {
		m.awayFixtures = make(map[int]struct{})
	}
	for i := range ids {
		m.awayFixtures[ids[i]] = struct{}{}
	}
}

// ClearAwayFixtures clears the "awayFixtures" edge to the Fixture entity.
func (m *TeamMutation) ClearAwayFixtures() {
	m.clearedawayFixtures = true
}

// AwayFixturesCleared reports if the "awayFixtures" edge to the Fixture entity was cleared.
func (m *TeamMutation) AwayFixturesCleared() bool {
	return m.clearedawayFixtures
}

// RemoveAwayFixtureIDs removes the "awayFixtures" edge to the Fixture entity by IDs.
func (m *TeamMutation) RemoveAwayFixtureIDs(ids ...int) {
	if m.removedawayFixtures == nil {
		m.removedawayFixtures = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.awayFixtures, ids[i])
		m.removedawayFixtures[ids[i]] = struct{}{}
	}
}

// RemovedAwayFixtures returns the removed IDs of the "awayFixtures" edge to the Fixture entity.
func (m *TeamMutation) RemovedAwayFixturesIDs() (ids []int) {
	for id := range m.removedawayFixtures {
		ids = append(ids, id)
	}
	return
}

// AwayFixturesIDs returns the "awayFixtures" edge IDs in the mutation.
func (m *TeamMutation) AwayFixturesIDs() (ids []int) {
	for id := range m.awayFixtures {
		ids = append(ids, id)
	}
	return
}

// ResetAwayFixtures resets all changes to the "awayFixtures" edge.
func (m *TeamMutation) ResetAwayFixtures() {
	m.awayFixtures = nil
	m.clearedawayFixtures = false
	m.removedawayFixtures = nil
}

// AddFixtureEventIDs adds the "fixtureEvents" edge to the FixtureEvents entity by ids.
func (m *TeamMutation) AddFixtureEventIDs(ids ...int) {
	if m.fixtureEvents == nil {
		m.fixtureEvents = make(map[int]struct{})
	}
	for i := range ids {
		m.fixtureEvents[ids[i]] = struct{}{}
	}
}

// ClearFixtureEvents clears the "fixtureEvents" edge to the FixtureEvents entity.
func (m *TeamMutation) ClearFixtureEvents() {
	m.clearedfixtureEvents = true
}

// FixtureEventsCleared reports if the "fixtureEvents" edge to the FixtureEvents entity was cleared.
func (m *TeamMutation) FixtureEventsCleared() bool {
	return m.clearedfixtureEvents
}

// RemoveFixtureEventIDs removes the "fixtureEvents" edge to the FixtureEvents entity by IDs.
func (m *TeamMutation) RemoveFixtureEventIDs(ids ...int) {
	if m.removedfixtureEvents == nil {
		m.removedfixtureEvents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.fixtureEvents, ids[i])
		m.removedfixtureEvents[ids[i]] = struct{}{}
	}
}

// RemovedFixtureEvents returns the removed IDs of the "fixtureEvents" edge to the FixtureEvents entity.
func (m *TeamMutation) RemovedFixtureEventsIDs() (ids []int) {
	for id := range m.removedfixtureEvents {
		ids = append(ids, id)
	}
	return
}

// FixtureEventsIDs returns the "fixtureEvents" edge IDs in the mutation.
func (m *TeamMutation) FixtureEventsIDs() (ids []int) {
	for id := range m.fixtureEvents {
		ids = append(ids, id)
	}
	return
}

// ResetFixtureEvents resets all changes to the "fixtureEvents" edge.
func (m *TeamMutation) ResetFixtureEvents() {
	m.fixtureEvents = nil
	m.clearedfixtureEvents = false
	m.removedfixtureEvents = nil
}

// AddFixtureLineupIDs adds the "fixtureLineups" edge to the FixtureLineups entity by ids.
func (m *TeamMutation) AddFixtureLineupIDs(ids ...int) {
	if m.fixtureLineups == nil {
		m.fixtureLineups = make(map[int]struct{})
	}
	for i := range ids {
		m.fixtureLineups[ids[i]] = struct{}{}
	}
}

// ClearFixtureLineups clears the "fixtureLineups" edge to the FixtureLineups entity.
func (m *TeamMutation) ClearFixtureLineups() {
	m.clearedfixtureLineups = true
}

// FixtureLineupsCleared reports if the "fixtureLineups" edge to the FixtureLineups entity was cleared.
func (m *TeamMutation) FixtureLineupsCleared() bool {
	return m.clearedfixtureLineups
}

// RemoveFixtureLineupIDs removes the "fixtureLineups" edge to the FixtureLineups entity by IDs.
func (m *TeamMutation) RemoveFixtureLineupIDs(ids ...int) {
	if m.removedfixtureLineups == nil {
		m.removedfixtureLineups = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.fixtureLineups, ids[i])
		m.removedfixtureLineups[ids[i]] = struct{}{}
	}
}

// RemovedFixtureLineups returns the removed IDs of the "fixtureLineups" edge to the FixtureLineups entity.
func (m *TeamMutation) RemovedFixtureLineupsIDs() (ids []int) {
	for id := range m.removedfixtureLineups {
		ids = append(ids, id)
	}
	return
}

// FixtureLineupsIDs returns the "fixtureLineups" edge IDs in the mutation.
func (m *TeamMutation) FixtureLineupsIDs() (ids []int) {
	for id := range m.fixtureLineups {
		ids = append(ids, id)
	}
	return
}

// ResetFixtureLineups resets all changes to the "fixtureLineups" edge.
func (m *TeamMutation) ResetFixtureLineups() {
	m.fixtureLineups = nil
	m.clearedfixtureLineups = false
	m.removedfixtureLineups = nil
}

// AddPlayerIDs adds the "players" edge to the Player entity by ids.
func (m *TeamMutation) AddPlayerIDs(ids ...int) {
	if m.players == nil {
		m.players = make(map[int]struct{})
	}
	for i := range ids {
		m.players[ids[i]] = struct{}{}
	}
}

// ClearPlayers clears the "players" edge to the Player entity.
func (m *TeamMutation) ClearPlayers() {
	m.clearedplayers = true
}

// PlayersCleared reports if the "players" edge to the Player entity was cleared.
func (m *TeamMutation) PlayersCleared() bool {
	return m.clearedplayers
}

// RemovePlayerIDs removes the "players" edge to the Player entity by IDs.
func (m *TeamMutation) RemovePlayerIDs(ids ...int) {
	if m.removedplayers == nil {
		m.removedplayers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.players, ids[i])
		m.removedplayers[ids[i]] = struct{}{}
	}
}

// RemovedPlayers returns the removed IDs of the "players" edge to the Player entity.
func (m *TeamMutation) RemovedPlayersIDs() (ids []int) {
	for id := range m.removedplayers {
		ids = append(ids, id)
	}
	return
}

// PlayersIDs returns the "players" edge IDs in the mutation.
func (m *TeamMutation) PlayersIDs() (ids []int) {
	for id := range m.players {
		ids = append(ids, id)
	}
	return
}

// ResetPlayers resets all changes to the "players" edge.
func (m *TeamMutation) ResetPlayers() {
	m.players = nil
	m.clearedplayers = false
	m.removedplayers = nil
}

// AddSquadIDs adds the "squad" edge to the Squad entity by ids.
func (m *TeamMutation) AddSquadIDs(ids ...int) {
	if m.squad == nil {
		m.squad = make(map[int]struct{})
	}
	for i := range ids {
		m.squad[ids[i]] = struct{}{}
	}
}

// ClearSquad clears the "squad" edge to the Squad entity.
func (m *TeamMutation) ClearSquad() {
	m.clearedsquad = true
}

// SquadCleared reports if the "squad" edge to the Squad entity was cleared.
func (m *TeamMutation) SquadCleared() bool {
	return m.clearedsquad
}

// RemoveSquadIDs removes the "squad" edge to the Squad entity by IDs.
func (m *TeamMutation) RemoveSquadIDs(ids ...int) {
	if m.removedsquad == nil {
		m.removedsquad = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.squad, ids[i])
		m.removedsquad[ids[i]] = struct{}{}
	}
}

// RemovedSquad returns the removed IDs of the "squad" edge to the Squad entity.
func (m *TeamMutation) RemovedSquadIDs() (ids []int) {
	for id := range m.removedsquad {
		ids = append(ids, id)
	}
	return
}

// SquadIDs returns the "squad" edge IDs in the mutation.
func (m *TeamMutation) SquadIDs() (ids []int) {
	for id := range m.squad {
		ids = append(ids, id)
	}
	return
}

// ResetSquad resets all changes to the "squad" edge.
func (m *TeamMutation) ResetSquad() {
	m.squad = nil
	m.clearedsquad = false
	m.removedsquad = nil
}

// SetBiggestStatsID sets the "biggest_stats" edge to the TSBiggest entity by id.
func (m *TeamMutation) SetBiggestStatsID(id int) {
	m.biggest_stats = &id
}

// ClearBiggestStats clears the "biggest_stats" edge to the TSBiggest entity.
func (m *TeamMutation) ClearBiggestStats() {
	m.clearedbiggest_stats = true
}

// BiggestStatsCleared reports if the "biggest_stats" edge to the TSBiggest entity was cleared.
func (m *TeamMutation) BiggestStatsCleared() bool {
	return m.clearedbiggest_stats
}

// BiggestStatsID returns the "biggest_stats" edge ID in the mutation.
func (m *TeamMutation) BiggestStatsID() (id int, exists bool) {
	if m.biggest_stats != nil {
		return *m.biggest_stats, true
	}
	return
}

// BiggestStatsIDs returns the "biggest_stats" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BiggestStatsID instead. It exists only for internal usage by the builders.
func (m *TeamMutation) BiggestStatsIDs() (ids []int) {
	if id := m.biggest_stats; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBiggestStats resets all changes to the "biggest_stats" edge.
func (m *TeamMutation) ResetBiggestStats() {
	m.biggest_stats = nil
	m.clearedbiggest_stats = false
}

// SetCardsStatsID sets the "cards_stats" edge to the TSCards entity by id.
func (m *TeamMutation) SetCardsStatsID(id int) {
	m.cards_stats = &id
}

// ClearCardsStats clears the "cards_stats" edge to the TSCards entity.
func (m *TeamMutation) ClearCardsStats() {
	m.clearedcards_stats = true
}

// CardsStatsCleared reports if the "cards_stats" edge to the TSCards entity was cleared.
func (m *TeamMutation) CardsStatsCleared() bool {
	return m.clearedcards_stats
}

// CardsStatsID returns the "cards_stats" edge ID in the mutation.
func (m *TeamMutation) CardsStatsID() (id int, exists bool) {
	if m.cards_stats != nil {
		return *m.cards_stats, true
	}
	return
}

// CardsStatsIDs returns the "cards_stats" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CardsStatsID instead. It exists only for internal usage by the builders.
func (m *TeamMutation) CardsStatsIDs() (ids []int) {
	if id := m.cards_stats; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCardsStats resets all changes to the "cards_stats" edge.
func (m *TeamMutation) ResetCardsStats() {
	m.cards_stats = nil
	m.clearedcards_stats = false
}

// SetCleanSheetStatsID sets the "clean_sheet_stats" edge to the TSCleanSheet entity by id.
func (m *TeamMutation) SetCleanSheetStatsID(id int) {
	m.clean_sheet_stats = &id
}

// ClearCleanSheetStats clears the "clean_sheet_stats" edge to the TSCleanSheet entity.
func (m *TeamMutation) ClearCleanSheetStats() {
	m.clearedclean_sheet_stats = true
}

// CleanSheetStatsCleared reports if the "clean_sheet_stats" edge to the TSCleanSheet entity was cleared.
func (m *TeamMutation) CleanSheetStatsCleared() bool {
	return m.clearedclean_sheet_stats
}

// CleanSheetStatsID returns the "clean_sheet_stats" edge ID in the mutation.
func (m *TeamMutation) CleanSheetStatsID() (id int, exists bool) {
	if m.clean_sheet_stats != nil {
		return *m.clean_sheet_stats, true
	}
	return
}

// CleanSheetStatsIDs returns the "clean_sheet_stats" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CleanSheetStatsID instead. It exists only for internal usage by the builders.
func (m *TeamMutation) CleanSheetStatsIDs() (ids []int) {
	if id := m.clean_sheet_stats; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCleanSheetStats resets all changes to the "clean_sheet_stats" edge.
func (m *TeamMutation) ResetCleanSheetStats() {
	m.clean_sheet_stats = nil
	m.clearedclean_sheet_stats = false
}

// SetFailedToScoreStatsID sets the "failed_to_score_stats" edge to the TSFailedToScore entity by id.
func (m *TeamMutation) SetFailedToScoreStatsID(id int) {
	m.failed_to_score_stats = &id
}

// ClearFailedToScoreStats clears the "failed_to_score_stats" edge to the TSFailedToScore entity.
func (m *TeamMutation) ClearFailedToScoreStats() {
	m.clearedfailed_to_score_stats = true
}

// FailedToScoreStatsCleared reports if the "failed_to_score_stats" edge to the TSFailedToScore entity was cleared.
func (m *TeamMutation) FailedToScoreStatsCleared() bool {
	return m.clearedfailed_to_score_stats
}

// FailedToScoreStatsID returns the "failed_to_score_stats" edge ID in the mutation.
func (m *TeamMutation) FailedToScoreStatsID() (id int, exists bool) {
	if m.failed_to_score_stats != nil {
		return *m.failed_to_score_stats, true
	}
	return
}

// FailedToScoreStatsIDs returns the "failed_to_score_stats" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FailedToScoreStatsID instead. It exists only for internal usage by the builders.
func (m *TeamMutation) FailedToScoreStatsIDs() (ids []int) {
	if id := m.failed_to_score_stats; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFailedToScoreStats resets all changes to the "failed_to_score_stats" edge.
func (m *TeamMutation) ResetFailedToScoreStats() {
	m.failed_to_score_stats = nil
	m.clearedfailed_to_score_stats = false
}

// SetFixturesStatsID sets the "fixtures_stats" edge to the TSFixtures entity by id.
func (m *TeamMutation) SetFixturesStatsID(id int) {
	m.fixtures_stats = &id
}

// ClearFixturesStats clears the "fixtures_stats" edge to the TSFixtures entity.
func (m *TeamMutation) ClearFixturesStats() {
	m.clearedfixtures_stats = true
}

// FixturesStatsCleared reports if the "fixtures_stats" edge to the TSFixtures entity was cleared.
func (m *TeamMutation) FixturesStatsCleared() bool {
	return m.clearedfixtures_stats
}

// FixturesStatsID returns the "fixtures_stats" edge ID in the mutation.
func (m *TeamMutation) FixturesStatsID() (id int, exists bool) {
	if m.fixtures_stats != nil {
		return *m.fixtures_stats, true
	}
	return
}

// FixturesStatsIDs returns the "fixtures_stats" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FixturesStatsID instead. It exists only for internal usage by the builders.
func (m *TeamMutation) FixturesStatsIDs() (ids []int) {
	if id := m.fixtures_stats; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFixturesStats resets all changes to the "fixtures_stats" edge.
func (m *TeamMutation) ResetFixturesStats() {
	m.fixtures_stats = nil
	m.clearedfixtures_stats = false
}

// SetGoalsStatsID sets the "goals_stats" edge to the TSGoals entity by id.
func (m *TeamMutation) SetGoalsStatsID(id int) {
	m.goals_stats = &id
}

// ClearGoalsStats clears the "goals_stats" edge to the TSGoals entity.
func (m *TeamMutation) ClearGoalsStats() {
	m.clearedgoals_stats = true
}

// GoalsStatsCleared reports if the "goals_stats" edge to the TSGoals entity was cleared.
func (m *TeamMutation) GoalsStatsCleared() bool {
	return m.clearedgoals_stats
}

// GoalsStatsID returns the "goals_stats" edge ID in the mutation.
func (m *TeamMutation) GoalsStatsID() (id int, exists bool) {
	if m.goals_stats != nil {
		return *m.goals_stats, true
	}
	return
}

// GoalsStatsIDs returns the "goals_stats" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GoalsStatsID instead. It exists only for internal usage by the builders.
func (m *TeamMutation) GoalsStatsIDs() (ids []int) {
	if id := m.goals_stats; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGoalsStats resets all changes to the "goals_stats" edge.
func (m *TeamMutation) ResetGoalsStats() {
	m.goals_stats = nil
	m.clearedgoals_stats = false
}

// AddLineupIDs adds the "lineups" edge to the TSLineups entity by ids.
func (m *TeamMutation) AddLineupIDs(ids ...int) {
	if m.lineups == nil {
		m.lineups = make(map[int]struct{})
	}
	for i := range ids {
		m.lineups[ids[i]] = struct{}{}
	}
}

// ClearLineups clears the "lineups" edge to the TSLineups entity.
func (m *TeamMutation) ClearLineups() {
	m.clearedlineups = true
}

// LineupsCleared reports if the "lineups" edge to the TSLineups entity was cleared.
func (m *TeamMutation) LineupsCleared() bool {
	return m.clearedlineups
}

// RemoveLineupIDs removes the "lineups" edge to the TSLineups entity by IDs.
func (m *TeamMutation) RemoveLineupIDs(ids ...int) {
	if m.removedlineups == nil {
		m.removedlineups = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.lineups, ids[i])
		m.removedlineups[ids[i]] = struct{}{}
	}
}

// RemovedLineups returns the removed IDs of the "lineups" edge to the TSLineups entity.
func (m *TeamMutation) RemovedLineupsIDs() (ids []int) {
	for id := range m.removedlineups {
		ids = append(ids, id)
	}
	return
}

// LineupsIDs returns the "lineups" edge IDs in the mutation.
func (m *TeamMutation) LineupsIDs() (ids []int) {
	for id := range m.lineups {
		ids = append(ids, id)
	}
	return
}

// ResetLineups resets all changes to the "lineups" edge.
func (m *TeamMutation) ResetLineups() {
	m.lineups = nil
	m.clearedlineups = false
	m.removedlineups = nil
}

// SetPenaltyStatsID sets the "penalty_stats" edge to the TSPenalty entity by id.
func (m *TeamMutation) SetPenaltyStatsID(id int) {
	m.penalty_stats = &id
}

// ClearPenaltyStats clears the "penalty_stats" edge to the TSPenalty entity.
func (m *TeamMutation) ClearPenaltyStats() {
	m.clearedpenalty_stats = true
}

// PenaltyStatsCleared reports if the "penalty_stats" edge to the TSPenalty entity was cleared.
func (m *TeamMutation) PenaltyStatsCleared() bool {
	return m.clearedpenalty_stats
}

// PenaltyStatsID returns the "penalty_stats" edge ID in the mutation.
func (m *TeamMutation) PenaltyStatsID() (id int, exists bool) {
	if m.penalty_stats != nil {
		return *m.penalty_stats, true
	}
	return
}

// PenaltyStatsIDs returns the "penalty_stats" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PenaltyStatsID instead. It exists only for internal usage by the builders.
func (m *TeamMutation) PenaltyStatsIDs() (ids []int) {
	if id := m.penalty_stats; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPenaltyStats resets all changes to the "penalty_stats" edge.
func (m *TeamMutation) ResetPenaltyStats() {
	m.penalty_stats = nil
	m.clearedpenalty_stats = false
}

// Where appends a list predicates to the TeamMutation builder.
func (m *TeamMutation) Where(ps ...predicate.Team) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TeamMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TeamMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Team, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TeamMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TeamMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Team).
func (m *TeamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.form != nil {
		fields = append(fields, team.FieldForm)
	}
	if m.lastUpdated != nil {
		fields = append(fields, team.FieldLastUpdated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case team.FieldForm:
		return m.Form()
	case team.FieldLastUpdated:
		return m.LastUpdated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case team.FieldForm:
		return m.OldForm(ctx)
	case team.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	}
	return nil, fmt.Errorf("unknown Team field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case team.FieldForm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForm(v)
		return nil
	case team.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Team numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(team.FieldForm) {
		fields = append(fields, team.FieldForm)
	}
	if m.FieldCleared(team.FieldLastUpdated) {
		fields = append(fields, team.FieldLastUpdated)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamMutation) ClearField(name string) error {
	switch name {
	case team.FieldForm:
		m.ClearForm()
		return nil
	case team.FieldLastUpdated:
		m.ClearLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown Team nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamMutation) ResetField(name string) error {
	switch name {
	case team.FieldForm:
		m.ResetForm()
		return nil
	case team.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamMutation) AddedEdges() []string {
	edges := make([]string, 0, 17)
	if m.season != nil {
		edges = append(edges, team.EdgeSeason)
	}
	if m.club != nil {
		edges = append(edges, team.EdgeClub)
	}
	if m.standings != nil {
		edges = append(edges, team.EdgeStandings)
	}
	if m.homeFixtures != nil {
		edges = append(edges, team.EdgeHomeFixtures)
	}
	if m.awayFixtures != nil {
		edges = append(edges, team.EdgeAwayFixtures)
	}
	if m.fixtureEvents != nil {
		edges = append(edges, team.EdgeFixtureEvents)
	}
	if m.fixtureLineups != nil {
		edges = append(edges, team.EdgeFixtureLineups)
	}
	if m.players != nil {
		edges = append(edges, team.EdgePlayers)
	}
	if m.squad != nil {
		edges = append(edges, team.EdgeSquad)
	}
	if m.biggest_stats != nil {
		edges = append(edges, team.EdgeBiggestStats)
	}
	if m.cards_stats != nil {
		edges = append(edges, team.EdgeCardsStats)
	}
	if m.clean_sheet_stats != nil {
		edges = append(edges, team.EdgeCleanSheetStats)
	}
	if m.failed_to_score_stats != nil {
		edges = append(edges, team.EdgeFailedToScoreStats)
	}
	if m.fixtures_stats != nil {
		edges = append(edges, team.EdgeFixturesStats)
	}
	if m.goals_stats != nil {
		edges = append(edges, team.EdgeGoalsStats)
	}
	if m.lineups != nil {
		edges = append(edges, team.EdgeLineups)
	}
	if m.penalty_stats != nil {
		edges = append(edges, team.EdgePenaltyStats)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeSeason:
		if id := m.season; id != nil {
			return []ent.Value{*id}
		}
	case team.EdgeClub:
		if id := m.club; id != nil {
			return []ent.Value{*id}
		}
	case team.EdgeStandings:
		ids := make([]ent.Value, 0, len(m.standings))
		for id := range m.standings {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeHomeFixtures:
		ids := make([]ent.Value, 0, len(m.homeFixtures))
		for id := range m.homeFixtures {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeAwayFixtures:
		ids := make([]ent.Value, 0, len(m.awayFixtures))
		for id := range m.awayFixtures {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeFixtureEvents:
		ids := make([]ent.Value, 0, len(m.fixtureEvents))
		for id := range m.fixtureEvents {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeFixtureLineups:
		ids := make([]ent.Value, 0, len(m.fixtureLineups))
		for id := range m.fixtureLineups {
			ids = append(ids, id)
		}
		return ids
	case team.EdgePlayers:
		ids := make([]ent.Value, 0, len(m.players))
		for id := range m.players {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeSquad:
		ids := make([]ent.Value, 0, len(m.squad))
		for id := range m.squad {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeBiggestStats:
		if id := m.biggest_stats; id != nil {
			return []ent.Value{*id}
		}
	case team.EdgeCardsStats:
		if id := m.cards_stats; id != nil {
			return []ent.Value{*id}
		}
	case team.EdgeCleanSheetStats:
		if id := m.clean_sheet_stats; id != nil {
			return []ent.Value{*id}
		}
	case team.EdgeFailedToScoreStats:
		if id := m.failed_to_score_stats; id != nil {
			return []ent.Value{*id}
		}
	case team.EdgeFixturesStats:
		if id := m.fixtures_stats; id != nil {
			return []ent.Value{*id}
		}
	case team.EdgeGoalsStats:
		if id := m.goals_stats; id != nil {
			return []ent.Value{*id}
		}
	case team.EdgeLineups:
		ids := make([]ent.Value, 0, len(m.lineups))
		for id := range m.lineups {
			ids = append(ids, id)
		}
		return ids
	case team.EdgePenaltyStats:
		if id := m.penalty_stats; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 17)
	if m.removedstandings != nil {
		edges = append(edges, team.EdgeStandings)
	}
	if m.removedhomeFixtures != nil {
		edges = append(edges, team.EdgeHomeFixtures)
	}
	if m.removedawayFixtures != nil {
		edges = append(edges, team.EdgeAwayFixtures)
	}
	if m.removedfixtureEvents != nil {
		edges = append(edges, team.EdgeFixtureEvents)
	}
	if m.removedfixtureLineups != nil {
		edges = append(edges, team.EdgeFixtureLineups)
	}
	if m.removedplayers != nil {
		edges = append(edges, team.EdgePlayers)
	}
	if m.removedsquad != nil {
		edges = append(edges, team.EdgeSquad)
	}
	if m.removedlineups != nil {
		edges = append(edges, team.EdgeLineups)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeStandings:
		ids := make([]ent.Value, 0, len(m.removedstandings))
		for id := range m.removedstandings {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeHomeFixtures:
		ids := make([]ent.Value, 0, len(m.removedhomeFixtures))
		for id := range m.removedhomeFixtures {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeAwayFixtures:
		ids := make([]ent.Value, 0, len(m.removedawayFixtures))
		for id := range m.removedawayFixtures {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeFixtureEvents:
		ids := make([]ent.Value, 0, len(m.removedfixtureEvents))
		for id := range m.removedfixtureEvents {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeFixtureLineups:
		ids := make([]ent.Value, 0, len(m.removedfixtureLineups))
		for id := range m.removedfixtureLineups {
			ids = append(ids, id)
		}
		return ids
	case team.EdgePlayers:
		ids := make([]ent.Value, 0, len(m.removedplayers))
		for id := range m.removedplayers {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeSquad:
		ids := make([]ent.Value, 0, len(m.removedsquad))
		for id := range m.removedsquad {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeLineups:
		ids := make([]ent.Value, 0, len(m.removedlineups))
		for id := range m.removedlineups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 17)
	if m.clearedseason {
		edges = append(edges, team.EdgeSeason)
	}
	if m.clearedclub {
		edges = append(edges, team.EdgeClub)
	}
	if m.clearedstandings {
		edges = append(edges, team.EdgeStandings)
	}
	if m.clearedhomeFixtures {
		edges = append(edges, team.EdgeHomeFixtures)
	}
	if m.clearedawayFixtures {
		edges = append(edges, team.EdgeAwayFixtures)
	}
	if m.clearedfixtureEvents {
		edges = append(edges, team.EdgeFixtureEvents)
	}
	if m.clearedfixtureLineups {
		edges = append(edges, team.EdgeFixtureLineups)
	}
	if m.clearedplayers {
		edges = append(edges, team.EdgePlayers)
	}
	if m.clearedsquad {
		edges = append(edges, team.EdgeSquad)
	}
	if m.clearedbiggest_stats {
		edges = append(edges, team.EdgeBiggestStats)
	}
	if m.clearedcards_stats {
		edges = append(edges, team.EdgeCardsStats)
	}
	if m.clearedclean_sheet_stats {
		edges = append(edges, team.EdgeCleanSheetStats)
	}
	if m.clearedfailed_to_score_stats {
		edges = append(edges, team.EdgeFailedToScoreStats)
	}
	if m.clearedfixtures_stats {
		edges = append(edges, team.EdgeFixturesStats)
	}
	if m.clearedgoals_stats {
		edges = append(edges, team.EdgeGoalsStats)
	}
	if m.clearedlineups {
		edges = append(edges, team.EdgeLineups)
	}
	if m.clearedpenalty_stats {
		edges = append(edges, team.EdgePenaltyStats)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamMutation) EdgeCleared(name string) bool {
	switch name {
	case team.EdgeSeason:
		return m.clearedseason
	case team.EdgeClub:
		return m.clearedclub
	case team.EdgeStandings:
		return m.clearedstandings
	case team.EdgeHomeFixtures:
		return m.clearedhomeFixtures
	case team.EdgeAwayFixtures:
		return m.clearedawayFixtures
	case team.EdgeFixtureEvents:
		return m.clearedfixtureEvents
	case team.EdgeFixtureLineups:
		return m.clearedfixtureLineups
	case team.EdgePlayers:
		return m.clearedplayers
	case team.EdgeSquad:
		return m.clearedsquad
	case team.EdgeBiggestStats:
		return m.clearedbiggest_stats
	case team.EdgeCardsStats:
		return m.clearedcards_stats
	case team.EdgeCleanSheetStats:
		return m.clearedclean_sheet_stats
	case team.EdgeFailedToScoreStats:
		return m.clearedfailed_to_score_stats
	case team.EdgeFixturesStats:
		return m.clearedfixtures_stats
	case team.EdgeGoalsStats:
		return m.clearedgoals_stats
	case team.EdgeLineups:
		return m.clearedlineups
	case team.EdgePenaltyStats:
		return m.clearedpenalty_stats
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamMutation) ClearEdge(name string) error {
	switch name {
	case team.EdgeSeason:
		m.ClearSeason()
		return nil
	case team.EdgeClub:
		m.ClearClub()
		return nil
	case team.EdgeBiggestStats:
		m.ClearBiggestStats()
		return nil
	case team.EdgeCardsStats:
		m.ClearCardsStats()
		return nil
	case team.EdgeCleanSheetStats:
		m.ClearCleanSheetStats()
		return nil
	case team.EdgeFailedToScoreStats:
		m.ClearFailedToScoreStats()
		return nil
	case team.EdgeFixturesStats:
		m.ClearFixturesStats()
		return nil
	case team.EdgeGoalsStats:
		m.ClearGoalsStats()
		return nil
	case team.EdgePenaltyStats:
		m.ClearPenaltyStats()
		return nil
	}
	return fmt.Errorf("unknown Team unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamMutation) ResetEdge(name string) error {
	switch name {
	case team.EdgeSeason:
		m.ResetSeason()
		return nil
	case team.EdgeClub:
		m.ResetClub()
		return nil
	case team.EdgeStandings:
		m.ResetStandings()
		return nil
	case team.EdgeHomeFixtures:
		m.ResetHomeFixtures()
		return nil
	case team.EdgeAwayFixtures:
		m.ResetAwayFixtures()
		return nil
	case team.EdgeFixtureEvents:
		m.ResetFixtureEvents()
		return nil
	case team.EdgeFixtureLineups:
		m.ResetFixtureLineups()
		return nil
	case team.EdgePlayers:
		m.ResetPlayers()
		return nil
	case team.EdgeSquad:
		m.ResetSquad()
		return nil
	case team.EdgeBiggestStats:
		m.ResetBiggestStats()
		return nil
	case team.EdgeCardsStats:
		m.ResetCardsStats()
		return nil
	case team.EdgeCleanSheetStats:
		m.ResetCleanSheetStats()
		return nil
	case team.EdgeFailedToScoreStats:
		m.ResetFailedToScoreStats()
		return nil
	case team.EdgeFixturesStats:
		m.ResetFixturesStats()
		return nil
	case team.EdgeGoalsStats:
		m.ResetGoalsStats()
		return nil
	case team.EdgeLineups:
		m.ResetLineups()
		return nil
	case team.EdgePenaltyStats:
		m.ResetPenaltyStats()
		return nil
	}
	return fmt.Errorf("unknown Team edge %s", name)
}
