// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"mapeleven/db/ent/birth"
	"mapeleven/db/ent/country"
	"mapeleven/db/ent/league"
	"mapeleven/db/ent/player"
	"mapeleven/db/ent/playerteamseason"
	"mapeleven/db/ent/predicate"
	"mapeleven/db/ent/season"
	"mapeleven/db/ent/standings"
	"mapeleven/db/ent/team"
	"mapeleven/db/ent/teamseason"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBirth            = "Birth"
	TypeCountry          = "Country"
	TypeLeague           = "League"
	TypePlayer           = "Player"
	TypePlayerTeamSeason = "PlayerTeamSeason"
	TypeSeason           = "Season"
	TypeStandings        = "Standings"
	TypeTeam             = "Team"
	TypeTeamSeason       = "TeamSeason"
)

// BirthMutation represents an operation that mutates the Birth nodes in the graph.
type BirthMutation struct {
	config
	op            Op
	typ           string
	id            *int
	date          *time.Time
	place         *string
	country       *string
	clearedFields map[string]struct{}
	player        *int
	clearedplayer bool
	done          bool
	oldValue      func(context.Context) (*Birth, error)
	predicates    []predicate.Birth
}

var _ ent.Mutation = (*BirthMutation)(nil)

// birthOption allows management of the mutation configuration using functional options.
type birthOption func(*BirthMutation)

// newBirthMutation creates new mutation for the Birth entity.
func newBirthMutation(c config, op Op, opts ...birthOption) *BirthMutation {
	m := &BirthMutation{
		config:        c,
		op:            op,
		typ:           TypeBirth,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBirthID sets the ID field of the mutation.
func withBirthID(id int) birthOption {
	return func(m *BirthMutation) {
		var (
			err   error
			once  sync.Once
			value *Birth
		)
		m.oldValue = func(ctx context.Context) (*Birth, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Birth.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBirth sets the old Birth of the mutation.
func withBirth(node *Birth) birthOption {
	return func(m *BirthMutation) {
		m.oldValue = func(context.Context) (*Birth, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BirthMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BirthMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BirthMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BirthMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Birth.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDate sets the "date" field.
func (m *BirthMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *BirthMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Birth entity.
// If the Birth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BirthMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *BirthMutation) ResetDate() {
	m.date = nil
}

// SetPlace sets the "place" field.
func (m *BirthMutation) SetPlace(s string) {
	m.place = &s
}

// Place returns the value of the "place" field in the mutation.
func (m *BirthMutation) Place() (r string, exists bool) {
	v := m.place
	if v == nil {
		return
	}
	return *v, true
}

// OldPlace returns the old "place" field's value of the Birth entity.
// If the Birth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BirthMutation) OldPlace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlace: %w", err)
	}
	return oldValue.Place, nil
}

// ResetPlace resets all changes to the "place" field.
func (m *BirthMutation) ResetPlace() {
	m.place = nil
}

// SetCountry sets the "country" field.
func (m *BirthMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *BirthMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Birth entity.
// If the Birth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BirthMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *BirthMutation) ResetCountry() {
	m.country = nil
}

// SetPlayerID sets the "player" edge to the Player entity by id.
func (m *BirthMutation) SetPlayerID(id int) {
	m.player = &id
}

// ClearPlayer clears the "player" edge to the Player entity.
func (m *BirthMutation) ClearPlayer() {
	m.clearedplayer = true
}

// PlayerCleared reports if the "player" edge to the Player entity was cleared.
func (m *BirthMutation) PlayerCleared() bool {
	return m.clearedplayer
}

// PlayerID returns the "player" edge ID in the mutation.
func (m *BirthMutation) PlayerID() (id int, exists bool) {
	if m.player != nil {
		return *m.player, true
	}
	return
}

// PlayerIDs returns the "player" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlayerID instead. It exists only for internal usage by the builders.
func (m *BirthMutation) PlayerIDs() (ids []int) {
	if id := m.player; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlayer resets all changes to the "player" edge.
func (m *BirthMutation) ResetPlayer() {
	m.player = nil
	m.clearedplayer = false
}

// Where appends a list predicates to the BirthMutation builder.
func (m *BirthMutation) Where(ps ...predicate.Birth) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BirthMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BirthMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Birth, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BirthMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BirthMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Birth).
func (m *BirthMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BirthMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.date != nil {
		fields = append(fields, birth.FieldDate)
	}
	if m.place != nil {
		fields = append(fields, birth.FieldPlace)
	}
	if m.country != nil {
		fields = append(fields, birth.FieldCountry)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BirthMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case birth.FieldDate:
		return m.Date()
	case birth.FieldPlace:
		return m.Place()
	case birth.FieldCountry:
		return m.Country()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BirthMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case birth.FieldDate:
		return m.OldDate(ctx)
	case birth.FieldPlace:
		return m.OldPlace(ctx)
	case birth.FieldCountry:
		return m.OldCountry(ctx)
	}
	return nil, fmt.Errorf("unknown Birth field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BirthMutation) SetField(name string, value ent.Value) error {
	switch name {
	case birth.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case birth.FieldPlace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlace(v)
		return nil
	case birth.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	}
	return fmt.Errorf("unknown Birth field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BirthMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BirthMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BirthMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Birth numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BirthMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BirthMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BirthMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Birth nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BirthMutation) ResetField(name string) error {
	switch name {
	case birth.FieldDate:
		m.ResetDate()
		return nil
	case birth.FieldPlace:
		m.ResetPlace()
		return nil
	case birth.FieldCountry:
		m.ResetCountry()
		return nil
	}
	return fmt.Errorf("unknown Birth field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BirthMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.player != nil {
		edges = append(edges, birth.EdgePlayer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BirthMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case birth.EdgePlayer:
		if id := m.player; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BirthMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BirthMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BirthMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedplayer {
		edges = append(edges, birth.EdgePlayer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BirthMutation) EdgeCleared(name string) bool {
	switch name {
	case birth.EdgePlayer:
		return m.clearedplayer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BirthMutation) ClearEdge(name string) error {
	switch name {
	case birth.EdgePlayer:
		m.ClearPlayer()
		return nil
	}
	return fmt.Errorf("unknown Birth unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BirthMutation) ResetEdge(name string) error {
	switch name {
	case birth.EdgePlayer:
		m.ResetPlayer()
		return nil
	}
	return fmt.Errorf("unknown Birth edge %s", name)
}

// CountryMutation represents an operation that mutates the Country nodes in the graph.
type CountryMutation struct {
	config
	op             Op
	typ            string
	id             *int
	code           *string
	name           *string
	flag           *string
	clearedFields  map[string]struct{}
	players        map[int]struct{}
	removedplayers map[int]struct{}
	clearedplayers bool
	leagues        map[int]struct{}
	removedleagues map[int]struct{}
	clearedleagues bool
	teams          map[int]struct{}
	removedteams   map[int]struct{}
	clearedteams   bool
	done           bool
	oldValue       func(context.Context) (*Country, error)
	predicates     []predicate.Country
}

var _ ent.Mutation = (*CountryMutation)(nil)

// countryOption allows management of the mutation configuration using functional options.
type countryOption func(*CountryMutation)

// newCountryMutation creates new mutation for the Country entity.
func newCountryMutation(c config, op Op, opts ...countryOption) *CountryMutation {
	m := &CountryMutation{
		config:        c,
		op:            op,
		typ:           TypeCountry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCountryID sets the ID field of the mutation.
func withCountryID(id int) countryOption {
	return func(m *CountryMutation) {
		var (
			err   error
			once  sync.Once
			value *Country
		)
		m.oldValue = func(ctx context.Context) (*Country, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Country.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCountry sets the old Country of the mutation.
func withCountry(node *Country) countryOption {
	return func(m *CountryMutation) {
		m.oldValue = func(context.Context) (*Country, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CountryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CountryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CountryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CountryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Country.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *CountryMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *CountryMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *CountryMutation) ResetCode() {
	m.code = nil
}

// SetName sets the "name" field.
func (m *CountryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CountryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CountryMutation) ResetName() {
	m.name = nil
}

// SetFlag sets the "flag" field.
func (m *CountryMutation) SetFlag(s string) {
	m.flag = &s
}

// Flag returns the value of the "flag" field in the mutation.
func (m *CountryMutation) Flag() (r string, exists bool) {
	v := m.flag
	if v == nil {
		return
	}
	return *v, true
}

// OldFlag returns the old "flag" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldFlag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlag: %w", err)
	}
	return oldValue.Flag, nil
}

// ResetFlag resets all changes to the "flag" field.
func (m *CountryMutation) ResetFlag() {
	m.flag = nil
}

// AddPlayerIDs adds the "players" edge to the Player entity by ids.
func (m *CountryMutation) AddPlayerIDs(ids ...int) {
	if m.players == nil {
		m.players = make(map[int]struct{})
	}
	for i := range ids {
		m.players[ids[i]] = struct{}{}
	}
}

// ClearPlayers clears the "players" edge to the Player entity.
func (m *CountryMutation) ClearPlayers() {
	m.clearedplayers = true
}

// PlayersCleared reports if the "players" edge to the Player entity was cleared.
func (m *CountryMutation) PlayersCleared() bool {
	return m.clearedplayers
}

// RemovePlayerIDs removes the "players" edge to the Player entity by IDs.
func (m *CountryMutation) RemovePlayerIDs(ids ...int) {
	if m.removedplayers == nil {
		m.removedplayers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.players, ids[i])
		m.removedplayers[ids[i]] = struct{}{}
	}
}

// RemovedPlayers returns the removed IDs of the "players" edge to the Player entity.
func (m *CountryMutation) RemovedPlayersIDs() (ids []int) {
	for id := range m.removedplayers {
		ids = append(ids, id)
	}
	return
}

// PlayersIDs returns the "players" edge IDs in the mutation.
func (m *CountryMutation) PlayersIDs() (ids []int) {
	for id := range m.players {
		ids = append(ids, id)
	}
	return
}

// ResetPlayers resets all changes to the "players" edge.
func (m *CountryMutation) ResetPlayers() {
	m.players = nil
	m.clearedplayers = false
	m.removedplayers = nil
}

// AddLeagueIDs adds the "leagues" edge to the League entity by ids.
func (m *CountryMutation) AddLeagueIDs(ids ...int) {
	if m.leagues == nil {
		m.leagues = make(map[int]struct{})
	}
	for i := range ids {
		m.leagues[ids[i]] = struct{}{}
	}
}

// ClearLeagues clears the "leagues" edge to the League entity.
func (m *CountryMutation) ClearLeagues() {
	m.clearedleagues = true
}

// LeaguesCleared reports if the "leagues" edge to the League entity was cleared.
func (m *CountryMutation) LeaguesCleared() bool {
	return m.clearedleagues
}

// RemoveLeagueIDs removes the "leagues" edge to the League entity by IDs.
func (m *CountryMutation) RemoveLeagueIDs(ids ...int) {
	if m.removedleagues == nil {
		m.removedleagues = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.leagues, ids[i])
		m.removedleagues[ids[i]] = struct{}{}
	}
}

// RemovedLeagues returns the removed IDs of the "leagues" edge to the League entity.
func (m *CountryMutation) RemovedLeaguesIDs() (ids []int) {
	for id := range m.removedleagues {
		ids = append(ids, id)
	}
	return
}

// LeaguesIDs returns the "leagues" edge IDs in the mutation.
func (m *CountryMutation) LeaguesIDs() (ids []int) {
	for id := range m.leagues {
		ids = append(ids, id)
	}
	return
}

// ResetLeagues resets all changes to the "leagues" edge.
func (m *CountryMutation) ResetLeagues() {
	m.leagues = nil
	m.clearedleagues = false
	m.removedleagues = nil
}

// AddTeamIDs adds the "teams" edge to the Team entity by ids.
func (m *CountryMutation) AddTeamIDs(ids ...int) {
	if m.teams == nil {
		m.teams = make(map[int]struct{})
	}
	for i := range ids {
		m.teams[ids[i]] = struct{}{}
	}
}

// ClearTeams clears the "teams" edge to the Team entity.
func (m *CountryMutation) ClearTeams() {
	m.clearedteams = true
}

// TeamsCleared reports if the "teams" edge to the Team entity was cleared.
func (m *CountryMutation) TeamsCleared() bool {
	return m.clearedteams
}

// RemoveTeamIDs removes the "teams" edge to the Team entity by IDs.
func (m *CountryMutation) RemoveTeamIDs(ids ...int) {
	if m.removedteams == nil {
		m.removedteams = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.teams, ids[i])
		m.removedteams[ids[i]] = struct{}{}
	}
}

// RemovedTeams returns the removed IDs of the "teams" edge to the Team entity.
func (m *CountryMutation) RemovedTeamsIDs() (ids []int) {
	for id := range m.removedteams {
		ids = append(ids, id)
	}
	return
}

// TeamsIDs returns the "teams" edge IDs in the mutation.
func (m *CountryMutation) TeamsIDs() (ids []int) {
	for id := range m.teams {
		ids = append(ids, id)
	}
	return
}

// ResetTeams resets all changes to the "teams" edge.
func (m *CountryMutation) ResetTeams() {
	m.teams = nil
	m.clearedteams = false
	m.removedteams = nil
}

// Where appends a list predicates to the CountryMutation builder.
func (m *CountryMutation) Where(ps ...predicate.Country) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CountryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CountryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Country, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CountryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CountryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Country).
func (m *CountryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CountryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.code != nil {
		fields = append(fields, country.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, country.FieldName)
	}
	if m.flag != nil {
		fields = append(fields, country.FieldFlag)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CountryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case country.FieldCode:
		return m.Code()
	case country.FieldName:
		return m.Name()
	case country.FieldFlag:
		return m.Flag()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CountryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case country.FieldCode:
		return m.OldCode(ctx)
	case country.FieldName:
		return m.OldName(ctx)
	case country.FieldFlag:
		return m.OldFlag(ctx)
	}
	return nil, fmt.Errorf("unknown Country field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case country.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case country.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case country.FieldFlag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlag(v)
		return nil
	}
	return fmt.Errorf("unknown Country field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CountryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CountryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Country numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CountryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CountryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CountryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Country nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CountryMutation) ResetField(name string) error {
	switch name {
	case country.FieldCode:
		m.ResetCode()
		return nil
	case country.FieldName:
		m.ResetName()
		return nil
	case country.FieldFlag:
		m.ResetFlag()
		return nil
	}
	return fmt.Errorf("unknown Country field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CountryMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.players != nil {
		edges = append(edges, country.EdgePlayers)
	}
	if m.leagues != nil {
		edges = append(edges, country.EdgeLeagues)
	}
	if m.teams != nil {
		edges = append(edges, country.EdgeTeams)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CountryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case country.EdgePlayers:
		ids := make([]ent.Value, 0, len(m.players))
		for id := range m.players {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeLeagues:
		ids := make([]ent.Value, 0, len(m.leagues))
		for id := range m.leagues {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.teams))
		for id := range m.teams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CountryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedplayers != nil {
		edges = append(edges, country.EdgePlayers)
	}
	if m.removedleagues != nil {
		edges = append(edges, country.EdgeLeagues)
	}
	if m.removedteams != nil {
		edges = append(edges, country.EdgeTeams)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CountryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case country.EdgePlayers:
		ids := make([]ent.Value, 0, len(m.removedplayers))
		for id := range m.removedplayers {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeLeagues:
		ids := make([]ent.Value, 0, len(m.removedleagues))
		for id := range m.removedleagues {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.removedteams))
		for id := range m.removedteams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CountryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedplayers {
		edges = append(edges, country.EdgePlayers)
	}
	if m.clearedleagues {
		edges = append(edges, country.EdgeLeagues)
	}
	if m.clearedteams {
		edges = append(edges, country.EdgeTeams)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CountryMutation) EdgeCleared(name string) bool {
	switch name {
	case country.EdgePlayers:
		return m.clearedplayers
	case country.EdgeLeagues:
		return m.clearedleagues
	case country.EdgeTeams:
		return m.clearedteams
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CountryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Country unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CountryMutation) ResetEdge(name string) error {
	switch name {
	case country.EdgePlayers:
		m.ResetPlayers()
		return nil
	case country.EdgeLeagues:
		m.ResetLeagues()
		return nil
	case country.EdgeTeams:
		m.ResetTeams()
		return nil
	}
	return fmt.Errorf("unknown Country edge %s", name)
}

// LeagueMutation represents an operation that mutates the League nodes in the graph.
type LeagueMutation struct {
	config
	op               Op
	typ              string
	id               *int
	slug             *string
	name             *string
	_type            *league.Type
	logo             *string
	clearedFields    map[string]struct{}
	season           *int
	clearedseason    bool
	standings        map[int]struct{}
	removedstandings map[int]struct{}
	clearedstandings bool
	teams            map[int]struct{}
	removedteams     map[int]struct{}
	clearedteams     bool
	country          *int
	clearedcountry   bool
	done             bool
	oldValue         func(context.Context) (*League, error)
	predicates       []predicate.League
}

var _ ent.Mutation = (*LeagueMutation)(nil)

// leagueOption allows management of the mutation configuration using functional options.
type leagueOption func(*LeagueMutation)

// newLeagueMutation creates new mutation for the League entity.
func newLeagueMutation(c config, op Op, opts ...leagueOption) *LeagueMutation {
	m := &LeagueMutation{
		config:        c,
		op:            op,
		typ:           TypeLeague,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLeagueID sets the ID field of the mutation.
func withLeagueID(id int) leagueOption {
	return func(m *LeagueMutation) {
		var (
			err   error
			once  sync.Once
			value *League
		)
		m.oldValue = func(ctx context.Context) (*League, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().League.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLeague sets the old League of the mutation.
func withLeague(node *League) leagueOption {
	return func(m *LeagueMutation) {
		m.oldValue = func(context.Context) (*League, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LeagueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LeagueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of League entities.
func (m *LeagueMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LeagueMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LeagueMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().League.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSlug sets the "slug" field.
func (m *LeagueMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *LeagueMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the League entity.
// If the League object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeagueMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *LeagueMutation) ResetSlug() {
	m.slug = nil
}

// SetName sets the "name" field.
func (m *LeagueMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LeagueMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the League entity.
// If the League object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeagueMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LeagueMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *LeagueMutation) SetType(l league.Type) {
	m._type = &l
}

// GetType returns the value of the "type" field in the mutation.
func (m *LeagueMutation) GetType() (r league.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the League entity.
// If the League object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeagueMutation) OldType(ctx context.Context) (v league.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *LeagueMutation) ResetType() {
	m._type = nil
}

// SetLogo sets the "logo" field.
func (m *LeagueMutation) SetLogo(s string) {
	m.logo = &s
}

// Logo returns the value of the "logo" field in the mutation.
func (m *LeagueMutation) Logo() (r string, exists bool) {
	v := m.logo
	if v == nil {
		return
	}
	return *v, true
}

// OldLogo returns the old "logo" field's value of the League entity.
// If the League object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeagueMutation) OldLogo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogo: %w", err)
	}
	return oldValue.Logo, nil
}

// ResetLogo resets all changes to the "logo" field.
func (m *LeagueMutation) ResetLogo() {
	m.logo = nil
}

// SetSeasonID sets the "season" edge to the Season entity by id.
func (m *LeagueMutation) SetSeasonID(id int) {
	m.season = &id
}

// ClearSeason clears the "season" edge to the Season entity.
func (m *LeagueMutation) ClearSeason() {
	m.clearedseason = true
}

// SeasonCleared reports if the "season" edge to the Season entity was cleared.
func (m *LeagueMutation) SeasonCleared() bool {
	return m.clearedseason
}

// SeasonID returns the "season" edge ID in the mutation.
func (m *LeagueMutation) SeasonID() (id int, exists bool) {
	if m.season != nil {
		return *m.season, true
	}
	return
}

// SeasonIDs returns the "season" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SeasonID instead. It exists only for internal usage by the builders.
func (m *LeagueMutation) SeasonIDs() (ids []int) {
	if id := m.season; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSeason resets all changes to the "season" edge.
func (m *LeagueMutation) ResetSeason() {
	m.season = nil
	m.clearedseason = false
}

// AddStandingIDs adds the "standings" edge to the Standings entity by ids.
func (m *LeagueMutation) AddStandingIDs(ids ...int) {
	if m.standings == nil {
		m.standings = make(map[int]struct{})
	}
	for i := range ids {
		m.standings[ids[i]] = struct{}{}
	}
}

// ClearStandings clears the "standings" edge to the Standings entity.
func (m *LeagueMutation) ClearStandings() {
	m.clearedstandings = true
}

// StandingsCleared reports if the "standings" edge to the Standings entity was cleared.
func (m *LeagueMutation) StandingsCleared() bool {
	return m.clearedstandings
}

// RemoveStandingIDs removes the "standings" edge to the Standings entity by IDs.
func (m *LeagueMutation) RemoveStandingIDs(ids ...int) {
	if m.removedstandings == nil {
		m.removedstandings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.standings, ids[i])
		m.removedstandings[ids[i]] = struct{}{}
	}
}

// RemovedStandings returns the removed IDs of the "standings" edge to the Standings entity.
func (m *LeagueMutation) RemovedStandingsIDs() (ids []int) {
	for id := range m.removedstandings {
		ids = append(ids, id)
	}
	return
}

// StandingsIDs returns the "standings" edge IDs in the mutation.
func (m *LeagueMutation) StandingsIDs() (ids []int) {
	for id := range m.standings {
		ids = append(ids, id)
	}
	return
}

// ResetStandings resets all changes to the "standings" edge.
func (m *LeagueMutation) ResetStandings() {
	m.standings = nil
	m.clearedstandings = false
	m.removedstandings = nil
}

// AddTeamIDs adds the "teams" edge to the Team entity by ids.
func (m *LeagueMutation) AddTeamIDs(ids ...int) {
	if m.teams == nil {
		m.teams = make(map[int]struct{})
	}
	for i := range ids {
		m.teams[ids[i]] = struct{}{}
	}
}

// ClearTeams clears the "teams" edge to the Team entity.
func (m *LeagueMutation) ClearTeams() {
	m.clearedteams = true
}

// TeamsCleared reports if the "teams" edge to the Team entity was cleared.
func (m *LeagueMutation) TeamsCleared() bool {
	return m.clearedteams
}

// RemoveTeamIDs removes the "teams" edge to the Team entity by IDs.
func (m *LeagueMutation) RemoveTeamIDs(ids ...int) {
	if m.removedteams == nil {
		m.removedteams = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.teams, ids[i])
		m.removedteams[ids[i]] = struct{}{}
	}
}

// RemovedTeams returns the removed IDs of the "teams" edge to the Team entity.
func (m *LeagueMutation) RemovedTeamsIDs() (ids []int) {
	for id := range m.removedteams {
		ids = append(ids, id)
	}
	return
}

// TeamsIDs returns the "teams" edge IDs in the mutation.
func (m *LeagueMutation) TeamsIDs() (ids []int) {
	for id := range m.teams {
		ids = append(ids, id)
	}
	return
}

// ResetTeams resets all changes to the "teams" edge.
func (m *LeagueMutation) ResetTeams() {
	m.teams = nil
	m.clearedteams = false
	m.removedteams = nil
}

// SetCountryID sets the "country" edge to the Country entity by id.
func (m *LeagueMutation) SetCountryID(id int) {
	m.country = &id
}

// ClearCountry clears the "country" edge to the Country entity.
func (m *LeagueMutation) ClearCountry() {
	m.clearedcountry = true
}

// CountryCleared reports if the "country" edge to the Country entity was cleared.
func (m *LeagueMutation) CountryCleared() bool {
	return m.clearedcountry
}

// CountryID returns the "country" edge ID in the mutation.
func (m *LeagueMutation) CountryID() (id int, exists bool) {
	if m.country != nil {
		return *m.country, true
	}
	return
}

// CountryIDs returns the "country" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CountryID instead. It exists only for internal usage by the builders.
func (m *LeagueMutation) CountryIDs() (ids []int) {
	if id := m.country; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCountry resets all changes to the "country" edge.
func (m *LeagueMutation) ResetCountry() {
	m.country = nil
	m.clearedcountry = false
}

// Where appends a list predicates to the LeagueMutation builder.
func (m *LeagueMutation) Where(ps ...predicate.League) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LeagueMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LeagueMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.League, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LeagueMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LeagueMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (League).
func (m *LeagueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LeagueMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.slug != nil {
		fields = append(fields, league.FieldSlug)
	}
	if m.name != nil {
		fields = append(fields, league.FieldName)
	}
	if m._type != nil {
		fields = append(fields, league.FieldType)
	}
	if m.logo != nil {
		fields = append(fields, league.FieldLogo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LeagueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case league.FieldSlug:
		return m.Slug()
	case league.FieldName:
		return m.Name()
	case league.FieldType:
		return m.GetType()
	case league.FieldLogo:
		return m.Logo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LeagueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case league.FieldSlug:
		return m.OldSlug(ctx)
	case league.FieldName:
		return m.OldName(ctx)
	case league.FieldType:
		return m.OldType(ctx)
	case league.FieldLogo:
		return m.OldLogo(ctx)
	}
	return nil, fmt.Errorf("unknown League field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LeagueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case league.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case league.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case league.FieldType:
		v, ok := value.(league.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case league.FieldLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogo(v)
		return nil
	}
	return fmt.Errorf("unknown League field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LeagueMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LeagueMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LeagueMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown League numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LeagueMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LeagueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LeagueMutation) ClearField(name string) error {
	return fmt.Errorf("unknown League nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LeagueMutation) ResetField(name string) error {
	switch name {
	case league.FieldSlug:
		m.ResetSlug()
		return nil
	case league.FieldName:
		m.ResetName()
		return nil
	case league.FieldType:
		m.ResetType()
		return nil
	case league.FieldLogo:
		m.ResetLogo()
		return nil
	}
	return fmt.Errorf("unknown League field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LeagueMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.season != nil {
		edges = append(edges, league.EdgeSeason)
	}
	if m.standings != nil {
		edges = append(edges, league.EdgeStandings)
	}
	if m.teams != nil {
		edges = append(edges, league.EdgeTeams)
	}
	if m.country != nil {
		edges = append(edges, league.EdgeCountry)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LeagueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case league.EdgeSeason:
		if id := m.season; id != nil {
			return []ent.Value{*id}
		}
	case league.EdgeStandings:
		ids := make([]ent.Value, 0, len(m.standings))
		for id := range m.standings {
			ids = append(ids, id)
		}
		return ids
	case league.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.teams))
		for id := range m.teams {
			ids = append(ids, id)
		}
		return ids
	case league.EdgeCountry:
		if id := m.country; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LeagueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedstandings != nil {
		edges = append(edges, league.EdgeStandings)
	}
	if m.removedteams != nil {
		edges = append(edges, league.EdgeTeams)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LeagueMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case league.EdgeStandings:
		ids := make([]ent.Value, 0, len(m.removedstandings))
		for id := range m.removedstandings {
			ids = append(ids, id)
		}
		return ids
	case league.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.removedteams))
		for id := range m.removedteams {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LeagueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedseason {
		edges = append(edges, league.EdgeSeason)
	}
	if m.clearedstandings {
		edges = append(edges, league.EdgeStandings)
	}
	if m.clearedteams {
		edges = append(edges, league.EdgeTeams)
	}
	if m.clearedcountry {
		edges = append(edges, league.EdgeCountry)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LeagueMutation) EdgeCleared(name string) bool {
	switch name {
	case league.EdgeSeason:
		return m.clearedseason
	case league.EdgeStandings:
		return m.clearedstandings
	case league.EdgeTeams:
		return m.clearedteams
	case league.EdgeCountry:
		return m.clearedcountry
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LeagueMutation) ClearEdge(name string) error {
	switch name {
	case league.EdgeSeason:
		m.ClearSeason()
		return nil
	case league.EdgeCountry:
		m.ClearCountry()
		return nil
	}
	return fmt.Errorf("unknown League unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LeagueMutation) ResetEdge(name string) error {
	switch name {
	case league.EdgeSeason:
		m.ResetSeason()
		return nil
	case league.EdgeStandings:
		m.ResetStandings()
		return nil
	case league.EdgeTeams:
		m.ResetTeams()
		return nil
	case league.EdgeCountry:
		m.ResetCountry()
		return nil
	}
	return fmt.Errorf("unknown League edge %s", name)
}

// PlayerMutation represents an operation that mutates the Player nodes in the graph.
type PlayerMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	slug                     *string
	name                     *string
	firstname                *string
	lastname                 *string
	age                      *int
	addage                   *int
	height                   *float64
	addheight                *float64
	weight                   *float64
	addweight                *float64
	injured                  *bool
	photo                    *string
	clearedFields            map[string]struct{}
	birth                    *int
	clearedbirth             bool
	teams                    map[int]struct{}
	removedteams             map[int]struct{}
	clearedteams             bool
	playerTeamSeasons        map[int]struct{}
	removedplayerTeamSeasons map[int]struct{}
	clearedplayerTeamSeasons bool
	done                     bool
	oldValue                 func(context.Context) (*Player, error)
	predicates               []predicate.Player
}

var _ ent.Mutation = (*PlayerMutation)(nil)

// playerOption allows management of the mutation configuration using functional options.
type playerOption func(*PlayerMutation)

// newPlayerMutation creates new mutation for the Player entity.
func newPlayerMutation(c config, op Op, opts ...playerOption) *PlayerMutation {
	m := &PlayerMutation{
		config:        c,
		op:            op,
		typ:           TypePlayer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlayerID sets the ID field of the mutation.
func withPlayerID(id int) playerOption {
	return func(m *PlayerMutation) {
		var (
			err   error
			once  sync.Once
			value *Player
		)
		m.oldValue = func(ctx context.Context) (*Player, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Player.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlayer sets the old Player of the mutation.
func withPlayer(node *Player) playerOption {
	return func(m *PlayerMutation) {
		m.oldValue = func(context.Context) (*Player, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlayerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlayerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Player entities.
func (m *PlayerMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlayerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlayerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Player.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSlug sets the "slug" field.
func (m *PlayerMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *PlayerMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *PlayerMutation) ResetSlug() {
	m.slug = nil
}

// SetName sets the "name" field.
func (m *PlayerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PlayerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PlayerMutation) ResetName() {
	m.name = nil
}

// SetFirstname sets the "firstname" field.
func (m *PlayerMutation) SetFirstname(s string) {
	m.firstname = &s
}

// Firstname returns the value of the "firstname" field in the mutation.
func (m *PlayerMutation) Firstname() (r string, exists bool) {
	v := m.firstname
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstname returns the old "firstname" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldFirstname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstname: %w", err)
	}
	return oldValue.Firstname, nil
}

// ResetFirstname resets all changes to the "firstname" field.
func (m *PlayerMutation) ResetFirstname() {
	m.firstname = nil
}

// SetLastname sets the "lastname" field.
func (m *PlayerMutation) SetLastname(s string) {
	m.lastname = &s
}

// Lastname returns the value of the "lastname" field in the mutation.
func (m *PlayerMutation) Lastname() (r string, exists bool) {
	v := m.lastname
	if v == nil {
		return
	}
	return *v, true
}

// OldLastname returns the old "lastname" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldLastname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastname: %w", err)
	}
	return oldValue.Lastname, nil
}

// ResetLastname resets all changes to the "lastname" field.
func (m *PlayerMutation) ResetLastname() {
	m.lastname = nil
}

// SetAge sets the "age" field.
func (m *PlayerMutation) SetAge(i int) {
	m.age = &i
	m.addage = nil
}

// Age returns the value of the "age" field in the mutation.
func (m *PlayerMutation) Age() (r int, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old "age" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldAge(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds i to the "age" field.
func (m *PlayerMutation) AddAge(i int) {
	if m.addage != nil {
		*m.addage += i
	} else {
		m.addage = &i
	}
}

// AddedAge returns the value that was added to the "age" field in this mutation.
func (m *PlayerMutation) AddedAge() (r int, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ResetAge resets all changes to the "age" field.
func (m *PlayerMutation) ResetAge() {
	m.age = nil
	m.addage = nil
}

// SetHeight sets the "height" field.
func (m *PlayerMutation) SetHeight(f float64) {
	m.height = &f
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *PlayerMutation) Height() (r float64, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldHeight(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds f to the "height" field.
func (m *PlayerMutation) AddHeight(f float64) {
	if m.addheight != nil {
		*m.addheight += f
	} else {
		m.addheight = &f
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *PlayerMutation) AddedHeight() (r float64, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ResetHeight resets all changes to the "height" field.
func (m *PlayerMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
}

// SetWeight sets the "weight" field.
func (m *PlayerMutation) SetWeight(f float64) {
	m.weight = &f
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *PlayerMutation) Weight() (r float64, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldWeight(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds f to the "weight" field.
func (m *PlayerMutation) AddWeight(f float64) {
	if m.addweight != nil {
		*m.addweight += f
	} else {
		m.addweight = &f
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *PlayerMutation) AddedWeight() (r float64, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeight resets all changes to the "weight" field.
func (m *PlayerMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
}

// SetInjured sets the "injured" field.
func (m *PlayerMutation) SetInjured(b bool) {
	m.injured = &b
}

// Injured returns the value of the "injured" field in the mutation.
func (m *PlayerMutation) Injured() (r bool, exists bool) {
	v := m.injured
	if v == nil {
		return
	}
	return *v, true
}

// OldInjured returns the old "injured" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldInjured(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInjured is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInjured requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInjured: %w", err)
	}
	return oldValue.Injured, nil
}

// ResetInjured resets all changes to the "injured" field.
func (m *PlayerMutation) ResetInjured() {
	m.injured = nil
}

// SetPhoto sets the "photo" field.
func (m *PlayerMutation) SetPhoto(s string) {
	m.photo = &s
}

// Photo returns the value of the "photo" field in the mutation.
func (m *PlayerMutation) Photo() (r string, exists bool) {
	v := m.photo
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoto returns the old "photo" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldPhoto(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoto is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoto requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoto: %w", err)
	}
	return oldValue.Photo, nil
}

// ResetPhoto resets all changes to the "photo" field.
func (m *PlayerMutation) ResetPhoto() {
	m.photo = nil
}

// SetBirthID sets the "birth" edge to the Birth entity by id.
func (m *PlayerMutation) SetBirthID(id int) {
	m.birth = &id
}

// ClearBirth clears the "birth" edge to the Birth entity.
func (m *PlayerMutation) ClearBirth() {
	m.clearedbirth = true
}

// BirthCleared reports if the "birth" edge to the Birth entity was cleared.
func (m *PlayerMutation) BirthCleared() bool {
	return m.clearedbirth
}

// BirthID returns the "birth" edge ID in the mutation.
func (m *PlayerMutation) BirthID() (id int, exists bool) {
	if m.birth != nil {
		return *m.birth, true
	}
	return
}

// BirthIDs returns the "birth" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BirthID instead. It exists only for internal usage by the builders.
func (m *PlayerMutation) BirthIDs() (ids []int) {
	if id := m.birth; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBirth resets all changes to the "birth" edge.
func (m *PlayerMutation) ResetBirth() {
	m.birth = nil
	m.clearedbirth = false
}

// AddTeamIDs adds the "teams" edge to the Team entity by ids.
func (m *PlayerMutation) AddTeamIDs(ids ...int) {
	if m.teams == nil {
		m.teams = make(map[int]struct{})
	}
	for i := range ids {
		m.teams[ids[i]] = struct{}{}
	}
}

// ClearTeams clears the "teams" edge to the Team entity.
func (m *PlayerMutation) ClearTeams() {
	m.clearedteams = true
}

// TeamsCleared reports if the "teams" edge to the Team entity was cleared.
func (m *PlayerMutation) TeamsCleared() bool {
	return m.clearedteams
}

// RemoveTeamIDs removes the "teams" edge to the Team entity by IDs.
func (m *PlayerMutation) RemoveTeamIDs(ids ...int) {
	if m.removedteams == nil {
		m.removedteams = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.teams, ids[i])
		m.removedteams[ids[i]] = struct{}{}
	}
}

// RemovedTeams returns the removed IDs of the "teams" edge to the Team entity.
func (m *PlayerMutation) RemovedTeamsIDs() (ids []int) {
	for id := range m.removedteams {
		ids = append(ids, id)
	}
	return
}

// TeamsIDs returns the "teams" edge IDs in the mutation.
func (m *PlayerMutation) TeamsIDs() (ids []int) {
	for id := range m.teams {
		ids = append(ids, id)
	}
	return
}

// ResetTeams resets all changes to the "teams" edge.
func (m *PlayerMutation) ResetTeams() {
	m.teams = nil
	m.clearedteams = false
	m.removedteams = nil
}

// AddPlayerTeamSeasonIDs adds the "playerTeamSeasons" edge to the PlayerTeamSeason entity by ids.
func (m *PlayerMutation) AddPlayerTeamSeasonIDs(ids ...int) {
	if m.playerTeamSeasons == nil {
		m.playerTeamSeasons = make(map[int]struct{})
	}
	for i := range ids {
		m.playerTeamSeasons[ids[i]] = struct{}{}
	}
}

// ClearPlayerTeamSeasons clears the "playerTeamSeasons" edge to the PlayerTeamSeason entity.
func (m *PlayerMutation) ClearPlayerTeamSeasons() {
	m.clearedplayerTeamSeasons = true
}

// PlayerTeamSeasonsCleared reports if the "playerTeamSeasons" edge to the PlayerTeamSeason entity was cleared.
func (m *PlayerMutation) PlayerTeamSeasonsCleared() bool {
	return m.clearedplayerTeamSeasons
}

// RemovePlayerTeamSeasonIDs removes the "playerTeamSeasons" edge to the PlayerTeamSeason entity by IDs.
func (m *PlayerMutation) RemovePlayerTeamSeasonIDs(ids ...int) {
	if m.removedplayerTeamSeasons == nil {
		m.removedplayerTeamSeasons = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.playerTeamSeasons, ids[i])
		m.removedplayerTeamSeasons[ids[i]] = struct{}{}
	}
}

// RemovedPlayerTeamSeasons returns the removed IDs of the "playerTeamSeasons" edge to the PlayerTeamSeason entity.
func (m *PlayerMutation) RemovedPlayerTeamSeasonsIDs() (ids []int) {
	for id := range m.removedplayerTeamSeasons {
		ids = append(ids, id)
	}
	return
}

// PlayerTeamSeasonsIDs returns the "playerTeamSeasons" edge IDs in the mutation.
func (m *PlayerMutation) PlayerTeamSeasonsIDs() (ids []int) {
	for id := range m.playerTeamSeasons {
		ids = append(ids, id)
	}
	return
}

// ResetPlayerTeamSeasons resets all changes to the "playerTeamSeasons" edge.
func (m *PlayerMutation) ResetPlayerTeamSeasons() {
	m.playerTeamSeasons = nil
	m.clearedplayerTeamSeasons = false
	m.removedplayerTeamSeasons = nil
}

// Where appends a list predicates to the PlayerMutation builder.
func (m *PlayerMutation) Where(ps ...predicate.Player) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlayerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlayerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Player, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlayerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlayerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Player).
func (m *PlayerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlayerMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.slug != nil {
		fields = append(fields, player.FieldSlug)
	}
	if m.name != nil {
		fields = append(fields, player.FieldName)
	}
	if m.firstname != nil {
		fields = append(fields, player.FieldFirstname)
	}
	if m.lastname != nil {
		fields = append(fields, player.FieldLastname)
	}
	if m.age != nil {
		fields = append(fields, player.FieldAge)
	}
	if m.height != nil {
		fields = append(fields, player.FieldHeight)
	}
	if m.weight != nil {
		fields = append(fields, player.FieldWeight)
	}
	if m.injured != nil {
		fields = append(fields, player.FieldInjured)
	}
	if m.photo != nil {
		fields = append(fields, player.FieldPhoto)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlayerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case player.FieldSlug:
		return m.Slug()
	case player.FieldName:
		return m.Name()
	case player.FieldFirstname:
		return m.Firstname()
	case player.FieldLastname:
		return m.Lastname()
	case player.FieldAge:
		return m.Age()
	case player.FieldHeight:
		return m.Height()
	case player.FieldWeight:
		return m.Weight()
	case player.FieldInjured:
		return m.Injured()
	case player.FieldPhoto:
		return m.Photo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlayerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case player.FieldSlug:
		return m.OldSlug(ctx)
	case player.FieldName:
		return m.OldName(ctx)
	case player.FieldFirstname:
		return m.OldFirstname(ctx)
	case player.FieldLastname:
		return m.OldLastname(ctx)
	case player.FieldAge:
		return m.OldAge(ctx)
	case player.FieldHeight:
		return m.OldHeight(ctx)
	case player.FieldWeight:
		return m.OldWeight(ctx)
	case player.FieldInjured:
		return m.OldInjured(ctx)
	case player.FieldPhoto:
		return m.OldPhoto(ctx)
	}
	return nil, fmt.Errorf("unknown Player field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlayerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case player.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case player.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case player.FieldFirstname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstname(v)
		return nil
	case player.FieldLastname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastname(v)
		return nil
	case player.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case player.FieldHeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case player.FieldWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case player.FieldInjured:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInjured(v)
		return nil
	case player.FieldPhoto:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoto(v)
		return nil
	}
	return fmt.Errorf("unknown Player field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlayerMutation) AddedFields() []string {
	var fields []string
	if m.addage != nil {
		fields = append(fields, player.FieldAge)
	}
	if m.addheight != nil {
		fields = append(fields, player.FieldHeight)
	}
	if m.addweight != nil {
		fields = append(fields, player.FieldWeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlayerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case player.FieldAge:
		return m.AddedAge()
	case player.FieldHeight:
		return m.AddedHeight()
	case player.FieldWeight:
		return m.AddedWeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlayerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case player.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	case player.FieldHeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	case player.FieldWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	}
	return fmt.Errorf("unknown Player numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlayerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlayerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlayerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Player nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlayerMutation) ResetField(name string) error {
	switch name {
	case player.FieldSlug:
		m.ResetSlug()
		return nil
	case player.FieldName:
		m.ResetName()
		return nil
	case player.FieldFirstname:
		m.ResetFirstname()
		return nil
	case player.FieldLastname:
		m.ResetLastname()
		return nil
	case player.FieldAge:
		m.ResetAge()
		return nil
	case player.FieldHeight:
		m.ResetHeight()
		return nil
	case player.FieldWeight:
		m.ResetWeight()
		return nil
	case player.FieldInjured:
		m.ResetInjured()
		return nil
	case player.FieldPhoto:
		m.ResetPhoto()
		return nil
	}
	return fmt.Errorf("unknown Player field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlayerMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.birth != nil {
		edges = append(edges, player.EdgeBirth)
	}
	if m.teams != nil {
		edges = append(edges, player.EdgeTeams)
	}
	if m.playerTeamSeasons != nil {
		edges = append(edges, player.EdgePlayerTeamSeasons)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlayerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case player.EdgeBirth:
		if id := m.birth; id != nil {
			return []ent.Value{*id}
		}
	case player.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.teams))
		for id := range m.teams {
			ids = append(ids, id)
		}
		return ids
	case player.EdgePlayerTeamSeasons:
		ids := make([]ent.Value, 0, len(m.playerTeamSeasons))
		for id := range m.playerTeamSeasons {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlayerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedteams != nil {
		edges = append(edges, player.EdgeTeams)
	}
	if m.removedplayerTeamSeasons != nil {
		edges = append(edges, player.EdgePlayerTeamSeasons)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlayerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case player.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.removedteams))
		for id := range m.removedteams {
			ids = append(ids, id)
		}
		return ids
	case player.EdgePlayerTeamSeasons:
		ids := make([]ent.Value, 0, len(m.removedplayerTeamSeasons))
		for id := range m.removedplayerTeamSeasons {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlayerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbirth {
		edges = append(edges, player.EdgeBirth)
	}
	if m.clearedteams {
		edges = append(edges, player.EdgeTeams)
	}
	if m.clearedplayerTeamSeasons {
		edges = append(edges, player.EdgePlayerTeamSeasons)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlayerMutation) EdgeCleared(name string) bool {
	switch name {
	case player.EdgeBirth:
		return m.clearedbirth
	case player.EdgeTeams:
		return m.clearedteams
	case player.EdgePlayerTeamSeasons:
		return m.clearedplayerTeamSeasons
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlayerMutation) ClearEdge(name string) error {
	switch name {
	case player.EdgeBirth:
		m.ClearBirth()
		return nil
	}
	return fmt.Errorf("unknown Player unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlayerMutation) ResetEdge(name string) error {
	switch name {
	case player.EdgeBirth:
		m.ResetBirth()
		return nil
	case player.EdgeTeams:
		m.ResetTeams()
		return nil
	case player.EdgePlayerTeamSeasons:
		m.ResetPlayerTeamSeasons()
		return nil
	}
	return fmt.Errorf("unknown Player edge %s", name)
}

// PlayerTeamSeasonMutation represents an operation that mutates the PlayerTeamSeason nodes in the graph.
type PlayerTeamSeasonMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	player_team_season_id    *int
	addplayer_team_season_id *int
	clearedFields            map[string]struct{}
	player                   *int
	clearedplayer            bool
	teamSeason               *int
	clearedteamSeason        bool
	done                     bool
	oldValue                 func(context.Context) (*PlayerTeamSeason, error)
	predicates               []predicate.PlayerTeamSeason
}

var _ ent.Mutation = (*PlayerTeamSeasonMutation)(nil)

// playerteamseasonOption allows management of the mutation configuration using functional options.
type playerteamseasonOption func(*PlayerTeamSeasonMutation)

// newPlayerTeamSeasonMutation creates new mutation for the PlayerTeamSeason entity.
func newPlayerTeamSeasonMutation(c config, op Op, opts ...playerteamseasonOption) *PlayerTeamSeasonMutation {
	m := &PlayerTeamSeasonMutation{
		config:        c,
		op:            op,
		typ:           TypePlayerTeamSeason,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlayerTeamSeasonID sets the ID field of the mutation.
func withPlayerTeamSeasonID(id int) playerteamseasonOption {
	return func(m *PlayerTeamSeasonMutation) {
		var (
			err   error
			once  sync.Once
			value *PlayerTeamSeason
		)
		m.oldValue = func(ctx context.Context) (*PlayerTeamSeason, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlayerTeamSeason.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlayerTeamSeason sets the old PlayerTeamSeason of the mutation.
func withPlayerTeamSeason(node *PlayerTeamSeason) playerteamseasonOption {
	return func(m *PlayerTeamSeasonMutation) {
		m.oldValue = func(context.Context) (*PlayerTeamSeason, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlayerTeamSeasonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlayerTeamSeasonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlayerTeamSeasonMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlayerTeamSeasonMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlayerTeamSeason.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPlayerTeamSeasonID sets the "player_team_season_id" field.
func (m *PlayerTeamSeasonMutation) SetPlayerTeamSeasonID(i int) {
	m.player_team_season_id = &i
	m.addplayer_team_season_id = nil
}

// PlayerTeamSeasonID returns the value of the "player_team_season_id" field in the mutation.
func (m *PlayerTeamSeasonMutation) PlayerTeamSeasonID() (r int, exists bool) {
	v := m.player_team_season_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPlayerTeamSeasonID returns the old "player_team_season_id" field's value of the PlayerTeamSeason entity.
// If the PlayerTeamSeason object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerTeamSeasonMutation) OldPlayerTeamSeasonID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlayerTeamSeasonID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlayerTeamSeasonID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlayerTeamSeasonID: %w", err)
	}
	return oldValue.PlayerTeamSeasonID, nil
}

// AddPlayerTeamSeasonID adds i to the "player_team_season_id" field.
func (m *PlayerTeamSeasonMutation) AddPlayerTeamSeasonID(i int) {
	if m.addplayer_team_season_id != nil {
		*m.addplayer_team_season_id += i
	} else {
		m.addplayer_team_season_id = &i
	}
}

// AddedPlayerTeamSeasonID returns the value that was added to the "player_team_season_id" field in this mutation.
func (m *PlayerTeamSeasonMutation) AddedPlayerTeamSeasonID() (r int, exists bool) {
	v := m.addplayer_team_season_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPlayerTeamSeasonID resets all changes to the "player_team_season_id" field.
func (m *PlayerTeamSeasonMutation) ResetPlayerTeamSeasonID() {
	m.player_team_season_id = nil
	m.addplayer_team_season_id = nil
}

// SetPlayerID sets the "player" edge to the Player entity by id.
func (m *PlayerTeamSeasonMutation) SetPlayerID(id int) {
	m.player = &id
}

// ClearPlayer clears the "player" edge to the Player entity.
func (m *PlayerTeamSeasonMutation) ClearPlayer() {
	m.clearedplayer = true
}

// PlayerCleared reports if the "player" edge to the Player entity was cleared.
func (m *PlayerTeamSeasonMutation) PlayerCleared() bool {
	return m.clearedplayer
}

// PlayerID returns the "player" edge ID in the mutation.
func (m *PlayerTeamSeasonMutation) PlayerID() (id int, exists bool) {
	if m.player != nil {
		return *m.player, true
	}
	return
}

// PlayerIDs returns the "player" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlayerID instead. It exists only for internal usage by the builders.
func (m *PlayerTeamSeasonMutation) PlayerIDs() (ids []int) {
	if id := m.player; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlayer resets all changes to the "player" edge.
func (m *PlayerTeamSeasonMutation) ResetPlayer() {
	m.player = nil
	m.clearedplayer = false
}

// SetTeamSeasonID sets the "teamSeason" edge to the TeamSeason entity by id.
func (m *PlayerTeamSeasonMutation) SetTeamSeasonID(id int) {
	m.teamSeason = &id
}

// ClearTeamSeason clears the "teamSeason" edge to the TeamSeason entity.
func (m *PlayerTeamSeasonMutation) ClearTeamSeason() {
	m.clearedteamSeason = true
}

// TeamSeasonCleared reports if the "teamSeason" edge to the TeamSeason entity was cleared.
func (m *PlayerTeamSeasonMutation) TeamSeasonCleared() bool {
	return m.clearedteamSeason
}

// TeamSeasonID returns the "teamSeason" edge ID in the mutation.
func (m *PlayerTeamSeasonMutation) TeamSeasonID() (id int, exists bool) {
	if m.teamSeason != nil {
		return *m.teamSeason, true
	}
	return
}

// TeamSeasonIDs returns the "teamSeason" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamSeasonID instead. It exists only for internal usage by the builders.
func (m *PlayerTeamSeasonMutation) TeamSeasonIDs() (ids []int) {
	if id := m.teamSeason; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeamSeason resets all changes to the "teamSeason" edge.
func (m *PlayerTeamSeasonMutation) ResetTeamSeason() {
	m.teamSeason = nil
	m.clearedteamSeason = false
}

// Where appends a list predicates to the PlayerTeamSeasonMutation builder.
func (m *PlayerTeamSeasonMutation) Where(ps ...predicate.PlayerTeamSeason) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlayerTeamSeasonMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlayerTeamSeasonMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PlayerTeamSeason, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlayerTeamSeasonMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlayerTeamSeasonMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PlayerTeamSeason).
func (m *PlayerTeamSeasonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlayerTeamSeasonMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.player_team_season_id != nil {
		fields = append(fields, playerteamseason.FieldPlayerTeamSeasonID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlayerTeamSeasonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case playerteamseason.FieldPlayerTeamSeasonID:
		return m.PlayerTeamSeasonID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlayerTeamSeasonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case playerteamseason.FieldPlayerTeamSeasonID:
		return m.OldPlayerTeamSeasonID(ctx)
	}
	return nil, fmt.Errorf("unknown PlayerTeamSeason field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlayerTeamSeasonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case playerteamseason.FieldPlayerTeamSeasonID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlayerTeamSeasonID(v)
		return nil
	}
	return fmt.Errorf("unknown PlayerTeamSeason field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlayerTeamSeasonMutation) AddedFields() []string {
	var fields []string
	if m.addplayer_team_season_id != nil {
		fields = append(fields, playerteamseason.FieldPlayerTeamSeasonID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlayerTeamSeasonMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case playerteamseason.FieldPlayerTeamSeasonID:
		return m.AddedPlayerTeamSeasonID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlayerTeamSeasonMutation) AddField(name string, value ent.Value) error {
	switch name {
	case playerteamseason.FieldPlayerTeamSeasonID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlayerTeamSeasonID(v)
		return nil
	}
	return fmt.Errorf("unknown PlayerTeamSeason numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlayerTeamSeasonMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlayerTeamSeasonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlayerTeamSeasonMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PlayerTeamSeason nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlayerTeamSeasonMutation) ResetField(name string) error {
	switch name {
	case playerteamseason.FieldPlayerTeamSeasonID:
		m.ResetPlayerTeamSeasonID()
		return nil
	}
	return fmt.Errorf("unknown PlayerTeamSeason field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlayerTeamSeasonMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.player != nil {
		edges = append(edges, playerteamseason.EdgePlayer)
	}
	if m.teamSeason != nil {
		edges = append(edges, playerteamseason.EdgeTeamSeason)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlayerTeamSeasonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case playerteamseason.EdgePlayer:
		if id := m.player; id != nil {
			return []ent.Value{*id}
		}
	case playerteamseason.EdgeTeamSeason:
		if id := m.teamSeason; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlayerTeamSeasonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlayerTeamSeasonMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlayerTeamSeasonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedplayer {
		edges = append(edges, playerteamseason.EdgePlayer)
	}
	if m.clearedteamSeason {
		edges = append(edges, playerteamseason.EdgeTeamSeason)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlayerTeamSeasonMutation) EdgeCleared(name string) bool {
	switch name {
	case playerteamseason.EdgePlayer:
		return m.clearedplayer
	case playerteamseason.EdgeTeamSeason:
		return m.clearedteamSeason
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlayerTeamSeasonMutation) ClearEdge(name string) error {
	switch name {
	case playerteamseason.EdgePlayer:
		m.ClearPlayer()
		return nil
	case playerteamseason.EdgeTeamSeason:
		m.ClearTeamSeason()
		return nil
	}
	return fmt.Errorf("unknown PlayerTeamSeason unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlayerTeamSeasonMutation) ResetEdge(name string) error {
	switch name {
	case playerteamseason.EdgePlayer:
		m.ResetPlayer()
		return nil
	case playerteamseason.EdgeTeamSeason:
		m.ResetTeamSeason()
		return nil
	}
	return fmt.Errorf("unknown PlayerTeamSeason edge %s", name)
}

// SeasonMutation represents an operation that mutates the Season nodes in the graph.
type SeasonMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	year               *int
	addyear            *int
	start              *time.Time
	end                *time.Time
	current            *bool
	clearedFields      map[string]struct{}
	league             *int
	clearedleague      bool
	teamSeasons        map[int]struct{}
	removedteamSeasons map[int]struct{}
	clearedteamSeasons bool
	done               bool
	oldValue           func(context.Context) (*Season, error)
	predicates         []predicate.Season
}

var _ ent.Mutation = (*SeasonMutation)(nil)

// seasonOption allows management of the mutation configuration using functional options.
type seasonOption func(*SeasonMutation)

// newSeasonMutation creates new mutation for the Season entity.
func newSeasonMutation(c config, op Op, opts ...seasonOption) *SeasonMutation {
	m := &SeasonMutation{
		config:        c,
		op:            op,
		typ:           TypeSeason,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSeasonID sets the ID field of the mutation.
func withSeasonID(id int) seasonOption {
	return func(m *SeasonMutation) {
		var (
			err   error
			once  sync.Once
			value *Season
		)
		m.oldValue = func(ctx context.Context) (*Season, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Season.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSeason sets the old Season of the mutation.
func withSeason(node *Season) seasonOption {
	return func(m *SeasonMutation) {
		m.oldValue = func(context.Context) (*Season, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SeasonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SeasonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SeasonMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SeasonMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Season.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetYear sets the "year" field.
func (m *SeasonMutation) SetYear(i int) {
	m.year = &i
	m.addyear = nil
}

// Year returns the value of the "year" field in the mutation.
func (m *SeasonMutation) Year() (r int, exists bool) {
	v := m.year
	if v == nil {
		return
	}
	return *v, true
}

// OldYear returns the old "year" field's value of the Season entity.
// If the Season object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeasonMutation) OldYear(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYear: %w", err)
	}
	return oldValue.Year, nil
}

// AddYear adds i to the "year" field.
func (m *SeasonMutation) AddYear(i int) {
	if m.addyear != nil {
		*m.addyear += i
	} else {
		m.addyear = &i
	}
}

// AddedYear returns the value that was added to the "year" field in this mutation.
func (m *SeasonMutation) AddedYear() (r int, exists bool) {
	v := m.addyear
	if v == nil {
		return
	}
	return *v, true
}

// ResetYear resets all changes to the "year" field.
func (m *SeasonMutation) ResetYear() {
	m.year = nil
	m.addyear = nil
}

// SetStart sets the "start" field.
func (m *SeasonMutation) SetStart(t time.Time) {
	m.start = &t
}

// Start returns the value of the "start" field in the mutation.
func (m *SeasonMutation) Start() (r time.Time, exists bool) {
	v := m.start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old "start" field's value of the Season entity.
// If the Season object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeasonMutation) OldStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// ResetStart resets all changes to the "start" field.
func (m *SeasonMutation) ResetStart() {
	m.start = nil
}

// SetEnd sets the "end" field.
func (m *SeasonMutation) SetEnd(t time.Time) {
	m.end = &t
}

// End returns the value of the "end" field in the mutation.
func (m *SeasonMutation) End() (r time.Time, exists bool) {
	v := m.end
	if v == nil {
		return
	}
	return *v, true
}

// OldEnd returns the old "end" field's value of the Season entity.
// If the Season object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeasonMutation) OldEnd(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnd: %w", err)
	}
	return oldValue.End, nil
}

// ResetEnd resets all changes to the "end" field.
func (m *SeasonMutation) ResetEnd() {
	m.end = nil
}

// SetCurrent sets the "current" field.
func (m *SeasonMutation) SetCurrent(b bool) {
	m.current = &b
}

// Current returns the value of the "current" field in the mutation.
func (m *SeasonMutation) Current() (r bool, exists bool) {
	v := m.current
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrent returns the old "current" field's value of the Season entity.
// If the Season object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeasonMutation) OldCurrent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrent: %w", err)
	}
	return oldValue.Current, nil
}

// ResetCurrent resets all changes to the "current" field.
func (m *SeasonMutation) ResetCurrent() {
	m.current = nil
}

// SetLeagueID sets the "league" edge to the League entity by id.
func (m *SeasonMutation) SetLeagueID(id int) {
	m.league = &id
}

// ClearLeague clears the "league" edge to the League entity.
func (m *SeasonMutation) ClearLeague() {
	m.clearedleague = true
}

// LeagueCleared reports if the "league" edge to the League entity was cleared.
func (m *SeasonMutation) LeagueCleared() bool {
	return m.clearedleague
}

// LeagueID returns the "league" edge ID in the mutation.
func (m *SeasonMutation) LeagueID() (id int, exists bool) {
	if m.league != nil {
		return *m.league, true
	}
	return
}

// LeagueIDs returns the "league" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LeagueID instead. It exists only for internal usage by the builders.
func (m *SeasonMutation) LeagueIDs() (ids []int) {
	if id := m.league; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLeague resets all changes to the "league" edge.
func (m *SeasonMutation) ResetLeague() {
	m.league = nil
	m.clearedleague = false
}

// AddTeamSeasonIDs adds the "teamSeasons" edge to the TeamSeason entity by ids.
func (m *SeasonMutation) AddTeamSeasonIDs(ids ...int) {
	if m.teamSeasons == nil {
		m.teamSeasons = make(map[int]struct{})
	}
	for i := range ids {
		m.teamSeasons[ids[i]] = struct{}{}
	}
}

// ClearTeamSeasons clears the "teamSeasons" edge to the TeamSeason entity.
func (m *SeasonMutation) ClearTeamSeasons() {
	m.clearedteamSeasons = true
}

// TeamSeasonsCleared reports if the "teamSeasons" edge to the TeamSeason entity was cleared.
func (m *SeasonMutation) TeamSeasonsCleared() bool {
	return m.clearedteamSeasons
}

// RemoveTeamSeasonIDs removes the "teamSeasons" edge to the TeamSeason entity by IDs.
func (m *SeasonMutation) RemoveTeamSeasonIDs(ids ...int) {
	if m.removedteamSeasons == nil {
		m.removedteamSeasons = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.teamSeasons, ids[i])
		m.removedteamSeasons[ids[i]] = struct{}{}
	}
}

// RemovedTeamSeasons returns the removed IDs of the "teamSeasons" edge to the TeamSeason entity.
func (m *SeasonMutation) RemovedTeamSeasonsIDs() (ids []int) {
	for id := range m.removedteamSeasons {
		ids = append(ids, id)
	}
	return
}

// TeamSeasonsIDs returns the "teamSeasons" edge IDs in the mutation.
func (m *SeasonMutation) TeamSeasonsIDs() (ids []int) {
	for id := range m.teamSeasons {
		ids = append(ids, id)
	}
	return
}

// ResetTeamSeasons resets all changes to the "teamSeasons" edge.
func (m *SeasonMutation) ResetTeamSeasons() {
	m.teamSeasons = nil
	m.clearedteamSeasons = false
	m.removedteamSeasons = nil
}

// Where appends a list predicates to the SeasonMutation builder.
func (m *SeasonMutation) Where(ps ...predicate.Season) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SeasonMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SeasonMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Season, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SeasonMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SeasonMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Season).
func (m *SeasonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SeasonMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.year != nil {
		fields = append(fields, season.FieldYear)
	}
	if m.start != nil {
		fields = append(fields, season.FieldStart)
	}
	if m.end != nil {
		fields = append(fields, season.FieldEnd)
	}
	if m.current != nil {
		fields = append(fields, season.FieldCurrent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SeasonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case season.FieldYear:
		return m.Year()
	case season.FieldStart:
		return m.Start()
	case season.FieldEnd:
		return m.End()
	case season.FieldCurrent:
		return m.Current()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SeasonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case season.FieldYear:
		return m.OldYear(ctx)
	case season.FieldStart:
		return m.OldStart(ctx)
	case season.FieldEnd:
		return m.OldEnd(ctx)
	case season.FieldCurrent:
		return m.OldCurrent(ctx)
	}
	return nil, fmt.Errorf("unknown Season field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeasonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case season.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYear(v)
		return nil
	case season.FieldStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case season.FieldEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnd(v)
		return nil
	case season.FieldCurrent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrent(v)
		return nil
	}
	return fmt.Errorf("unknown Season field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SeasonMutation) AddedFields() []string {
	var fields []string
	if m.addyear != nil {
		fields = append(fields, season.FieldYear)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SeasonMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case season.FieldYear:
		return m.AddedYear()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeasonMutation) AddField(name string, value ent.Value) error {
	switch name {
	case season.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYear(v)
		return nil
	}
	return fmt.Errorf("unknown Season numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SeasonMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SeasonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SeasonMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Season nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SeasonMutation) ResetField(name string) error {
	switch name {
	case season.FieldYear:
		m.ResetYear()
		return nil
	case season.FieldStart:
		m.ResetStart()
		return nil
	case season.FieldEnd:
		m.ResetEnd()
		return nil
	case season.FieldCurrent:
		m.ResetCurrent()
		return nil
	}
	return fmt.Errorf("unknown Season field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SeasonMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.league != nil {
		edges = append(edges, season.EdgeLeague)
	}
	if m.teamSeasons != nil {
		edges = append(edges, season.EdgeTeamSeasons)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SeasonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case season.EdgeLeague:
		if id := m.league; id != nil {
			return []ent.Value{*id}
		}
	case season.EdgeTeamSeasons:
		ids := make([]ent.Value, 0, len(m.teamSeasons))
		for id := range m.teamSeasons {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SeasonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedteamSeasons != nil {
		edges = append(edges, season.EdgeTeamSeasons)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SeasonMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case season.EdgeTeamSeasons:
		ids := make([]ent.Value, 0, len(m.removedteamSeasons))
		for id := range m.removedteamSeasons {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SeasonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedleague {
		edges = append(edges, season.EdgeLeague)
	}
	if m.clearedteamSeasons {
		edges = append(edges, season.EdgeTeamSeasons)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SeasonMutation) EdgeCleared(name string) bool {
	switch name {
	case season.EdgeLeague:
		return m.clearedleague
	case season.EdgeTeamSeasons:
		return m.clearedteamSeasons
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SeasonMutation) ClearEdge(name string) error {
	switch name {
	case season.EdgeLeague:
		m.ClearLeague()
		return nil
	}
	return fmt.Errorf("unknown Season unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SeasonMutation) ResetEdge(name string) error {
	switch name {
	case season.EdgeLeague:
		m.ResetLeague()
		return nil
	case season.EdgeTeamSeasons:
		m.ResetTeamSeasons()
		return nil
	}
	return fmt.Errorf("unknown Season edge %s", name)
}

// StandingsMutation represents an operation that mutates the Standings nodes in the graph.
type StandingsMutation struct {
	config
	op            Op
	typ           string
	id            *int
	rank          *int
	addrank       *int
	description   *string
	clearedFields map[string]struct{}
	league        *int
	clearedleague bool
	team          *int
	clearedteam   bool
	done          bool
	oldValue      func(context.Context) (*Standings, error)
	predicates    []predicate.Standings
}

var _ ent.Mutation = (*StandingsMutation)(nil)

// standingsOption allows management of the mutation configuration using functional options.
type standingsOption func(*StandingsMutation)

// newStandingsMutation creates new mutation for the Standings entity.
func newStandingsMutation(c config, op Op, opts ...standingsOption) *StandingsMutation {
	m := &StandingsMutation{
		config:        c,
		op:            op,
		typ:           TypeStandings,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStandingsID sets the ID field of the mutation.
func withStandingsID(id int) standingsOption {
	return func(m *StandingsMutation) {
		var (
			err   error
			once  sync.Once
			value *Standings
		)
		m.oldValue = func(ctx context.Context) (*Standings, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Standings.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStandings sets the old Standings of the mutation.
func withStandings(node *Standings) standingsOption {
	return func(m *StandingsMutation) {
		m.oldValue = func(context.Context) (*Standings, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StandingsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StandingsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StandingsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StandingsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Standings.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRank sets the "rank" field.
func (m *StandingsMutation) SetRank(i int) {
	m.rank = &i
	m.addrank = nil
}

// Rank returns the value of the "rank" field in the mutation.
func (m *StandingsMutation) Rank() (r int, exists bool) {
	v := m.rank
	if v == nil {
		return
	}
	return *v, true
}

// OldRank returns the old "rank" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldRank(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRank: %w", err)
	}
	return oldValue.Rank, nil
}

// AddRank adds i to the "rank" field.
func (m *StandingsMutation) AddRank(i int) {
	if m.addrank != nil {
		*m.addrank += i
	} else {
		m.addrank = &i
	}
}

// AddedRank returns the value that was added to the "rank" field in this mutation.
func (m *StandingsMutation) AddedRank() (r int, exists bool) {
	v := m.addrank
	if v == nil {
		return
	}
	return *v, true
}

// ResetRank resets all changes to the "rank" field.
func (m *StandingsMutation) ResetRank() {
	m.rank = nil
	m.addrank = nil
}

// SetDescription sets the "description" field.
func (m *StandingsMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *StandingsMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Standings entity.
// If the Standings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StandingsMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *StandingsMutation) ResetDescription() {
	m.description = nil
}

// SetLeagueID sets the "league" edge to the League entity by id.
func (m *StandingsMutation) SetLeagueID(id int) {
	m.league = &id
}

// ClearLeague clears the "league" edge to the League entity.
func (m *StandingsMutation) ClearLeague() {
	m.clearedleague = true
}

// LeagueCleared reports if the "league" edge to the League entity was cleared.
func (m *StandingsMutation) LeagueCleared() bool {
	return m.clearedleague
}

// LeagueID returns the "league" edge ID in the mutation.
func (m *StandingsMutation) LeagueID() (id int, exists bool) {
	if m.league != nil {
		return *m.league, true
	}
	return
}

// LeagueIDs returns the "league" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LeagueID instead. It exists only for internal usage by the builders.
func (m *StandingsMutation) LeagueIDs() (ids []int) {
	if id := m.league; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLeague resets all changes to the "league" edge.
func (m *StandingsMutation) ResetLeague() {
	m.league = nil
	m.clearedleague = false
}

// SetTeamID sets the "team" edge to the Team entity by id.
func (m *StandingsMutation) SetTeamID(id int) {
	m.team = &id
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *StandingsMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *StandingsMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamID returns the "team" edge ID in the mutation.
func (m *StandingsMutation) TeamID() (id int, exists bool) {
	if m.team != nil {
		return *m.team, true
	}
	return
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *StandingsMutation) TeamIDs() (ids []int) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *StandingsMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// Where appends a list predicates to the StandingsMutation builder.
func (m *StandingsMutation) Where(ps ...predicate.Standings) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StandingsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StandingsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Standings, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StandingsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StandingsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Standings).
func (m *StandingsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StandingsMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.rank != nil {
		fields = append(fields, standings.FieldRank)
	}
	if m.description != nil {
		fields = append(fields, standings.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StandingsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case standings.FieldRank:
		return m.Rank()
	case standings.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StandingsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case standings.FieldRank:
		return m.OldRank(ctx)
	case standings.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Standings field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StandingsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case standings.FieldRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRank(v)
		return nil
	case standings.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Standings field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StandingsMutation) AddedFields() []string {
	var fields []string
	if m.addrank != nil {
		fields = append(fields, standings.FieldRank)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StandingsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case standings.FieldRank:
		return m.AddedRank()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StandingsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case standings.FieldRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRank(v)
		return nil
	}
	return fmt.Errorf("unknown Standings numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StandingsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StandingsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StandingsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Standings nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StandingsMutation) ResetField(name string) error {
	switch name {
	case standings.FieldRank:
		m.ResetRank()
		return nil
	case standings.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Standings field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StandingsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.league != nil {
		edges = append(edges, standings.EdgeLeague)
	}
	if m.team != nil {
		edges = append(edges, standings.EdgeTeam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StandingsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case standings.EdgeLeague:
		if id := m.league; id != nil {
			return []ent.Value{*id}
		}
	case standings.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StandingsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StandingsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StandingsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedleague {
		edges = append(edges, standings.EdgeLeague)
	}
	if m.clearedteam {
		edges = append(edges, standings.EdgeTeam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StandingsMutation) EdgeCleared(name string) bool {
	switch name {
	case standings.EdgeLeague:
		return m.clearedleague
	case standings.EdgeTeam:
		return m.clearedteam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StandingsMutation) ClearEdge(name string) error {
	switch name {
	case standings.EdgeLeague:
		m.ClearLeague()
		return nil
	case standings.EdgeTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown Standings unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StandingsMutation) ResetEdge(name string) error {
	switch name {
	case standings.EdgeLeague:
		m.ResetLeague()
		return nil
	case standings.EdgeTeam:
		m.ResetTeam()
		return nil
	}
	return fmt.Errorf("unknown Standings edge %s", name)
}

// TeamMutation represents an operation that mutates the Team nodes in the graph.
type TeamMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	slug               *string
	name               *string
	code               *string
	founded            *int
	addfounded         *int
	national           *bool
	logo               *string
	clearedFields      map[string]struct{}
	standings          map[int]struct{}
	removedstandings   map[int]struct{}
	clearedstandings   bool
	country            *int
	clearedcountry     bool
	leagues            map[int]struct{}
	removedleagues     map[int]struct{}
	clearedleagues     bool
	players            map[int]struct{}
	removedplayers     map[int]struct{}
	clearedplayers     bool
	teamSeasons        map[int]struct{}
	removedteamSeasons map[int]struct{}
	clearedteamSeasons bool
	done               bool
	oldValue           func(context.Context) (*Team, error)
	predicates         []predicate.Team
}

var _ ent.Mutation = (*TeamMutation)(nil)

// teamOption allows management of the mutation configuration using functional options.
type teamOption func(*TeamMutation)

// newTeamMutation creates new mutation for the Team entity.
func newTeamMutation(c config, op Op, opts ...teamOption) *TeamMutation {
	m := &TeamMutation{
		config:        c,
		op:            op,
		typ:           TypeTeam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamID sets the ID field of the mutation.
func withTeamID(id int) teamOption {
	return func(m *TeamMutation) {
		var (
			err   error
			once  sync.Once
			value *Team
		)
		m.oldValue = func(ctx context.Context) (*Team, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Team.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeam sets the old Team of the mutation.
func withTeam(node *Team) teamOption {
	return func(m *TeamMutation) {
		m.oldValue = func(context.Context) (*Team, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Team entities.
func (m *TeamMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Team.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSlug sets the "slug" field.
func (m *TeamMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *TeamMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *TeamMutation) ResetSlug() {
	m.slug = nil
}

// SetName sets the "name" field.
func (m *TeamMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TeamMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TeamMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *TeamMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *TeamMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *TeamMutation) ResetCode() {
	m.code = nil
}

// SetFounded sets the "founded" field.
func (m *TeamMutation) SetFounded(i int) {
	m.founded = &i
	m.addfounded = nil
}

// Founded returns the value of the "founded" field in the mutation.
func (m *TeamMutation) Founded() (r int, exists bool) {
	v := m.founded
	if v == nil {
		return
	}
	return *v, true
}

// OldFounded returns the old "founded" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldFounded(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFounded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFounded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFounded: %w", err)
	}
	return oldValue.Founded, nil
}

// AddFounded adds i to the "founded" field.
func (m *TeamMutation) AddFounded(i int) {
	if m.addfounded != nil {
		*m.addfounded += i
	} else {
		m.addfounded = &i
	}
}

// AddedFounded returns the value that was added to the "founded" field in this mutation.
func (m *TeamMutation) AddedFounded() (r int, exists bool) {
	v := m.addfounded
	if v == nil {
		return
	}
	return *v, true
}

// ResetFounded resets all changes to the "founded" field.
func (m *TeamMutation) ResetFounded() {
	m.founded = nil
	m.addfounded = nil
}

// SetNational sets the "national" field.
func (m *TeamMutation) SetNational(b bool) {
	m.national = &b
}

// National returns the value of the "national" field in the mutation.
func (m *TeamMutation) National() (r bool, exists bool) {
	v := m.national
	if v == nil {
		return
	}
	return *v, true
}

// OldNational returns the old "national" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldNational(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNational is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNational requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNational: %w", err)
	}
	return oldValue.National, nil
}

// ResetNational resets all changes to the "national" field.
func (m *TeamMutation) ResetNational() {
	m.national = nil
}

// SetLogo sets the "logo" field.
func (m *TeamMutation) SetLogo(s string) {
	m.logo = &s
}

// Logo returns the value of the "logo" field in the mutation.
func (m *TeamMutation) Logo() (r string, exists bool) {
	v := m.logo
	if v == nil {
		return
	}
	return *v, true
}

// OldLogo returns the old "logo" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldLogo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogo: %w", err)
	}
	return oldValue.Logo, nil
}

// ResetLogo resets all changes to the "logo" field.
func (m *TeamMutation) ResetLogo() {
	m.logo = nil
}

// AddStandingIDs adds the "standings" edge to the Standings entity by ids.
func (m *TeamMutation) AddStandingIDs(ids ...int) {
	if m.standings == nil {
		m.standings = make(map[int]struct{})
	}
	for i := range ids {
		m.standings[ids[i]] = struct{}{}
	}
}

// ClearStandings clears the "standings" edge to the Standings entity.
func (m *TeamMutation) ClearStandings() {
	m.clearedstandings = true
}

// StandingsCleared reports if the "standings" edge to the Standings entity was cleared.
func (m *TeamMutation) StandingsCleared() bool {
	return m.clearedstandings
}

// RemoveStandingIDs removes the "standings" edge to the Standings entity by IDs.
func (m *TeamMutation) RemoveStandingIDs(ids ...int) {
	if m.removedstandings == nil {
		m.removedstandings = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.standings, ids[i])
		m.removedstandings[ids[i]] = struct{}{}
	}
}

// RemovedStandings returns the removed IDs of the "standings" edge to the Standings entity.
func (m *TeamMutation) RemovedStandingsIDs() (ids []int) {
	for id := range m.removedstandings {
		ids = append(ids, id)
	}
	return
}

// StandingsIDs returns the "standings" edge IDs in the mutation.
func (m *TeamMutation) StandingsIDs() (ids []int) {
	for id := range m.standings {
		ids = append(ids, id)
	}
	return
}

// ResetStandings resets all changes to the "standings" edge.
func (m *TeamMutation) ResetStandings() {
	m.standings = nil
	m.clearedstandings = false
	m.removedstandings = nil
}

// SetCountryID sets the "country" edge to the Country entity by id.
func (m *TeamMutation) SetCountryID(id int) {
	m.country = &id
}

// ClearCountry clears the "country" edge to the Country entity.
func (m *TeamMutation) ClearCountry() {
	m.clearedcountry = true
}

// CountryCleared reports if the "country" edge to the Country entity was cleared.
func (m *TeamMutation) CountryCleared() bool {
	return m.clearedcountry
}

// CountryID returns the "country" edge ID in the mutation.
func (m *TeamMutation) CountryID() (id int, exists bool) {
	if m.country != nil {
		return *m.country, true
	}
	return
}

// CountryIDs returns the "country" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CountryID instead. It exists only for internal usage by the builders.
func (m *TeamMutation) CountryIDs() (ids []int) {
	if id := m.country; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCountry resets all changes to the "country" edge.
func (m *TeamMutation) ResetCountry() {
	m.country = nil
	m.clearedcountry = false
}

// AddLeagueIDs adds the "leagues" edge to the League entity by ids.
func (m *TeamMutation) AddLeagueIDs(ids ...int) {
	if m.leagues == nil {
		m.leagues = make(map[int]struct{})
	}
	for i := range ids {
		m.leagues[ids[i]] = struct{}{}
	}
}

// ClearLeagues clears the "leagues" edge to the League entity.
func (m *TeamMutation) ClearLeagues() {
	m.clearedleagues = true
}

// LeaguesCleared reports if the "leagues" edge to the League entity was cleared.
func (m *TeamMutation) LeaguesCleared() bool {
	return m.clearedleagues
}

// RemoveLeagueIDs removes the "leagues" edge to the League entity by IDs.
func (m *TeamMutation) RemoveLeagueIDs(ids ...int) {
	if m.removedleagues == nil {
		m.removedleagues = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.leagues, ids[i])
		m.removedleagues[ids[i]] = struct{}{}
	}
}

// RemovedLeagues returns the removed IDs of the "leagues" edge to the League entity.
func (m *TeamMutation) RemovedLeaguesIDs() (ids []int) {
	for id := range m.removedleagues {
		ids = append(ids, id)
	}
	return
}

// LeaguesIDs returns the "leagues" edge IDs in the mutation.
func (m *TeamMutation) LeaguesIDs() (ids []int) {
	for id := range m.leagues {
		ids = append(ids, id)
	}
	return
}

// ResetLeagues resets all changes to the "leagues" edge.
func (m *TeamMutation) ResetLeagues() {
	m.leagues = nil
	m.clearedleagues = false
	m.removedleagues = nil
}

// AddPlayerIDs adds the "players" edge to the Player entity by ids.
func (m *TeamMutation) AddPlayerIDs(ids ...int) {
	if m.players == nil {
		m.players = make(map[int]struct{})
	}
	for i := range ids {
		m.players[ids[i]] = struct{}{}
	}
}

// ClearPlayers clears the "players" edge to the Player entity.
func (m *TeamMutation) ClearPlayers() {
	m.clearedplayers = true
}

// PlayersCleared reports if the "players" edge to the Player entity was cleared.
func (m *TeamMutation) PlayersCleared() bool {
	return m.clearedplayers
}

// RemovePlayerIDs removes the "players" edge to the Player entity by IDs.
func (m *TeamMutation) RemovePlayerIDs(ids ...int) {
	if m.removedplayers == nil {
		m.removedplayers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.players, ids[i])
		m.removedplayers[ids[i]] = struct{}{}
	}
}

// RemovedPlayers returns the removed IDs of the "players" edge to the Player entity.
func (m *TeamMutation) RemovedPlayersIDs() (ids []int) {
	for id := range m.removedplayers {
		ids = append(ids, id)
	}
	return
}

// PlayersIDs returns the "players" edge IDs in the mutation.
func (m *TeamMutation) PlayersIDs() (ids []int) {
	for id := range m.players {
		ids = append(ids, id)
	}
	return
}

// ResetPlayers resets all changes to the "players" edge.
func (m *TeamMutation) ResetPlayers() {
	m.players = nil
	m.clearedplayers = false
	m.removedplayers = nil
}

// AddTeamSeasonIDs adds the "teamSeasons" edge to the TeamSeason entity by ids.
func (m *TeamMutation) AddTeamSeasonIDs(ids ...int) {
	if m.teamSeasons == nil {
		m.teamSeasons = make(map[int]struct{})
	}
	for i := range ids {
		m.teamSeasons[ids[i]] = struct{}{}
	}
}

// ClearTeamSeasons clears the "teamSeasons" edge to the TeamSeason entity.
func (m *TeamMutation) ClearTeamSeasons() {
	m.clearedteamSeasons = true
}

// TeamSeasonsCleared reports if the "teamSeasons" edge to the TeamSeason entity was cleared.
func (m *TeamMutation) TeamSeasonsCleared() bool {
	return m.clearedteamSeasons
}

// RemoveTeamSeasonIDs removes the "teamSeasons" edge to the TeamSeason entity by IDs.
func (m *TeamMutation) RemoveTeamSeasonIDs(ids ...int) {
	if m.removedteamSeasons == nil {
		m.removedteamSeasons = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.teamSeasons, ids[i])
		m.removedteamSeasons[ids[i]] = struct{}{}
	}
}

// RemovedTeamSeasons returns the removed IDs of the "teamSeasons" edge to the TeamSeason entity.
func (m *TeamMutation) RemovedTeamSeasonsIDs() (ids []int) {
	for id := range m.removedteamSeasons {
		ids = append(ids, id)
	}
	return
}

// TeamSeasonsIDs returns the "teamSeasons" edge IDs in the mutation.
func (m *TeamMutation) TeamSeasonsIDs() (ids []int) {
	for id := range m.teamSeasons {
		ids = append(ids, id)
	}
	return
}

// ResetTeamSeasons resets all changes to the "teamSeasons" edge.
func (m *TeamMutation) ResetTeamSeasons() {
	m.teamSeasons = nil
	m.clearedteamSeasons = false
	m.removedteamSeasons = nil
}

// Where appends a list predicates to the TeamMutation builder.
func (m *TeamMutation) Where(ps ...predicate.Team) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TeamMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TeamMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Team, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TeamMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TeamMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Team).
func (m *TeamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.slug != nil {
		fields = append(fields, team.FieldSlug)
	}
	if m.name != nil {
		fields = append(fields, team.FieldName)
	}
	if m.code != nil {
		fields = append(fields, team.FieldCode)
	}
	if m.founded != nil {
		fields = append(fields, team.FieldFounded)
	}
	if m.national != nil {
		fields = append(fields, team.FieldNational)
	}
	if m.logo != nil {
		fields = append(fields, team.FieldLogo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case team.FieldSlug:
		return m.Slug()
	case team.FieldName:
		return m.Name()
	case team.FieldCode:
		return m.Code()
	case team.FieldFounded:
		return m.Founded()
	case team.FieldNational:
		return m.National()
	case team.FieldLogo:
		return m.Logo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case team.FieldSlug:
		return m.OldSlug(ctx)
	case team.FieldName:
		return m.OldName(ctx)
	case team.FieldCode:
		return m.OldCode(ctx)
	case team.FieldFounded:
		return m.OldFounded(ctx)
	case team.FieldNational:
		return m.OldNational(ctx)
	case team.FieldLogo:
		return m.OldLogo(ctx)
	}
	return nil, fmt.Errorf("unknown Team field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case team.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case team.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case team.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case team.FieldFounded:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFounded(v)
		return nil
	case team.FieldNational:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNational(v)
		return nil
	case team.FieldLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogo(v)
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamMutation) AddedFields() []string {
	var fields []string
	if m.addfounded != nil {
		fields = append(fields, team.FieldFounded)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case team.FieldFounded:
		return m.AddedFounded()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) AddField(name string, value ent.Value) error {
	switch name {
	case team.FieldFounded:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFounded(v)
		return nil
	}
	return fmt.Errorf("unknown Team numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Team nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamMutation) ResetField(name string) error {
	switch name {
	case team.FieldSlug:
		m.ResetSlug()
		return nil
	case team.FieldName:
		m.ResetName()
		return nil
	case team.FieldCode:
		m.ResetCode()
		return nil
	case team.FieldFounded:
		m.ResetFounded()
		return nil
	case team.FieldNational:
		m.ResetNational()
		return nil
	case team.FieldLogo:
		m.ResetLogo()
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.standings != nil {
		edges = append(edges, team.EdgeStandings)
	}
	if m.country != nil {
		edges = append(edges, team.EdgeCountry)
	}
	if m.leagues != nil {
		edges = append(edges, team.EdgeLeagues)
	}
	if m.players != nil {
		edges = append(edges, team.EdgePlayers)
	}
	if m.teamSeasons != nil {
		edges = append(edges, team.EdgeTeamSeasons)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeStandings:
		ids := make([]ent.Value, 0, len(m.standings))
		for id := range m.standings {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeCountry:
		if id := m.country; id != nil {
			return []ent.Value{*id}
		}
	case team.EdgeLeagues:
		ids := make([]ent.Value, 0, len(m.leagues))
		for id := range m.leagues {
			ids = append(ids, id)
		}
		return ids
	case team.EdgePlayers:
		ids := make([]ent.Value, 0, len(m.players))
		for id := range m.players {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeTeamSeasons:
		ids := make([]ent.Value, 0, len(m.teamSeasons))
		for id := range m.teamSeasons {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedstandings != nil {
		edges = append(edges, team.EdgeStandings)
	}
	if m.removedleagues != nil {
		edges = append(edges, team.EdgeLeagues)
	}
	if m.removedplayers != nil {
		edges = append(edges, team.EdgePlayers)
	}
	if m.removedteamSeasons != nil {
		edges = append(edges, team.EdgeTeamSeasons)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeStandings:
		ids := make([]ent.Value, 0, len(m.removedstandings))
		for id := range m.removedstandings {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeLeagues:
		ids := make([]ent.Value, 0, len(m.removedleagues))
		for id := range m.removedleagues {
			ids = append(ids, id)
		}
		return ids
	case team.EdgePlayers:
		ids := make([]ent.Value, 0, len(m.removedplayers))
		for id := range m.removedplayers {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeTeamSeasons:
		ids := make([]ent.Value, 0, len(m.removedteamSeasons))
		for id := range m.removedteamSeasons {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedstandings {
		edges = append(edges, team.EdgeStandings)
	}
	if m.clearedcountry {
		edges = append(edges, team.EdgeCountry)
	}
	if m.clearedleagues {
		edges = append(edges, team.EdgeLeagues)
	}
	if m.clearedplayers {
		edges = append(edges, team.EdgePlayers)
	}
	if m.clearedteamSeasons {
		edges = append(edges, team.EdgeTeamSeasons)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamMutation) EdgeCleared(name string) bool {
	switch name {
	case team.EdgeStandings:
		return m.clearedstandings
	case team.EdgeCountry:
		return m.clearedcountry
	case team.EdgeLeagues:
		return m.clearedleagues
	case team.EdgePlayers:
		return m.clearedplayers
	case team.EdgeTeamSeasons:
		return m.clearedteamSeasons
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamMutation) ClearEdge(name string) error {
	switch name {
	case team.EdgeCountry:
		m.ClearCountry()
		return nil
	}
	return fmt.Errorf("unknown Team unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamMutation) ResetEdge(name string) error {
	switch name {
	case team.EdgeStandings:
		m.ResetStandings()
		return nil
	case team.EdgeCountry:
		m.ResetCountry()
		return nil
	case team.EdgeLeagues:
		m.ResetLeagues()
		return nil
	case team.EdgePlayers:
		m.ResetPlayers()
		return nil
	case team.EdgeTeamSeasons:
		m.ResetTeamSeasons()
		return nil
	}
	return fmt.Errorf("unknown Team edge %s", name)
}

// TeamSeasonMutation represents an operation that mutates the TeamSeason nodes in the graph.
type TeamSeasonMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	team_season_id           *int
	addteam_season_id        *int
	clearedFields            map[string]struct{}
	team                     *int
	clearedteam              bool
	season                   *int
	clearedseason            bool
	playerTeamSeasons        map[int]struct{}
	removedplayerTeamSeasons map[int]struct{}
	clearedplayerTeamSeasons bool
	done                     bool
	oldValue                 func(context.Context) (*TeamSeason, error)
	predicates               []predicate.TeamSeason
}

var _ ent.Mutation = (*TeamSeasonMutation)(nil)

// teamseasonOption allows management of the mutation configuration using functional options.
type teamseasonOption func(*TeamSeasonMutation)

// newTeamSeasonMutation creates new mutation for the TeamSeason entity.
func newTeamSeasonMutation(c config, op Op, opts ...teamseasonOption) *TeamSeasonMutation {
	m := &TeamSeasonMutation{
		config:        c,
		op:            op,
		typ:           TypeTeamSeason,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamSeasonID sets the ID field of the mutation.
func withTeamSeasonID(id int) teamseasonOption {
	return func(m *TeamSeasonMutation) {
		var (
			err   error
			once  sync.Once
			value *TeamSeason
		)
		m.oldValue = func(ctx context.Context) (*TeamSeason, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TeamSeason.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeamSeason sets the old TeamSeason of the mutation.
func withTeamSeason(node *TeamSeason) teamseasonOption {
	return func(m *TeamSeasonMutation) {
		m.oldValue = func(context.Context) (*TeamSeason, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamSeasonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamSeasonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamSeasonMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamSeasonMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TeamSeason.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTeamSeasonID sets the "team_season_id" field.
func (m *TeamSeasonMutation) SetTeamSeasonID(i int) {
	m.team_season_id = &i
	m.addteam_season_id = nil
}

// TeamSeasonID returns the value of the "team_season_id" field in the mutation.
func (m *TeamSeasonMutation) TeamSeasonID() (r int, exists bool) {
	v := m.team_season_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamSeasonID returns the old "team_season_id" field's value of the TeamSeason entity.
// If the TeamSeason object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamSeasonMutation) OldTeamSeasonID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamSeasonID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamSeasonID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamSeasonID: %w", err)
	}
	return oldValue.TeamSeasonID, nil
}

// AddTeamSeasonID adds i to the "team_season_id" field.
func (m *TeamSeasonMutation) AddTeamSeasonID(i int) {
	if m.addteam_season_id != nil {
		*m.addteam_season_id += i
	} else {
		m.addteam_season_id = &i
	}
}

// AddedTeamSeasonID returns the value that was added to the "team_season_id" field in this mutation.
func (m *TeamSeasonMutation) AddedTeamSeasonID() (r int, exists bool) {
	v := m.addteam_season_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTeamSeasonID resets all changes to the "team_season_id" field.
func (m *TeamSeasonMutation) ResetTeamSeasonID() {
	m.team_season_id = nil
	m.addteam_season_id = nil
}

// SetTeamID sets the "team" edge to the Team entity by id.
func (m *TeamSeasonMutation) SetTeamID(id int) {
	m.team = &id
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *TeamSeasonMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *TeamSeasonMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamID returns the "team" edge ID in the mutation.
func (m *TeamSeasonMutation) TeamID() (id int, exists bool) {
	if m.team != nil {
		return *m.team, true
	}
	return
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *TeamSeasonMutation) TeamIDs() (ids []int) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *TeamSeasonMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// SetSeasonID sets the "season" edge to the Season entity by id.
func (m *TeamSeasonMutation) SetSeasonID(id int) {
	m.season = &id
}

// ClearSeason clears the "season" edge to the Season entity.
func (m *TeamSeasonMutation) ClearSeason() {
	m.clearedseason = true
}

// SeasonCleared reports if the "season" edge to the Season entity was cleared.
func (m *TeamSeasonMutation) SeasonCleared() bool {
	return m.clearedseason
}

// SeasonID returns the "season" edge ID in the mutation.
func (m *TeamSeasonMutation) SeasonID() (id int, exists bool) {
	if m.season != nil {
		return *m.season, true
	}
	return
}

// SeasonIDs returns the "season" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SeasonID instead. It exists only for internal usage by the builders.
func (m *TeamSeasonMutation) SeasonIDs() (ids []int) {
	if id := m.season; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSeason resets all changes to the "season" edge.
func (m *TeamSeasonMutation) ResetSeason() {
	m.season = nil
	m.clearedseason = false
}

// AddPlayerTeamSeasonIDs adds the "playerTeamSeasons" edge to the PlayerTeamSeason entity by ids.
func (m *TeamSeasonMutation) AddPlayerTeamSeasonIDs(ids ...int) {
	if m.playerTeamSeasons == nil {
		m.playerTeamSeasons = make(map[int]struct{})
	}
	for i := range ids {
		m.playerTeamSeasons[ids[i]] = struct{}{}
	}
}

// ClearPlayerTeamSeasons clears the "playerTeamSeasons" edge to the PlayerTeamSeason entity.
func (m *TeamSeasonMutation) ClearPlayerTeamSeasons() {
	m.clearedplayerTeamSeasons = true
}

// PlayerTeamSeasonsCleared reports if the "playerTeamSeasons" edge to the PlayerTeamSeason entity was cleared.
func (m *TeamSeasonMutation) PlayerTeamSeasonsCleared() bool {
	return m.clearedplayerTeamSeasons
}

// RemovePlayerTeamSeasonIDs removes the "playerTeamSeasons" edge to the PlayerTeamSeason entity by IDs.
func (m *TeamSeasonMutation) RemovePlayerTeamSeasonIDs(ids ...int) {
	if m.removedplayerTeamSeasons == nil {
		m.removedplayerTeamSeasons = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.playerTeamSeasons, ids[i])
		m.removedplayerTeamSeasons[ids[i]] = struct{}{}
	}
}

// RemovedPlayerTeamSeasons returns the removed IDs of the "playerTeamSeasons" edge to the PlayerTeamSeason entity.
func (m *TeamSeasonMutation) RemovedPlayerTeamSeasonsIDs() (ids []int) {
	for id := range m.removedplayerTeamSeasons {
		ids = append(ids, id)
	}
	return
}

// PlayerTeamSeasonsIDs returns the "playerTeamSeasons" edge IDs in the mutation.
func (m *TeamSeasonMutation) PlayerTeamSeasonsIDs() (ids []int) {
	for id := range m.playerTeamSeasons {
		ids = append(ids, id)
	}
	return
}

// ResetPlayerTeamSeasons resets all changes to the "playerTeamSeasons" edge.
func (m *TeamSeasonMutation) ResetPlayerTeamSeasons() {
	m.playerTeamSeasons = nil
	m.clearedplayerTeamSeasons = false
	m.removedplayerTeamSeasons = nil
}

// Where appends a list predicates to the TeamSeasonMutation builder.
func (m *TeamSeasonMutation) Where(ps ...predicate.TeamSeason) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TeamSeasonMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TeamSeasonMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TeamSeason, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TeamSeasonMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TeamSeasonMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TeamSeason).
func (m *TeamSeasonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamSeasonMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.team_season_id != nil {
		fields = append(fields, teamseason.FieldTeamSeasonID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamSeasonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case teamseason.FieldTeamSeasonID:
		return m.TeamSeasonID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamSeasonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case teamseason.FieldTeamSeasonID:
		return m.OldTeamSeasonID(ctx)
	}
	return nil, fmt.Errorf("unknown TeamSeason field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamSeasonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case teamseason.FieldTeamSeasonID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamSeasonID(v)
		return nil
	}
	return fmt.Errorf("unknown TeamSeason field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamSeasonMutation) AddedFields() []string {
	var fields []string
	if m.addteam_season_id != nil {
		fields = append(fields, teamseason.FieldTeamSeasonID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamSeasonMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case teamseason.FieldTeamSeasonID:
		return m.AddedTeamSeasonID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamSeasonMutation) AddField(name string, value ent.Value) error {
	switch name {
	case teamseason.FieldTeamSeasonID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTeamSeasonID(v)
		return nil
	}
	return fmt.Errorf("unknown TeamSeason numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamSeasonMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamSeasonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamSeasonMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TeamSeason nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamSeasonMutation) ResetField(name string) error {
	switch name {
	case teamseason.FieldTeamSeasonID:
		m.ResetTeamSeasonID()
		return nil
	}
	return fmt.Errorf("unknown TeamSeason field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamSeasonMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.team != nil {
		edges = append(edges, teamseason.EdgeTeam)
	}
	if m.season != nil {
		edges = append(edges, teamseason.EdgeSeason)
	}
	if m.playerTeamSeasons != nil {
		edges = append(edges, teamseason.EdgePlayerTeamSeasons)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamSeasonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case teamseason.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	case teamseason.EdgeSeason:
		if id := m.season; id != nil {
			return []ent.Value{*id}
		}
	case teamseason.EdgePlayerTeamSeasons:
		ids := make([]ent.Value, 0, len(m.playerTeamSeasons))
		for id := range m.playerTeamSeasons {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamSeasonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedplayerTeamSeasons != nil {
		edges = append(edges, teamseason.EdgePlayerTeamSeasons)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamSeasonMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case teamseason.EdgePlayerTeamSeasons:
		ids := make([]ent.Value, 0, len(m.removedplayerTeamSeasons))
		for id := range m.removedplayerTeamSeasons {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamSeasonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedteam {
		edges = append(edges, teamseason.EdgeTeam)
	}
	if m.clearedseason {
		edges = append(edges, teamseason.EdgeSeason)
	}
	if m.clearedplayerTeamSeasons {
		edges = append(edges, teamseason.EdgePlayerTeamSeasons)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamSeasonMutation) EdgeCleared(name string) bool {
	switch name {
	case teamseason.EdgeTeam:
		return m.clearedteam
	case teamseason.EdgeSeason:
		return m.clearedseason
	case teamseason.EdgePlayerTeamSeasons:
		return m.clearedplayerTeamSeasons
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamSeasonMutation) ClearEdge(name string) error {
	switch name {
	case teamseason.EdgeTeam:
		m.ClearTeam()
		return nil
	case teamseason.EdgeSeason:
		m.ClearSeason()
		return nil
	}
	return fmt.Errorf("unknown TeamSeason unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamSeasonMutation) ResetEdge(name string) error {
	switch name {
	case teamseason.EdgeTeam:
		m.ResetTeam()
		return nil
	case teamseason.EdgeSeason:
		m.ResetSeason()
		return nil
	case teamseason.EdgePlayerTeamSeasons:
		m.ResetPlayerTeamSeasons()
		return nil
	}
	return fmt.Errorf("unknown TeamSeason edge %s", name)
}
