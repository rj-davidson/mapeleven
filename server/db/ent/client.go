// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"mapeleven/db/ent/migrate"

	"mapeleven/db/ent/birth"
	"mapeleven/db/ent/club"
	"mapeleven/db/ent/country"
	"mapeleven/db/ent/fixture"
	"mapeleven/db/ent/league"
	"mapeleven/db/ent/player"
	"mapeleven/db/ent/playerseason"
	"mapeleven/db/ent/season"
	"mapeleven/db/ent/standings"
	"mapeleven/db/ent/team"
	"mapeleven/db/ent/tsbiggest"
	"mapeleven/db/ent/tscards"
	"mapeleven/db/ent/tscleansheet"
	"mapeleven/db/ent/tsfailedtoscore"
	"mapeleven/db/ent/tsfixtures"
	"mapeleven/db/ent/tsgoals"
	"mapeleven/db/ent/tslineups"
	"mapeleven/db/ent/tspenalty"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Birth is the client for interacting with the Birth builders.
	Birth *BirthClient
	// Club is the client for interacting with the Club builders.
	Club *ClubClient
	// Country is the client for interacting with the Country builders.
	Country *CountryClient
	// Fixture is the client for interacting with the Fixture builders.
	Fixture *FixtureClient
	// League is the client for interacting with the League builders.
	League *LeagueClient
	// Player is the client for interacting with the Player builders.
	Player *PlayerClient
	// PlayerSeason is the client for interacting with the PlayerSeason builders.
	PlayerSeason *PlayerSeasonClient
	// Season is the client for interacting with the Season builders.
	Season *SeasonClient
	// Standings is the client for interacting with the Standings builders.
	Standings *StandingsClient
	// TSBiggest is the client for interacting with the TSBiggest builders.
	TSBiggest *TSBiggestClient
	// TSCards is the client for interacting with the TSCards builders.
	TSCards *TSCardsClient
	// TSCleanSheet is the client for interacting with the TSCleanSheet builders.
	TSCleanSheet *TSCleanSheetClient
	// TSFailedToScore is the client for interacting with the TSFailedToScore builders.
	TSFailedToScore *TSFailedToScoreClient
	// TSFixtures is the client for interacting with the TSFixtures builders.
	TSFixtures *TSFixturesClient
	// TSGoals is the client for interacting with the TSGoals builders.
	TSGoals *TSGoalsClient
	// TSLineups is the client for interacting with the TSLineups builders.
	TSLineups *TSLineupsClient
	// TSPenalty is the client for interacting with the TSPenalty builders.
	TSPenalty *TSPenaltyClient
	// Team is the client for interacting with the Team builders.
	Team *TeamClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Birth = NewBirthClient(c.config)
	c.Club = NewClubClient(c.config)
	c.Country = NewCountryClient(c.config)
	c.Fixture = NewFixtureClient(c.config)
	c.League = NewLeagueClient(c.config)
	c.Player = NewPlayerClient(c.config)
	c.PlayerSeason = NewPlayerSeasonClient(c.config)
	c.Season = NewSeasonClient(c.config)
	c.Standings = NewStandingsClient(c.config)
	c.TSBiggest = NewTSBiggestClient(c.config)
	c.TSCards = NewTSCardsClient(c.config)
	c.TSCleanSheet = NewTSCleanSheetClient(c.config)
	c.TSFailedToScore = NewTSFailedToScoreClient(c.config)
	c.TSFixtures = NewTSFixturesClient(c.config)
	c.TSGoals = NewTSGoalsClient(c.config)
	c.TSLineups = NewTSLineupsClient(c.config)
	c.TSPenalty = NewTSPenaltyClient(c.config)
	c.Team = NewTeamClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		Birth:           NewBirthClient(cfg),
		Club:            NewClubClient(cfg),
		Country:         NewCountryClient(cfg),
		Fixture:         NewFixtureClient(cfg),
		League:          NewLeagueClient(cfg),
		Player:          NewPlayerClient(cfg),
		PlayerSeason:    NewPlayerSeasonClient(cfg),
		Season:          NewSeasonClient(cfg),
		Standings:       NewStandingsClient(cfg),
		TSBiggest:       NewTSBiggestClient(cfg),
		TSCards:         NewTSCardsClient(cfg),
		TSCleanSheet:    NewTSCleanSheetClient(cfg),
		TSFailedToScore: NewTSFailedToScoreClient(cfg),
		TSFixtures:      NewTSFixturesClient(cfg),
		TSGoals:         NewTSGoalsClient(cfg),
		TSLineups:       NewTSLineupsClient(cfg),
		TSPenalty:       NewTSPenaltyClient(cfg),
		Team:            NewTeamClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		Birth:           NewBirthClient(cfg),
		Club:            NewClubClient(cfg),
		Country:         NewCountryClient(cfg),
		Fixture:         NewFixtureClient(cfg),
		League:          NewLeagueClient(cfg),
		Player:          NewPlayerClient(cfg),
		PlayerSeason:    NewPlayerSeasonClient(cfg),
		Season:          NewSeasonClient(cfg),
		Standings:       NewStandingsClient(cfg),
		TSBiggest:       NewTSBiggestClient(cfg),
		TSCards:         NewTSCardsClient(cfg),
		TSCleanSheet:    NewTSCleanSheetClient(cfg),
		TSFailedToScore: NewTSFailedToScoreClient(cfg),
		TSFixtures:      NewTSFixturesClient(cfg),
		TSGoals:         NewTSGoalsClient(cfg),
		TSLineups:       NewTSLineupsClient(cfg),
		TSPenalty:       NewTSPenaltyClient(cfg),
		Team:            NewTeamClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Birth.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Birth, c.Club, c.Country, c.Fixture, c.League, c.Player, c.PlayerSeason,
		c.Season, c.Standings, c.TSBiggest, c.TSCards, c.TSCleanSheet,
		c.TSFailedToScore, c.TSFixtures, c.TSGoals, c.TSLineups, c.TSPenalty, c.Team,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Birth, c.Club, c.Country, c.Fixture, c.League, c.Player, c.PlayerSeason,
		c.Season, c.Standings, c.TSBiggest, c.TSCards, c.TSCleanSheet,
		c.TSFailedToScore, c.TSFixtures, c.TSGoals, c.TSLineups, c.TSPenalty, c.Team,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *BirthMutation:
		return c.Birth.mutate(ctx, m)
	case *ClubMutation:
		return c.Club.mutate(ctx, m)
	case *CountryMutation:
		return c.Country.mutate(ctx, m)
	case *FixtureMutation:
		return c.Fixture.mutate(ctx, m)
	case *LeagueMutation:
		return c.League.mutate(ctx, m)
	case *PlayerMutation:
		return c.Player.mutate(ctx, m)
	case *PlayerSeasonMutation:
		return c.PlayerSeason.mutate(ctx, m)
	case *SeasonMutation:
		return c.Season.mutate(ctx, m)
	case *StandingsMutation:
		return c.Standings.mutate(ctx, m)
	case *TSBiggestMutation:
		return c.TSBiggest.mutate(ctx, m)
	case *TSCardsMutation:
		return c.TSCards.mutate(ctx, m)
	case *TSCleanSheetMutation:
		return c.TSCleanSheet.mutate(ctx, m)
	case *TSFailedToScoreMutation:
		return c.TSFailedToScore.mutate(ctx, m)
	case *TSFixturesMutation:
		return c.TSFixtures.mutate(ctx, m)
	case *TSGoalsMutation:
		return c.TSGoals.mutate(ctx, m)
	case *TSLineupsMutation:
		return c.TSLineups.mutate(ctx, m)
	case *TSPenaltyMutation:
		return c.TSPenalty.mutate(ctx, m)
	case *TeamMutation:
		return c.Team.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// BirthClient is a client for the Birth schema.
type BirthClient struct {
	config
}

// NewBirthClient returns a client for the Birth from the given config.
func NewBirthClient(c config) *BirthClient {
	return &BirthClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `birth.Hooks(f(g(h())))`.
func (c *BirthClient) Use(hooks ...Hook) {
	c.hooks.Birth = append(c.hooks.Birth, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `birth.Intercept(f(g(h())))`.
func (c *BirthClient) Intercept(interceptors ...Interceptor) {
	c.inters.Birth = append(c.inters.Birth, interceptors...)
}

// Create returns a builder for creating a Birth entity.
func (c *BirthClient) Create() *BirthCreate {
	mutation := newBirthMutation(c.config, OpCreate)
	return &BirthCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Birth entities.
func (c *BirthClient) CreateBulk(builders ...*BirthCreate) *BirthCreateBulk {
	return &BirthCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Birth.
func (c *BirthClient) Update() *BirthUpdate {
	mutation := newBirthMutation(c.config, OpUpdate)
	return &BirthUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BirthClient) UpdateOne(b *Birth) *BirthUpdateOne {
	mutation := newBirthMutation(c.config, OpUpdateOne, withBirth(b))
	return &BirthUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BirthClient) UpdateOneID(id int) *BirthUpdateOne {
	mutation := newBirthMutation(c.config, OpUpdateOne, withBirthID(id))
	return &BirthUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Birth.
func (c *BirthClient) Delete() *BirthDelete {
	mutation := newBirthMutation(c.config, OpDelete)
	return &BirthDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BirthClient) DeleteOne(b *Birth) *BirthDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BirthClient) DeleteOneID(id int) *BirthDeleteOne {
	builder := c.Delete().Where(birth.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BirthDeleteOne{builder}
}

// Query returns a query builder for Birth.
func (c *BirthClient) Query() *BirthQuery {
	return &BirthQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBirth},
		inters: c.Interceptors(),
	}
}

// Get returns a Birth entity by its id.
func (c *BirthClient) Get(ctx context.Context, id int) (*Birth, error) {
	return c.Query().Where(birth.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BirthClient) GetX(ctx context.Context, id int) *Birth {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlayer queries the player edge of a Birth.
func (c *BirthClient) QueryPlayer(b *Birth) *PlayerQuery {
	query := (&PlayerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(birth.Table, birth.FieldID, id),
			sqlgraph.To(player.Table, player.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, birth.PlayerTable, birth.PlayerColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BirthClient) Hooks() []Hook {
	return c.hooks.Birth
}

// Interceptors returns the client interceptors.
func (c *BirthClient) Interceptors() []Interceptor {
	return c.inters.Birth
}

func (c *BirthClient) mutate(ctx context.Context, m *BirthMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BirthCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BirthUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BirthUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BirthDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Birth mutation op: %q", m.Op())
	}
}

// ClubClient is a client for the Club schema.
type ClubClient struct {
	config
}

// NewClubClient returns a client for the Club from the given config.
func NewClubClient(c config) *ClubClient {
	return &ClubClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `club.Hooks(f(g(h())))`.
func (c *ClubClient) Use(hooks ...Hook) {
	c.hooks.Club = append(c.hooks.Club, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `club.Intercept(f(g(h())))`.
func (c *ClubClient) Intercept(interceptors ...Interceptor) {
	c.inters.Club = append(c.inters.Club, interceptors...)
}

// Create returns a builder for creating a Club entity.
func (c *ClubClient) Create() *ClubCreate {
	mutation := newClubMutation(c.config, OpCreate)
	return &ClubCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Club entities.
func (c *ClubClient) CreateBulk(builders ...*ClubCreate) *ClubCreateBulk {
	return &ClubCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Club.
func (c *ClubClient) Update() *ClubUpdate {
	mutation := newClubMutation(c.config, OpUpdate)
	return &ClubUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ClubClient) UpdateOne(cl *Club) *ClubUpdateOne {
	mutation := newClubMutation(c.config, OpUpdateOne, withClub(cl))
	return &ClubUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ClubClient) UpdateOneID(id int) *ClubUpdateOne {
	mutation := newClubMutation(c.config, OpUpdateOne, withClubID(id))
	return &ClubUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Club.
func (c *ClubClient) Delete() *ClubDelete {
	mutation := newClubMutation(c.config, OpDelete)
	return &ClubDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ClubClient) DeleteOne(cl *Club) *ClubDeleteOne {
	return c.DeleteOneID(cl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ClubClient) DeleteOneID(id int) *ClubDeleteOne {
	builder := c.Delete().Where(club.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ClubDeleteOne{builder}
}

// Query returns a query builder for Club.
func (c *ClubClient) Query() *ClubQuery {
	return &ClubQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeClub},
		inters: c.Interceptors(),
	}
}

// Get returns a Club entity by its id.
func (c *ClubClient) Get(ctx context.Context, id int) (*Club, error) {
	return c.Query().Where(club.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ClubClient) GetX(ctx context.Context, id int) *Club {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCountry queries the country edge of a Club.
func (c *ClubClient) QueryCountry(cl *Club) *CountryQuery {
	query := (&CountryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(club.Table, club.FieldID, id),
			sqlgraph.To(country.Table, country.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, club.CountryTable, club.CountryColumn),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeam queries the team edge of a Club.
func (c *ClubClient) QueryTeam(cl *Club) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(club.Table, club.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, club.TeamTable, club.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlayerSeasons queries the playerSeasons edge of a Club.
func (c *ClubClient) QueryPlayerSeasons(cl *Club) *PlayerSeasonQuery {
	query := (&PlayerSeasonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(club.Table, club.FieldID, id),
			sqlgraph.To(playerseason.Table, playerseason.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, club.PlayerSeasonsTable, club.PlayerSeasonsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ClubClient) Hooks() []Hook {
	return c.hooks.Club
}

// Interceptors returns the client interceptors.
func (c *ClubClient) Interceptors() []Interceptor {
	return c.inters.Club
}

func (c *ClubClient) mutate(ctx context.Context, m *ClubMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ClubCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ClubUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ClubUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ClubDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Club mutation op: %q", m.Op())
	}
}

// CountryClient is a client for the Country schema.
type CountryClient struct {
	config
}

// NewCountryClient returns a client for the Country from the given config.
func NewCountryClient(c config) *CountryClient {
	return &CountryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `country.Hooks(f(g(h())))`.
func (c *CountryClient) Use(hooks ...Hook) {
	c.hooks.Country = append(c.hooks.Country, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `country.Intercept(f(g(h())))`.
func (c *CountryClient) Intercept(interceptors ...Interceptor) {
	c.inters.Country = append(c.inters.Country, interceptors...)
}

// Create returns a builder for creating a Country entity.
func (c *CountryClient) Create() *CountryCreate {
	mutation := newCountryMutation(c.config, OpCreate)
	return &CountryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Country entities.
func (c *CountryClient) CreateBulk(builders ...*CountryCreate) *CountryCreateBulk {
	return &CountryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Country.
func (c *CountryClient) Update() *CountryUpdate {
	mutation := newCountryMutation(c.config, OpUpdate)
	return &CountryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CountryClient) UpdateOne(co *Country) *CountryUpdateOne {
	mutation := newCountryMutation(c.config, OpUpdateOne, withCountry(co))
	return &CountryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CountryClient) UpdateOneID(id int) *CountryUpdateOne {
	mutation := newCountryMutation(c.config, OpUpdateOne, withCountryID(id))
	return &CountryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Country.
func (c *CountryClient) Delete() *CountryDelete {
	mutation := newCountryMutation(c.config, OpDelete)
	return &CountryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CountryClient) DeleteOne(co *Country) *CountryDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CountryClient) DeleteOneID(id int) *CountryDeleteOne {
	builder := c.Delete().Where(country.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CountryDeleteOne{builder}
}

// Query returns a query builder for Country.
func (c *CountryClient) Query() *CountryQuery {
	return &CountryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCountry},
		inters: c.Interceptors(),
	}
}

// Get returns a Country entity by its id.
func (c *CountryClient) Get(ctx context.Context, id int) (*Country, error) {
	return c.Query().Where(country.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CountryClient) GetX(ctx context.Context, id int) *Country {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPlayers queries the players edge of a Country.
func (c *CountryClient) QueryPlayers(co *Country) *PlayerQuery {
	query := (&PlayerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(country.Table, country.FieldID, id),
			sqlgraph.To(player.Table, player.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, country.PlayersTable, country.PlayersColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLeagues queries the leagues edge of a Country.
func (c *CountryClient) QueryLeagues(co *Country) *LeagueQuery {
	query := (&LeagueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(country.Table, country.FieldID, id),
			sqlgraph.To(league.Table, league.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, country.LeaguesTable, country.LeaguesColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClubs queries the clubs edge of a Country.
func (c *CountryClient) QueryClubs(co *Country) *ClubQuery {
	query := (&ClubClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(country.Table, country.FieldID, id),
			sqlgraph.To(club.Table, club.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, country.ClubsTable, country.ClubsColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CountryClient) Hooks() []Hook {
	return c.hooks.Country
}

// Interceptors returns the client interceptors.
func (c *CountryClient) Interceptors() []Interceptor {
	return c.inters.Country
}

func (c *CountryClient) mutate(ctx context.Context, m *CountryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CountryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CountryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CountryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CountryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Country mutation op: %q", m.Op())
	}
}

// FixtureClient is a client for the Fixture schema.
type FixtureClient struct {
	config
}

// NewFixtureClient returns a client for the Fixture from the given config.
func NewFixtureClient(c config) *FixtureClient {
	return &FixtureClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `fixture.Hooks(f(g(h())))`.
func (c *FixtureClient) Use(hooks ...Hook) {
	c.hooks.Fixture = append(c.hooks.Fixture, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `fixture.Intercept(f(g(h())))`.
func (c *FixtureClient) Intercept(interceptors ...Interceptor) {
	c.inters.Fixture = append(c.inters.Fixture, interceptors...)
}

// Create returns a builder for creating a Fixture entity.
func (c *FixtureClient) Create() *FixtureCreate {
	mutation := newFixtureMutation(c.config, OpCreate)
	return &FixtureCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Fixture entities.
func (c *FixtureClient) CreateBulk(builders ...*FixtureCreate) *FixtureCreateBulk {
	return &FixtureCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Fixture.
func (c *FixtureClient) Update() *FixtureUpdate {
	mutation := newFixtureMutation(c.config, OpUpdate)
	return &FixtureUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FixtureClient) UpdateOne(f *Fixture) *FixtureUpdateOne {
	mutation := newFixtureMutation(c.config, OpUpdateOne, withFixture(f))
	return &FixtureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FixtureClient) UpdateOneID(id int) *FixtureUpdateOne {
	mutation := newFixtureMutation(c.config, OpUpdateOne, withFixtureID(id))
	return &FixtureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Fixture.
func (c *FixtureClient) Delete() *FixtureDelete {
	mutation := newFixtureMutation(c.config, OpDelete)
	return &FixtureDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FixtureClient) DeleteOne(f *Fixture) *FixtureDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FixtureClient) DeleteOneID(id int) *FixtureDeleteOne {
	builder := c.Delete().Where(fixture.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FixtureDeleteOne{builder}
}

// Query returns a query builder for Fixture.
func (c *FixtureClient) Query() *FixtureQuery {
	return &FixtureQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeFixture},
		inters: c.Interceptors(),
	}
}

// Get returns a Fixture entity by its id.
func (c *FixtureClient) Get(ctx context.Context, id int) (*Fixture, error) {
	return c.Query().Where(fixture.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FixtureClient) GetX(ctx context.Context, id int) *Fixture {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryHomeTeam queries the homeTeam edge of a Fixture.
func (c *FixtureClient) QueryHomeTeam(f *Fixture) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fixture.Table, fixture.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, fixture.HomeTeamTable, fixture.HomeTeamColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAwayTeam queries the awayTeam edge of a Fixture.
func (c *FixtureClient) QueryAwayTeam(f *Fixture) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fixture.Table, fixture.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, fixture.AwayTeamTable, fixture.AwayTeamColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySeason queries the season edge of a Fixture.
func (c *FixtureClient) QuerySeason(f *Fixture) *SeasonQuery {
	query := (&SeasonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(fixture.Table, fixture.FieldID, id),
			sqlgraph.To(season.Table, season.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, fixture.SeasonTable, fixture.SeasonColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FixtureClient) Hooks() []Hook {
	return c.hooks.Fixture
}

// Interceptors returns the client interceptors.
func (c *FixtureClient) Interceptors() []Interceptor {
	return c.inters.Fixture
}

func (c *FixtureClient) mutate(ctx context.Context, m *FixtureMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&FixtureCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&FixtureUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&FixtureUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&FixtureDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Fixture mutation op: %q", m.Op())
	}
}

// LeagueClient is a client for the League schema.
type LeagueClient struct {
	config
}

// NewLeagueClient returns a client for the League from the given config.
func NewLeagueClient(c config) *LeagueClient {
	return &LeagueClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `league.Hooks(f(g(h())))`.
func (c *LeagueClient) Use(hooks ...Hook) {
	c.hooks.League = append(c.hooks.League, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `league.Intercept(f(g(h())))`.
func (c *LeagueClient) Intercept(interceptors ...Interceptor) {
	c.inters.League = append(c.inters.League, interceptors...)
}

// Create returns a builder for creating a League entity.
func (c *LeagueClient) Create() *LeagueCreate {
	mutation := newLeagueMutation(c.config, OpCreate)
	return &LeagueCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of League entities.
func (c *LeagueClient) CreateBulk(builders ...*LeagueCreate) *LeagueCreateBulk {
	return &LeagueCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for League.
func (c *LeagueClient) Update() *LeagueUpdate {
	mutation := newLeagueMutation(c.config, OpUpdate)
	return &LeagueUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LeagueClient) UpdateOne(l *League) *LeagueUpdateOne {
	mutation := newLeagueMutation(c.config, OpUpdateOne, withLeague(l))
	return &LeagueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LeagueClient) UpdateOneID(id int) *LeagueUpdateOne {
	mutation := newLeagueMutation(c.config, OpUpdateOne, withLeagueID(id))
	return &LeagueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for League.
func (c *LeagueClient) Delete() *LeagueDelete {
	mutation := newLeagueMutation(c.config, OpDelete)
	return &LeagueDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LeagueClient) DeleteOne(l *League) *LeagueDeleteOne {
	return c.DeleteOneID(l.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LeagueClient) DeleteOneID(id int) *LeagueDeleteOne {
	builder := c.Delete().Where(league.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LeagueDeleteOne{builder}
}

// Query returns a query builder for League.
func (c *LeagueClient) Query() *LeagueQuery {
	return &LeagueQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLeague},
		inters: c.Interceptors(),
	}
}

// Get returns a League entity by its id.
func (c *LeagueClient) Get(ctx context.Context, id int) (*League, error) {
	return c.Query().Where(league.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LeagueClient) GetX(ctx context.Context, id int) *League {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCountry queries the country edge of a League.
func (c *LeagueClient) QueryCountry(l *League) *CountryQuery {
	query := (&CountryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(league.Table, league.FieldID, id),
			sqlgraph.To(country.Table, country.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, league.CountryTable, league.CountryColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySeason queries the season edge of a League.
func (c *LeagueClient) QuerySeason(l *League) *SeasonQuery {
	query := (&SeasonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(league.Table, league.FieldID, id),
			sqlgraph.To(season.Table, season.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, league.SeasonTable, league.SeasonColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LeagueClient) Hooks() []Hook {
	return c.hooks.League
}

// Interceptors returns the client interceptors.
func (c *LeagueClient) Interceptors() []Interceptor {
	return c.inters.League
}

func (c *LeagueClient) mutate(ctx context.Context, m *LeagueMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LeagueCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LeagueUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LeagueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LeagueDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown League mutation op: %q", m.Op())
	}
}

// PlayerClient is a client for the Player schema.
type PlayerClient struct {
	config
}

// NewPlayerClient returns a client for the Player from the given config.
func NewPlayerClient(c config) *PlayerClient {
	return &PlayerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `player.Hooks(f(g(h())))`.
func (c *PlayerClient) Use(hooks ...Hook) {
	c.hooks.Player = append(c.hooks.Player, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `player.Intercept(f(g(h())))`.
func (c *PlayerClient) Intercept(interceptors ...Interceptor) {
	c.inters.Player = append(c.inters.Player, interceptors...)
}

// Create returns a builder for creating a Player entity.
func (c *PlayerClient) Create() *PlayerCreate {
	mutation := newPlayerMutation(c.config, OpCreate)
	return &PlayerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Player entities.
func (c *PlayerClient) CreateBulk(builders ...*PlayerCreate) *PlayerCreateBulk {
	return &PlayerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Player.
func (c *PlayerClient) Update() *PlayerUpdate {
	mutation := newPlayerMutation(c.config, OpUpdate)
	return &PlayerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PlayerClient) UpdateOne(pl *Player) *PlayerUpdateOne {
	mutation := newPlayerMutation(c.config, OpUpdateOne, withPlayer(pl))
	return &PlayerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PlayerClient) UpdateOneID(id int) *PlayerUpdateOne {
	mutation := newPlayerMutation(c.config, OpUpdateOne, withPlayerID(id))
	return &PlayerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Player.
func (c *PlayerClient) Delete() *PlayerDelete {
	mutation := newPlayerMutation(c.config, OpDelete)
	return &PlayerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PlayerClient) DeleteOne(pl *Player) *PlayerDeleteOne {
	return c.DeleteOneID(pl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PlayerClient) DeleteOneID(id int) *PlayerDeleteOne {
	builder := c.Delete().Where(player.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PlayerDeleteOne{builder}
}

// Query returns a query builder for Player.
func (c *PlayerClient) Query() *PlayerQuery {
	return &PlayerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePlayer},
		inters: c.Interceptors(),
	}
}

// Get returns a Player entity by its id.
func (c *PlayerClient) Get(ctx context.Context, id int) (*Player, error) {
	return c.Query().Where(player.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PlayerClient) GetX(ctx context.Context, id int) *Player {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBirth queries the birth edge of a Player.
func (c *PlayerClient) QueryBirth(pl *Player) *BirthQuery {
	query := (&BirthClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(player.Table, player.FieldID, id),
			sqlgraph.To(birth.Table, birth.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, player.BirthTable, player.BirthColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PlayerClient) Hooks() []Hook {
	return c.hooks.Player
}

// Interceptors returns the client interceptors.
func (c *PlayerClient) Interceptors() []Interceptor {
	return c.inters.Player
}

func (c *PlayerClient) mutate(ctx context.Context, m *PlayerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PlayerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PlayerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PlayerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PlayerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Player mutation op: %q", m.Op())
	}
}

// PlayerSeasonClient is a client for the PlayerSeason schema.
type PlayerSeasonClient struct {
	config
}

// NewPlayerSeasonClient returns a client for the PlayerSeason from the given config.
func NewPlayerSeasonClient(c config) *PlayerSeasonClient {
	return &PlayerSeasonClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `playerseason.Hooks(f(g(h())))`.
func (c *PlayerSeasonClient) Use(hooks ...Hook) {
	c.hooks.PlayerSeason = append(c.hooks.PlayerSeason, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `playerseason.Intercept(f(g(h())))`.
func (c *PlayerSeasonClient) Intercept(interceptors ...Interceptor) {
	c.inters.PlayerSeason = append(c.inters.PlayerSeason, interceptors...)
}

// Create returns a builder for creating a PlayerSeason entity.
func (c *PlayerSeasonClient) Create() *PlayerSeasonCreate {
	mutation := newPlayerSeasonMutation(c.config, OpCreate)
	return &PlayerSeasonCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PlayerSeason entities.
func (c *PlayerSeasonClient) CreateBulk(builders ...*PlayerSeasonCreate) *PlayerSeasonCreateBulk {
	return &PlayerSeasonCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PlayerSeason.
func (c *PlayerSeasonClient) Update() *PlayerSeasonUpdate {
	mutation := newPlayerSeasonMutation(c.config, OpUpdate)
	return &PlayerSeasonUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PlayerSeasonClient) UpdateOne(ps *PlayerSeason) *PlayerSeasonUpdateOne {
	mutation := newPlayerSeasonMutation(c.config, OpUpdateOne, withPlayerSeason(ps))
	return &PlayerSeasonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PlayerSeasonClient) UpdateOneID(id int) *PlayerSeasonUpdateOne {
	mutation := newPlayerSeasonMutation(c.config, OpUpdateOne, withPlayerSeasonID(id))
	return &PlayerSeasonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PlayerSeason.
func (c *PlayerSeasonClient) Delete() *PlayerSeasonDelete {
	mutation := newPlayerSeasonMutation(c.config, OpDelete)
	return &PlayerSeasonDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PlayerSeasonClient) DeleteOne(ps *PlayerSeason) *PlayerSeasonDeleteOne {
	return c.DeleteOneID(ps.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PlayerSeasonClient) DeleteOneID(id int) *PlayerSeasonDeleteOne {
	builder := c.Delete().Where(playerseason.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PlayerSeasonDeleteOne{builder}
}

// Query returns a query builder for PlayerSeason.
func (c *PlayerSeasonClient) Query() *PlayerSeasonQuery {
	return &PlayerSeasonQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePlayerSeason},
		inters: c.Interceptors(),
	}
}

// Get returns a PlayerSeason entity by its id.
func (c *PlayerSeasonClient) Get(ctx context.Context, id int) (*PlayerSeason, error) {
	return c.Query().Where(playerseason.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PlayerSeasonClient) GetX(ctx context.Context, id int) *PlayerSeason {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryClub queries the club edge of a PlayerSeason.
func (c *PlayerSeasonClient) QueryClub(ps *PlayerSeason) *ClubQuery {
	query := (&ClubClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(playerseason.Table, playerseason.FieldID, id),
			sqlgraph.To(club.Table, club.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, playerseason.ClubTable, playerseason.ClubPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PlayerSeasonClient) Hooks() []Hook {
	return c.hooks.PlayerSeason
}

// Interceptors returns the client interceptors.
func (c *PlayerSeasonClient) Interceptors() []Interceptor {
	return c.inters.PlayerSeason
}

func (c *PlayerSeasonClient) mutate(ctx context.Context, m *PlayerSeasonMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PlayerSeasonCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PlayerSeasonUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PlayerSeasonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PlayerSeasonDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PlayerSeason mutation op: %q", m.Op())
	}
}

// SeasonClient is a client for the Season schema.
type SeasonClient struct {
	config
}

// NewSeasonClient returns a client for the Season from the given config.
func NewSeasonClient(c config) *SeasonClient {
	return &SeasonClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `season.Hooks(f(g(h())))`.
func (c *SeasonClient) Use(hooks ...Hook) {
	c.hooks.Season = append(c.hooks.Season, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `season.Intercept(f(g(h())))`.
func (c *SeasonClient) Intercept(interceptors ...Interceptor) {
	c.inters.Season = append(c.inters.Season, interceptors...)
}

// Create returns a builder for creating a Season entity.
func (c *SeasonClient) Create() *SeasonCreate {
	mutation := newSeasonMutation(c.config, OpCreate)
	return &SeasonCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Season entities.
func (c *SeasonClient) CreateBulk(builders ...*SeasonCreate) *SeasonCreateBulk {
	return &SeasonCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Season.
func (c *SeasonClient) Update() *SeasonUpdate {
	mutation := newSeasonMutation(c.config, OpUpdate)
	return &SeasonUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SeasonClient) UpdateOne(s *Season) *SeasonUpdateOne {
	mutation := newSeasonMutation(c.config, OpUpdateOne, withSeason(s))
	return &SeasonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SeasonClient) UpdateOneID(id int) *SeasonUpdateOne {
	mutation := newSeasonMutation(c.config, OpUpdateOne, withSeasonID(id))
	return &SeasonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Season.
func (c *SeasonClient) Delete() *SeasonDelete {
	mutation := newSeasonMutation(c.config, OpDelete)
	return &SeasonDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SeasonClient) DeleteOne(s *Season) *SeasonDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SeasonClient) DeleteOneID(id int) *SeasonDeleteOne {
	builder := c.Delete().Where(season.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SeasonDeleteOne{builder}
}

// Query returns a query builder for Season.
func (c *SeasonClient) Query() *SeasonQuery {
	return &SeasonQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSeason},
		inters: c.Interceptors(),
	}
}

// Get returns a Season entity by its id.
func (c *SeasonClient) Get(ctx context.Context, id int) (*Season, error) {
	return c.Query().Where(season.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SeasonClient) GetX(ctx context.Context, id int) *Season {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryLeague queries the league edge of a Season.
func (c *SeasonClient) QueryLeague(s *Season) *LeagueQuery {
	query := (&LeagueClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(season.Table, season.FieldID, id),
			sqlgraph.To(league.Table, league.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, season.LeagueTable, season.LeagueColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFixtures queries the fixtures edge of a Season.
func (c *SeasonClient) QueryFixtures(s *Season) *FixtureQuery {
	query := (&FixtureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(season.Table, season.FieldID, id),
			sqlgraph.To(fixture.Table, fixture.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, season.FixturesTable, season.FixturesColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStandings queries the standings edge of a Season.
func (c *SeasonClient) QueryStandings(s *Season) *StandingsQuery {
	query := (&StandingsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(season.Table, season.FieldID, id),
			sqlgraph.To(standings.Table, standings.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, season.StandingsTable, season.StandingsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeams queries the teams edge of a Season.
func (c *SeasonClient) QueryTeams(s *Season) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(season.Table, season.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, season.TeamsTable, season.TeamsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlayerSeasons queries the playerSeasons edge of a Season.
func (c *SeasonClient) QueryPlayerSeasons(s *Season) *PlayerSeasonQuery {
	query := (&PlayerSeasonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(season.Table, season.FieldID, id),
			sqlgraph.To(playerseason.Table, playerseason.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, season.PlayerSeasonsTable, season.PlayerSeasonsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SeasonClient) Hooks() []Hook {
	return c.hooks.Season
}

// Interceptors returns the client interceptors.
func (c *SeasonClient) Interceptors() []Interceptor {
	return c.inters.Season
}

func (c *SeasonClient) mutate(ctx context.Context, m *SeasonMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SeasonCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SeasonUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SeasonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SeasonDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Season mutation op: %q", m.Op())
	}
}

// StandingsClient is a client for the Standings schema.
type StandingsClient struct {
	config
}

// NewStandingsClient returns a client for the Standings from the given config.
func NewStandingsClient(c config) *StandingsClient {
	return &StandingsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `standings.Hooks(f(g(h())))`.
func (c *StandingsClient) Use(hooks ...Hook) {
	c.hooks.Standings = append(c.hooks.Standings, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `standings.Intercept(f(g(h())))`.
func (c *StandingsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Standings = append(c.inters.Standings, interceptors...)
}

// Create returns a builder for creating a Standings entity.
func (c *StandingsClient) Create() *StandingsCreate {
	mutation := newStandingsMutation(c.config, OpCreate)
	return &StandingsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Standings entities.
func (c *StandingsClient) CreateBulk(builders ...*StandingsCreate) *StandingsCreateBulk {
	return &StandingsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Standings.
func (c *StandingsClient) Update() *StandingsUpdate {
	mutation := newStandingsMutation(c.config, OpUpdate)
	return &StandingsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StandingsClient) UpdateOne(s *Standings) *StandingsUpdateOne {
	mutation := newStandingsMutation(c.config, OpUpdateOne, withStandings(s))
	return &StandingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StandingsClient) UpdateOneID(id int) *StandingsUpdateOne {
	mutation := newStandingsMutation(c.config, OpUpdateOne, withStandingsID(id))
	return &StandingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Standings.
func (c *StandingsClient) Delete() *StandingsDelete {
	mutation := newStandingsMutation(c.config, OpDelete)
	return &StandingsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StandingsClient) DeleteOne(s *Standings) *StandingsDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StandingsClient) DeleteOneID(id int) *StandingsDeleteOne {
	builder := c.Delete().Where(standings.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StandingsDeleteOne{builder}
}

// Query returns a query builder for Standings.
func (c *StandingsClient) Query() *StandingsQuery {
	return &StandingsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStandings},
		inters: c.Interceptors(),
	}
}

// Get returns a Standings entity by its id.
func (c *StandingsClient) Get(ctx context.Context, id int) (*Standings, error) {
	return c.Query().Where(standings.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StandingsClient) GetX(ctx context.Context, id int) *Standings {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTeam queries the team edge of a Standings.
func (c *StandingsClient) QueryTeam(s *Standings) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(standings.Table, standings.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, standings.TeamTable, standings.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySeason queries the season edge of a Standings.
func (c *StandingsClient) QuerySeason(s *Standings) *SeasonQuery {
	query := (&SeasonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(standings.Table, standings.FieldID, id),
			sqlgraph.To(season.Table, season.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, standings.SeasonTable, standings.SeasonColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StandingsClient) Hooks() []Hook {
	return c.hooks.Standings
}

// Interceptors returns the client interceptors.
func (c *StandingsClient) Interceptors() []Interceptor {
	return c.inters.Standings
}

func (c *StandingsClient) mutate(ctx context.Context, m *StandingsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StandingsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StandingsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StandingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StandingsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Standings mutation op: %q", m.Op())
	}
}

// TSBiggestClient is a client for the TSBiggest schema.
type TSBiggestClient struct {
	config
}

// NewTSBiggestClient returns a client for the TSBiggest from the given config.
func NewTSBiggestClient(c config) *TSBiggestClient {
	return &TSBiggestClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tsbiggest.Hooks(f(g(h())))`.
func (c *TSBiggestClient) Use(hooks ...Hook) {
	c.hooks.TSBiggest = append(c.hooks.TSBiggest, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tsbiggest.Intercept(f(g(h())))`.
func (c *TSBiggestClient) Intercept(interceptors ...Interceptor) {
	c.inters.TSBiggest = append(c.inters.TSBiggest, interceptors...)
}

// Create returns a builder for creating a TSBiggest entity.
func (c *TSBiggestClient) Create() *TSBiggestCreate {
	mutation := newTSBiggestMutation(c.config, OpCreate)
	return &TSBiggestCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TSBiggest entities.
func (c *TSBiggestClient) CreateBulk(builders ...*TSBiggestCreate) *TSBiggestCreateBulk {
	return &TSBiggestCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TSBiggest.
func (c *TSBiggestClient) Update() *TSBiggestUpdate {
	mutation := newTSBiggestMutation(c.config, OpUpdate)
	return &TSBiggestUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TSBiggestClient) UpdateOne(tb *TSBiggest) *TSBiggestUpdateOne {
	mutation := newTSBiggestMutation(c.config, OpUpdateOne, withTSBiggest(tb))
	return &TSBiggestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TSBiggestClient) UpdateOneID(id int) *TSBiggestUpdateOne {
	mutation := newTSBiggestMutation(c.config, OpUpdateOne, withTSBiggestID(id))
	return &TSBiggestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TSBiggest.
func (c *TSBiggestClient) Delete() *TSBiggestDelete {
	mutation := newTSBiggestMutation(c.config, OpDelete)
	return &TSBiggestDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TSBiggestClient) DeleteOne(tb *TSBiggest) *TSBiggestDeleteOne {
	return c.DeleteOneID(tb.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TSBiggestClient) DeleteOneID(id int) *TSBiggestDeleteOne {
	builder := c.Delete().Where(tsbiggest.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TSBiggestDeleteOne{builder}
}

// Query returns a query builder for TSBiggest.
func (c *TSBiggestClient) Query() *TSBiggestQuery {
	return &TSBiggestQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTSBiggest},
		inters: c.Interceptors(),
	}
}

// Get returns a TSBiggest entity by its id.
func (c *TSBiggestClient) Get(ctx context.Context, id int) (*TSBiggest, error) {
	return c.Query().Where(tsbiggest.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TSBiggestClient) GetX(ctx context.Context, id int) *TSBiggest {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTeam queries the team edge of a TSBiggest.
func (c *TSBiggestClient) QueryTeam(tb *TSBiggest) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tsbiggest.Table, tsbiggest.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, tsbiggest.TeamTable, tsbiggest.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(tb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TSBiggestClient) Hooks() []Hook {
	return c.hooks.TSBiggest
}

// Interceptors returns the client interceptors.
func (c *TSBiggestClient) Interceptors() []Interceptor {
	return c.inters.TSBiggest
}

func (c *TSBiggestClient) mutate(ctx context.Context, m *TSBiggestMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TSBiggestCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TSBiggestUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TSBiggestUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TSBiggestDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TSBiggest mutation op: %q", m.Op())
	}
}

// TSCardsClient is a client for the TSCards schema.
type TSCardsClient struct {
	config
}

// NewTSCardsClient returns a client for the TSCards from the given config.
func NewTSCardsClient(c config) *TSCardsClient {
	return &TSCardsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tscards.Hooks(f(g(h())))`.
func (c *TSCardsClient) Use(hooks ...Hook) {
	c.hooks.TSCards = append(c.hooks.TSCards, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tscards.Intercept(f(g(h())))`.
func (c *TSCardsClient) Intercept(interceptors ...Interceptor) {
	c.inters.TSCards = append(c.inters.TSCards, interceptors...)
}

// Create returns a builder for creating a TSCards entity.
func (c *TSCardsClient) Create() *TSCardsCreate {
	mutation := newTSCardsMutation(c.config, OpCreate)
	return &TSCardsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TSCards entities.
func (c *TSCardsClient) CreateBulk(builders ...*TSCardsCreate) *TSCardsCreateBulk {
	return &TSCardsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TSCards.
func (c *TSCardsClient) Update() *TSCardsUpdate {
	mutation := newTSCardsMutation(c.config, OpUpdate)
	return &TSCardsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TSCardsClient) UpdateOne(tc *TSCards) *TSCardsUpdateOne {
	mutation := newTSCardsMutation(c.config, OpUpdateOne, withTSCards(tc))
	return &TSCardsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TSCardsClient) UpdateOneID(id int) *TSCardsUpdateOne {
	mutation := newTSCardsMutation(c.config, OpUpdateOne, withTSCardsID(id))
	return &TSCardsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TSCards.
func (c *TSCardsClient) Delete() *TSCardsDelete {
	mutation := newTSCardsMutation(c.config, OpDelete)
	return &TSCardsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TSCardsClient) DeleteOne(tc *TSCards) *TSCardsDeleteOne {
	return c.DeleteOneID(tc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TSCardsClient) DeleteOneID(id int) *TSCardsDeleteOne {
	builder := c.Delete().Where(tscards.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TSCardsDeleteOne{builder}
}

// Query returns a query builder for TSCards.
func (c *TSCardsClient) Query() *TSCardsQuery {
	return &TSCardsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTSCards},
		inters: c.Interceptors(),
	}
}

// Get returns a TSCards entity by its id.
func (c *TSCardsClient) Get(ctx context.Context, id int) (*TSCards, error) {
	return c.Query().Where(tscards.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TSCardsClient) GetX(ctx context.Context, id int) *TSCards {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTeam queries the team edge of a TSCards.
func (c *TSCardsClient) QueryTeam(tc *TSCards) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tscards.Table, tscards.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, tscards.TeamTable, tscards.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(tc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TSCardsClient) Hooks() []Hook {
	return c.hooks.TSCards
}

// Interceptors returns the client interceptors.
func (c *TSCardsClient) Interceptors() []Interceptor {
	return c.inters.TSCards
}

func (c *TSCardsClient) mutate(ctx context.Context, m *TSCardsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TSCardsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TSCardsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TSCardsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TSCardsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TSCards mutation op: %q", m.Op())
	}
}

// TSCleanSheetClient is a client for the TSCleanSheet schema.
type TSCleanSheetClient struct {
	config
}

// NewTSCleanSheetClient returns a client for the TSCleanSheet from the given config.
func NewTSCleanSheetClient(c config) *TSCleanSheetClient {
	return &TSCleanSheetClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tscleansheet.Hooks(f(g(h())))`.
func (c *TSCleanSheetClient) Use(hooks ...Hook) {
	c.hooks.TSCleanSheet = append(c.hooks.TSCleanSheet, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tscleansheet.Intercept(f(g(h())))`.
func (c *TSCleanSheetClient) Intercept(interceptors ...Interceptor) {
	c.inters.TSCleanSheet = append(c.inters.TSCleanSheet, interceptors...)
}

// Create returns a builder for creating a TSCleanSheet entity.
func (c *TSCleanSheetClient) Create() *TSCleanSheetCreate {
	mutation := newTSCleanSheetMutation(c.config, OpCreate)
	return &TSCleanSheetCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TSCleanSheet entities.
func (c *TSCleanSheetClient) CreateBulk(builders ...*TSCleanSheetCreate) *TSCleanSheetCreateBulk {
	return &TSCleanSheetCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TSCleanSheet.
func (c *TSCleanSheetClient) Update() *TSCleanSheetUpdate {
	mutation := newTSCleanSheetMutation(c.config, OpUpdate)
	return &TSCleanSheetUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TSCleanSheetClient) UpdateOne(tcs *TSCleanSheet) *TSCleanSheetUpdateOne {
	mutation := newTSCleanSheetMutation(c.config, OpUpdateOne, withTSCleanSheet(tcs))
	return &TSCleanSheetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TSCleanSheetClient) UpdateOneID(id int) *TSCleanSheetUpdateOne {
	mutation := newTSCleanSheetMutation(c.config, OpUpdateOne, withTSCleanSheetID(id))
	return &TSCleanSheetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TSCleanSheet.
func (c *TSCleanSheetClient) Delete() *TSCleanSheetDelete {
	mutation := newTSCleanSheetMutation(c.config, OpDelete)
	return &TSCleanSheetDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TSCleanSheetClient) DeleteOne(tcs *TSCleanSheet) *TSCleanSheetDeleteOne {
	return c.DeleteOneID(tcs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TSCleanSheetClient) DeleteOneID(id int) *TSCleanSheetDeleteOne {
	builder := c.Delete().Where(tscleansheet.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TSCleanSheetDeleteOne{builder}
}

// Query returns a query builder for TSCleanSheet.
func (c *TSCleanSheetClient) Query() *TSCleanSheetQuery {
	return &TSCleanSheetQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTSCleanSheet},
		inters: c.Interceptors(),
	}
}

// Get returns a TSCleanSheet entity by its id.
func (c *TSCleanSheetClient) Get(ctx context.Context, id int) (*TSCleanSheet, error) {
	return c.Query().Where(tscleansheet.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TSCleanSheetClient) GetX(ctx context.Context, id int) *TSCleanSheet {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTeam queries the team edge of a TSCleanSheet.
func (c *TSCleanSheetClient) QueryTeam(tcs *TSCleanSheet) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tcs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tscleansheet.Table, tscleansheet.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, tscleansheet.TeamTable, tscleansheet.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(tcs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TSCleanSheetClient) Hooks() []Hook {
	return c.hooks.TSCleanSheet
}

// Interceptors returns the client interceptors.
func (c *TSCleanSheetClient) Interceptors() []Interceptor {
	return c.inters.TSCleanSheet
}

func (c *TSCleanSheetClient) mutate(ctx context.Context, m *TSCleanSheetMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TSCleanSheetCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TSCleanSheetUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TSCleanSheetUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TSCleanSheetDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TSCleanSheet mutation op: %q", m.Op())
	}
}

// TSFailedToScoreClient is a client for the TSFailedToScore schema.
type TSFailedToScoreClient struct {
	config
}

// NewTSFailedToScoreClient returns a client for the TSFailedToScore from the given config.
func NewTSFailedToScoreClient(c config) *TSFailedToScoreClient {
	return &TSFailedToScoreClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tsfailedtoscore.Hooks(f(g(h())))`.
func (c *TSFailedToScoreClient) Use(hooks ...Hook) {
	c.hooks.TSFailedToScore = append(c.hooks.TSFailedToScore, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tsfailedtoscore.Intercept(f(g(h())))`.
func (c *TSFailedToScoreClient) Intercept(interceptors ...Interceptor) {
	c.inters.TSFailedToScore = append(c.inters.TSFailedToScore, interceptors...)
}

// Create returns a builder for creating a TSFailedToScore entity.
func (c *TSFailedToScoreClient) Create() *TSFailedToScoreCreate {
	mutation := newTSFailedToScoreMutation(c.config, OpCreate)
	return &TSFailedToScoreCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TSFailedToScore entities.
func (c *TSFailedToScoreClient) CreateBulk(builders ...*TSFailedToScoreCreate) *TSFailedToScoreCreateBulk {
	return &TSFailedToScoreCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TSFailedToScore.
func (c *TSFailedToScoreClient) Update() *TSFailedToScoreUpdate {
	mutation := newTSFailedToScoreMutation(c.config, OpUpdate)
	return &TSFailedToScoreUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TSFailedToScoreClient) UpdateOne(tfts *TSFailedToScore) *TSFailedToScoreUpdateOne {
	mutation := newTSFailedToScoreMutation(c.config, OpUpdateOne, withTSFailedToScore(tfts))
	return &TSFailedToScoreUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TSFailedToScoreClient) UpdateOneID(id int) *TSFailedToScoreUpdateOne {
	mutation := newTSFailedToScoreMutation(c.config, OpUpdateOne, withTSFailedToScoreID(id))
	return &TSFailedToScoreUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TSFailedToScore.
func (c *TSFailedToScoreClient) Delete() *TSFailedToScoreDelete {
	mutation := newTSFailedToScoreMutation(c.config, OpDelete)
	return &TSFailedToScoreDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TSFailedToScoreClient) DeleteOne(tfts *TSFailedToScore) *TSFailedToScoreDeleteOne {
	return c.DeleteOneID(tfts.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TSFailedToScoreClient) DeleteOneID(id int) *TSFailedToScoreDeleteOne {
	builder := c.Delete().Where(tsfailedtoscore.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TSFailedToScoreDeleteOne{builder}
}

// Query returns a query builder for TSFailedToScore.
func (c *TSFailedToScoreClient) Query() *TSFailedToScoreQuery {
	return &TSFailedToScoreQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTSFailedToScore},
		inters: c.Interceptors(),
	}
}

// Get returns a TSFailedToScore entity by its id.
func (c *TSFailedToScoreClient) Get(ctx context.Context, id int) (*TSFailedToScore, error) {
	return c.Query().Where(tsfailedtoscore.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TSFailedToScoreClient) GetX(ctx context.Context, id int) *TSFailedToScore {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTeam queries the team edge of a TSFailedToScore.
func (c *TSFailedToScoreClient) QueryTeam(tfts *TSFailedToScore) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tfts.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tsfailedtoscore.Table, tsfailedtoscore.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, tsfailedtoscore.TeamTable, tsfailedtoscore.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(tfts.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TSFailedToScoreClient) Hooks() []Hook {
	return c.hooks.TSFailedToScore
}

// Interceptors returns the client interceptors.
func (c *TSFailedToScoreClient) Interceptors() []Interceptor {
	return c.inters.TSFailedToScore
}

func (c *TSFailedToScoreClient) mutate(ctx context.Context, m *TSFailedToScoreMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TSFailedToScoreCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TSFailedToScoreUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TSFailedToScoreUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TSFailedToScoreDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TSFailedToScore mutation op: %q", m.Op())
	}
}

// TSFixturesClient is a client for the TSFixtures schema.
type TSFixturesClient struct {
	config
}

// NewTSFixturesClient returns a client for the TSFixtures from the given config.
func NewTSFixturesClient(c config) *TSFixturesClient {
	return &TSFixturesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tsfixtures.Hooks(f(g(h())))`.
func (c *TSFixturesClient) Use(hooks ...Hook) {
	c.hooks.TSFixtures = append(c.hooks.TSFixtures, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tsfixtures.Intercept(f(g(h())))`.
func (c *TSFixturesClient) Intercept(interceptors ...Interceptor) {
	c.inters.TSFixtures = append(c.inters.TSFixtures, interceptors...)
}

// Create returns a builder for creating a TSFixtures entity.
func (c *TSFixturesClient) Create() *TSFixturesCreate {
	mutation := newTSFixturesMutation(c.config, OpCreate)
	return &TSFixturesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TSFixtures entities.
func (c *TSFixturesClient) CreateBulk(builders ...*TSFixturesCreate) *TSFixturesCreateBulk {
	return &TSFixturesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TSFixtures.
func (c *TSFixturesClient) Update() *TSFixturesUpdate {
	mutation := newTSFixturesMutation(c.config, OpUpdate)
	return &TSFixturesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TSFixturesClient) UpdateOne(tf *TSFixtures) *TSFixturesUpdateOne {
	mutation := newTSFixturesMutation(c.config, OpUpdateOne, withTSFixtures(tf))
	return &TSFixturesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TSFixturesClient) UpdateOneID(id int) *TSFixturesUpdateOne {
	mutation := newTSFixturesMutation(c.config, OpUpdateOne, withTSFixturesID(id))
	return &TSFixturesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TSFixtures.
func (c *TSFixturesClient) Delete() *TSFixturesDelete {
	mutation := newTSFixturesMutation(c.config, OpDelete)
	return &TSFixturesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TSFixturesClient) DeleteOne(tf *TSFixtures) *TSFixturesDeleteOne {
	return c.DeleteOneID(tf.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TSFixturesClient) DeleteOneID(id int) *TSFixturesDeleteOne {
	builder := c.Delete().Where(tsfixtures.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TSFixturesDeleteOne{builder}
}

// Query returns a query builder for TSFixtures.
func (c *TSFixturesClient) Query() *TSFixturesQuery {
	return &TSFixturesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTSFixtures},
		inters: c.Interceptors(),
	}
}

// Get returns a TSFixtures entity by its id.
func (c *TSFixturesClient) Get(ctx context.Context, id int) (*TSFixtures, error) {
	return c.Query().Where(tsfixtures.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TSFixturesClient) GetX(ctx context.Context, id int) *TSFixtures {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTeam queries the team edge of a TSFixtures.
func (c *TSFixturesClient) QueryTeam(tf *TSFixtures) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tf.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tsfixtures.Table, tsfixtures.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, tsfixtures.TeamTable, tsfixtures.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(tf.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TSFixturesClient) Hooks() []Hook {
	return c.hooks.TSFixtures
}

// Interceptors returns the client interceptors.
func (c *TSFixturesClient) Interceptors() []Interceptor {
	return c.inters.TSFixtures
}

func (c *TSFixturesClient) mutate(ctx context.Context, m *TSFixturesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TSFixturesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TSFixturesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TSFixturesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TSFixturesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TSFixtures mutation op: %q", m.Op())
	}
}

// TSGoalsClient is a client for the TSGoals schema.
type TSGoalsClient struct {
	config
}

// NewTSGoalsClient returns a client for the TSGoals from the given config.
func NewTSGoalsClient(c config) *TSGoalsClient {
	return &TSGoalsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tsgoals.Hooks(f(g(h())))`.
func (c *TSGoalsClient) Use(hooks ...Hook) {
	c.hooks.TSGoals = append(c.hooks.TSGoals, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tsgoals.Intercept(f(g(h())))`.
func (c *TSGoalsClient) Intercept(interceptors ...Interceptor) {
	c.inters.TSGoals = append(c.inters.TSGoals, interceptors...)
}

// Create returns a builder for creating a TSGoals entity.
func (c *TSGoalsClient) Create() *TSGoalsCreate {
	mutation := newTSGoalsMutation(c.config, OpCreate)
	return &TSGoalsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TSGoals entities.
func (c *TSGoalsClient) CreateBulk(builders ...*TSGoalsCreate) *TSGoalsCreateBulk {
	return &TSGoalsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TSGoals.
func (c *TSGoalsClient) Update() *TSGoalsUpdate {
	mutation := newTSGoalsMutation(c.config, OpUpdate)
	return &TSGoalsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TSGoalsClient) UpdateOne(tg *TSGoals) *TSGoalsUpdateOne {
	mutation := newTSGoalsMutation(c.config, OpUpdateOne, withTSGoals(tg))
	return &TSGoalsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TSGoalsClient) UpdateOneID(id int) *TSGoalsUpdateOne {
	mutation := newTSGoalsMutation(c.config, OpUpdateOne, withTSGoalsID(id))
	return &TSGoalsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TSGoals.
func (c *TSGoalsClient) Delete() *TSGoalsDelete {
	mutation := newTSGoalsMutation(c.config, OpDelete)
	return &TSGoalsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TSGoalsClient) DeleteOne(tg *TSGoals) *TSGoalsDeleteOne {
	return c.DeleteOneID(tg.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TSGoalsClient) DeleteOneID(id int) *TSGoalsDeleteOne {
	builder := c.Delete().Where(tsgoals.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TSGoalsDeleteOne{builder}
}

// Query returns a query builder for TSGoals.
func (c *TSGoalsClient) Query() *TSGoalsQuery {
	return &TSGoalsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTSGoals},
		inters: c.Interceptors(),
	}
}

// Get returns a TSGoals entity by its id.
func (c *TSGoalsClient) Get(ctx context.Context, id int) (*TSGoals, error) {
	return c.Query().Where(tsgoals.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TSGoalsClient) GetX(ctx context.Context, id int) *TSGoals {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTeam queries the team edge of a TSGoals.
func (c *TSGoalsClient) QueryTeam(tg *TSGoals) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tg.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tsgoals.Table, tsgoals.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, tsgoals.TeamTable, tsgoals.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(tg.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TSGoalsClient) Hooks() []Hook {
	return c.hooks.TSGoals
}

// Interceptors returns the client interceptors.
func (c *TSGoalsClient) Interceptors() []Interceptor {
	return c.inters.TSGoals
}

func (c *TSGoalsClient) mutate(ctx context.Context, m *TSGoalsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TSGoalsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TSGoalsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TSGoalsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TSGoalsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TSGoals mutation op: %q", m.Op())
	}
}

// TSLineupsClient is a client for the TSLineups schema.
type TSLineupsClient struct {
	config
}

// NewTSLineupsClient returns a client for the TSLineups from the given config.
func NewTSLineupsClient(c config) *TSLineupsClient {
	return &TSLineupsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tslineups.Hooks(f(g(h())))`.
func (c *TSLineupsClient) Use(hooks ...Hook) {
	c.hooks.TSLineups = append(c.hooks.TSLineups, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tslineups.Intercept(f(g(h())))`.
func (c *TSLineupsClient) Intercept(interceptors ...Interceptor) {
	c.inters.TSLineups = append(c.inters.TSLineups, interceptors...)
}

// Create returns a builder for creating a TSLineups entity.
func (c *TSLineupsClient) Create() *TSLineupsCreate {
	mutation := newTSLineupsMutation(c.config, OpCreate)
	return &TSLineupsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TSLineups entities.
func (c *TSLineupsClient) CreateBulk(builders ...*TSLineupsCreate) *TSLineupsCreateBulk {
	return &TSLineupsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TSLineups.
func (c *TSLineupsClient) Update() *TSLineupsUpdate {
	mutation := newTSLineupsMutation(c.config, OpUpdate)
	return &TSLineupsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TSLineupsClient) UpdateOne(tl *TSLineups) *TSLineupsUpdateOne {
	mutation := newTSLineupsMutation(c.config, OpUpdateOne, withTSLineups(tl))
	return &TSLineupsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TSLineupsClient) UpdateOneID(id int) *TSLineupsUpdateOne {
	mutation := newTSLineupsMutation(c.config, OpUpdateOne, withTSLineupsID(id))
	return &TSLineupsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TSLineups.
func (c *TSLineupsClient) Delete() *TSLineupsDelete {
	mutation := newTSLineupsMutation(c.config, OpDelete)
	return &TSLineupsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TSLineupsClient) DeleteOne(tl *TSLineups) *TSLineupsDeleteOne {
	return c.DeleteOneID(tl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TSLineupsClient) DeleteOneID(id int) *TSLineupsDeleteOne {
	builder := c.Delete().Where(tslineups.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TSLineupsDeleteOne{builder}
}

// Query returns a query builder for TSLineups.
func (c *TSLineupsClient) Query() *TSLineupsQuery {
	return &TSLineupsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTSLineups},
		inters: c.Interceptors(),
	}
}

// Get returns a TSLineups entity by its id.
func (c *TSLineupsClient) Get(ctx context.Context, id int) (*TSLineups, error) {
	return c.Query().Where(tslineups.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TSLineupsClient) GetX(ctx context.Context, id int) *TSLineups {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTeam queries the team edge of a TSLineups.
func (c *TSLineupsClient) QueryTeam(tl *TSLineups) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tslineups.Table, tslineups.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tslineups.TeamTable, tslineups.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(tl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TSLineupsClient) Hooks() []Hook {
	return c.hooks.TSLineups
}

// Interceptors returns the client interceptors.
func (c *TSLineupsClient) Interceptors() []Interceptor {
	return c.inters.TSLineups
}

func (c *TSLineupsClient) mutate(ctx context.Context, m *TSLineupsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TSLineupsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TSLineupsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TSLineupsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TSLineupsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TSLineups mutation op: %q", m.Op())
	}
}

// TSPenaltyClient is a client for the TSPenalty schema.
type TSPenaltyClient struct {
	config
}

// NewTSPenaltyClient returns a client for the TSPenalty from the given config.
func NewTSPenaltyClient(c config) *TSPenaltyClient {
	return &TSPenaltyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tspenalty.Hooks(f(g(h())))`.
func (c *TSPenaltyClient) Use(hooks ...Hook) {
	c.hooks.TSPenalty = append(c.hooks.TSPenalty, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tspenalty.Intercept(f(g(h())))`.
func (c *TSPenaltyClient) Intercept(interceptors ...Interceptor) {
	c.inters.TSPenalty = append(c.inters.TSPenalty, interceptors...)
}

// Create returns a builder for creating a TSPenalty entity.
func (c *TSPenaltyClient) Create() *TSPenaltyCreate {
	mutation := newTSPenaltyMutation(c.config, OpCreate)
	return &TSPenaltyCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TSPenalty entities.
func (c *TSPenaltyClient) CreateBulk(builders ...*TSPenaltyCreate) *TSPenaltyCreateBulk {
	return &TSPenaltyCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TSPenalty.
func (c *TSPenaltyClient) Update() *TSPenaltyUpdate {
	mutation := newTSPenaltyMutation(c.config, OpUpdate)
	return &TSPenaltyUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TSPenaltyClient) UpdateOne(tp *TSPenalty) *TSPenaltyUpdateOne {
	mutation := newTSPenaltyMutation(c.config, OpUpdateOne, withTSPenalty(tp))
	return &TSPenaltyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TSPenaltyClient) UpdateOneID(id int) *TSPenaltyUpdateOne {
	mutation := newTSPenaltyMutation(c.config, OpUpdateOne, withTSPenaltyID(id))
	return &TSPenaltyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TSPenalty.
func (c *TSPenaltyClient) Delete() *TSPenaltyDelete {
	mutation := newTSPenaltyMutation(c.config, OpDelete)
	return &TSPenaltyDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TSPenaltyClient) DeleteOne(tp *TSPenalty) *TSPenaltyDeleteOne {
	return c.DeleteOneID(tp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TSPenaltyClient) DeleteOneID(id int) *TSPenaltyDeleteOne {
	builder := c.Delete().Where(tspenalty.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TSPenaltyDeleteOne{builder}
}

// Query returns a query builder for TSPenalty.
func (c *TSPenaltyClient) Query() *TSPenaltyQuery {
	return &TSPenaltyQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTSPenalty},
		inters: c.Interceptors(),
	}
}

// Get returns a TSPenalty entity by its id.
func (c *TSPenaltyClient) Get(ctx context.Context, id int) (*TSPenalty, error) {
	return c.Query().Where(tspenalty.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TSPenaltyClient) GetX(ctx context.Context, id int) *TSPenalty {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTeam queries the team edge of a TSPenalty.
func (c *TSPenaltyClient) QueryTeam(tp *TSPenalty) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := tp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tspenalty.Table, tspenalty.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, tspenalty.TeamTable, tspenalty.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(tp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TSPenaltyClient) Hooks() []Hook {
	return c.hooks.TSPenalty
}

// Interceptors returns the client interceptors.
func (c *TSPenaltyClient) Interceptors() []Interceptor {
	return c.inters.TSPenalty
}

func (c *TSPenaltyClient) mutate(ctx context.Context, m *TSPenaltyMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TSPenaltyCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TSPenaltyUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TSPenaltyUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TSPenaltyDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TSPenalty mutation op: %q", m.Op())
	}
}

// TeamClient is a client for the Team schema.
type TeamClient struct {
	config
}

// NewTeamClient returns a client for the Team from the given config.
func NewTeamClient(c config) *TeamClient {
	return &TeamClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `team.Hooks(f(g(h())))`.
func (c *TeamClient) Use(hooks ...Hook) {
	c.hooks.Team = append(c.hooks.Team, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `team.Intercept(f(g(h())))`.
func (c *TeamClient) Intercept(interceptors ...Interceptor) {
	c.inters.Team = append(c.inters.Team, interceptors...)
}

// Create returns a builder for creating a Team entity.
func (c *TeamClient) Create() *TeamCreate {
	mutation := newTeamMutation(c.config, OpCreate)
	return &TeamCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Team entities.
func (c *TeamClient) CreateBulk(builders ...*TeamCreate) *TeamCreateBulk {
	return &TeamCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Team.
func (c *TeamClient) Update() *TeamUpdate {
	mutation := newTeamMutation(c.config, OpUpdate)
	return &TeamUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TeamClient) UpdateOne(t *Team) *TeamUpdateOne {
	mutation := newTeamMutation(c.config, OpUpdateOne, withTeam(t))
	return &TeamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TeamClient) UpdateOneID(id int) *TeamUpdateOne {
	mutation := newTeamMutation(c.config, OpUpdateOne, withTeamID(id))
	return &TeamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Team.
func (c *TeamClient) Delete() *TeamDelete {
	mutation := newTeamMutation(c.config, OpDelete)
	return &TeamDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TeamClient) DeleteOne(t *Team) *TeamDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TeamClient) DeleteOneID(id int) *TeamDeleteOne {
	builder := c.Delete().Where(team.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TeamDeleteOne{builder}
}

// Query returns a query builder for Team.
func (c *TeamClient) Query() *TeamQuery {
	return &TeamQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTeam},
		inters: c.Interceptors(),
	}
}

// Get returns a Team entity by its id.
func (c *TeamClient) Get(ctx context.Context, id int) (*Team, error) {
	return c.Query().Where(team.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TeamClient) GetX(ctx context.Context, id int) *Team {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySeason queries the season edge of a Team.
func (c *TeamClient) QuerySeason(t *Team) *SeasonQuery {
	query := (&SeasonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(season.Table, season.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, team.SeasonTable, team.SeasonColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClub queries the club edge of a Team.
func (c *TeamClient) QueryClub(t *Team) *ClubQuery {
	query := (&ClubClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(club.Table, club.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, team.ClubTable, team.ClubColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStandings queries the standings edge of a Team.
func (c *TeamClient) QueryStandings(t *Team) *StandingsQuery {
	query := (&StandingsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(standings.Table, standings.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, team.StandingsTable, team.StandingsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHomeFixtures queries the homeFixtures edge of a Team.
func (c *TeamClient) QueryHomeFixtures(t *Team) *FixtureQuery {
	query := (&FixtureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(fixture.Table, fixture.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, team.HomeFixturesTable, team.HomeFixturesColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAwayFixtures queries the awayFixtures edge of a Team.
func (c *TeamClient) QueryAwayFixtures(t *Team) *FixtureQuery {
	query := (&FixtureClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(fixture.Table, fixture.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, team.AwayFixturesTable, team.AwayFixturesColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlayers queries the players edge of a Team.
func (c *TeamClient) QueryPlayers(t *Team) *PlayerQuery {
	query := (&PlayerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(player.Table, player.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, team.PlayersTable, team.PlayersColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryBiggestStats queries the biggest_stats edge of a Team.
func (c *TeamClient) QueryBiggestStats(t *Team) *TSBiggestQuery {
	query := (&TSBiggestClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(tsbiggest.Table, tsbiggest.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, team.BiggestStatsTable, team.BiggestStatsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCardsStats queries the cards_stats edge of a Team.
func (c *TeamClient) QueryCardsStats(t *Team) *TSCardsQuery {
	query := (&TSCardsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(tscards.Table, tscards.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, team.CardsStatsTable, team.CardsStatsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCleanSheetStats queries the clean_sheet_stats edge of a Team.
func (c *TeamClient) QueryCleanSheetStats(t *Team) *TSCleanSheetQuery {
	query := (&TSCleanSheetClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(tscleansheet.Table, tscleansheet.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, team.CleanSheetStatsTable, team.CleanSheetStatsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFailedToScoreStats queries the failed_to_score_stats edge of a Team.
func (c *TeamClient) QueryFailedToScoreStats(t *Team) *TSFailedToScoreQuery {
	query := (&TSFailedToScoreClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(tsfailedtoscore.Table, tsfailedtoscore.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, team.FailedToScoreStatsTable, team.FailedToScoreStatsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFixturesStats queries the fixtures_stats edge of a Team.
func (c *TeamClient) QueryFixturesStats(t *Team) *TSFixturesQuery {
	query := (&TSFixturesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(tsfixtures.Table, tsfixtures.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, team.FixturesStatsTable, team.FixturesStatsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGoalsStats queries the goals_stats edge of a Team.
func (c *TeamClient) QueryGoalsStats(t *Team) *TSGoalsQuery {
	query := (&TSGoalsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(tsgoals.Table, tsgoals.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, team.GoalsStatsTable, team.GoalsStatsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLineups queries the lineups edge of a Team.
func (c *TeamClient) QueryLineups(t *Team) *TSLineupsQuery {
	query := (&TSLineupsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(tslineups.Table, tslineups.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, team.LineupsTable, team.LineupsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPenaltyStats queries the penalty_stats edge of a Team.
func (c *TeamClient) QueryPenaltyStats(t *Team) *TSPenaltyQuery {
	query := (&TSPenaltyClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(tspenalty.Table, tspenalty.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, team.PenaltyStatsTable, team.PenaltyStatsColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeam queries the team edge of a Team.
func (c *TeamClient) QueryTeam(t *Team) *PlayerSeasonQuery {
	query := (&PlayerSeasonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(playerseason.Table, playerseason.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, team.TeamTable, team.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TeamClient) Hooks() []Hook {
	return c.hooks.Team
}

// Interceptors returns the client interceptors.
func (c *TeamClient) Interceptors() []Interceptor {
	return c.inters.Team
}

func (c *TeamClient) mutate(ctx context.Context, m *TeamMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TeamCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TeamUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TeamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TeamDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Team mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Birth, Club, Country, Fixture, League, Player, PlayerSeason, Season, Standings,
		TSBiggest, TSCards, TSCleanSheet, TSFailedToScore, TSFixtures, TSGoals,
		TSLineups, TSPenalty, Team []ent.Hook
	}
	inters struct {
		Birth, Club, Country, Fixture, League, Player, PlayerSeason, Season, Standings,
		TSBiggest, TSCards, TSCleanSheet, TSFailedToScore, TSFixtures, TSGoals,
		TSLineups, TSPenalty, Team []ent.Interceptor
	}
)
